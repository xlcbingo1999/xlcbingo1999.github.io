<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="cn"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://xlcbingo1999.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://xlcbingo1999.github.io/" rel="alternate" type="text/html" hreflang="cn"/><updated>2024-09-03T12:19:52+00:00</updated><id>https://xlcbingo1999.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Ray调度框架介绍</title><link href="https://xlcbingo1999.github.io/blog/2024/Ray/" rel="alternate" type="text/html" title="Ray调度框架介绍"/><published>2024-06-13T00:00:00+00:00</published><updated>2024-06-13T00:00:00+00:00</updated><id>https://xlcbingo1999.github.io/blog/2024/Ray</id><content type="html" xml:base="https://xlcbingo1999.github.io/blog/2024/Ray/"><![CDATA[<p>Redirecting to Ray调度框架介绍</p> <p>如果没看到，请查看这个文档：https://we5lw6jk7r.feishu.cn/wiki/WDFEwtu33it2sTkKj0XcovQKnCf?from=from_copylink</p>]]></content><author><name></name></author><category term="开源项目源码"/><category term="系统-高性能计算"/><summary type="html"><![CDATA[Ray调度框架介绍]]></summary></entry><entry><title type="html">CCTools调度框架介绍</title><link href="https://xlcbingo1999.github.io/blog/2024/CCTools/" rel="alternate" type="text/html" title="CCTools调度框架介绍"/><published>2024-06-13T00:00:00+00:00</published><updated>2024-06-13T00:00:00+00:00</updated><id>https://xlcbingo1999.github.io/blog/2024/CCTools</id><content type="html" xml:base="https://xlcbingo1999.github.io/blog/2024/CCTools/"><![CDATA[<h1 id="cctools">CCTools</h1> <h1 id="应用">应用</h1> <ul> <li>Makeflow 是生物信息常用的一种流程组织工具。详细信息可以参考其<a href="http://ccl.cse.nd.edu/software/makeflow/">官方网站</a>。其优点在于代码可以在本地机器执行的同时也可以按在集群环境进行执行。【参考文献：<a href="http://www.xtaohub.com/Getting-Started/Makeflow-best-pra">http://www.xtaohub.com/Getting-Started/Makeflow-best-pra</a>】</li> </ul> <h1 id="特点">特点</h1> <h2 id="实际任务黑盒化">实际任务黑盒化</h2> <h2 id="bash-命令描述所有的逻辑">Bash 命令描述所有的逻辑</h2> <h2 id="任务的数据依赖需要文件系统的接入">任务的数据依赖需要文件系统的接入</h2> <h2 id="支持简单的资源管理">支持简单的资源管理?</h2> <ul> <li>是否有负载均衡算法或者资源调度算法？</li> </ul> <h2 id="提供-c-和-python-接口">提供 C 和 Python 接口</h2> <h2 id="可以和-parsl-结合使用-parsl-在上层">可以和 Parsl 结合使用: Parsl 在上层</h2> <h1 id="几大组件">几大组件</h1> <h2 id="taskvine">TaskVine</h2> <ul> <li>TaskVine 是一个用于构建在高性能计算 (HPC) 集群、GPU 集群、云服务提供商和其他分布式计算系统上运行的大规模数据密集型动态工作流程的框架。工作流程是以图形结构组织的程序和文件的集合，允许工作流程的各个部分以并行、可重现的方式运行：TaskVine 工作流程需要一个管理器和大量工作进程。应用程序生成大量小任务，并将其分发给 worker。随着任务访问外部数据源并产生自己的输出，越来越多的数据被拉入集群节点上的本地存储。这些数据用于加速未来的任务并避免重新计算现有结果。应用程序“像藤蔓一样”通过集群逐渐生长。</li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/Yskzbim3Zo4JZSxF99zcsvxanqc-480.webp 480w, /assets/img/feishu_docs_static/Yskzbim3Zo4JZSxF99zcsvxanqc-800.webp 800w, /assets/img/feishu_docs_static/Yskzbim3Zo4JZSxF99zcsvxanqc-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/Yskzbim3Zo4JZSxF99zcsvxanqc.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <ul> <li>TaskVine 管理器应用程序可以在 Linux 或 OSX 平台上用 Python 或 C 编写。单个任务可以是简单的 Python 函数、复杂的 Unix 应用程序或无服务器函数调用。关键思想是声明文件对象，然后声明使用它们并生成新文件对象的任务。例如，此代码片段从项目存储库中提取一个输入文件，并运行一个任务来搜索字符串“needle”，生成文件 output.txt</li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="nf">declare_url</span><span class="p">(</span><span class="sh">"</span><span class="s">https://www.gutenberg.org/cache/epub/2600/pg2600.txt</span><span class="sh">"</span><span class="p">)</span>
<span class="n">g</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="nf">declare_file</span><span class="p">(</span><span class="sh">"</span><span class="s">myoutput.txt</span><span class="sh">"</span><span class="p">)</span>

<span class="n">t</span> <span class="o">=</span> <span class="nc">Task</span><span class="p">(</span><span class="sh">"</span><span class="s">grep needle warandpeace.txt &gt; output.txt</span><span class="sh">"</span><span class="p">)</span>
<span class="n">t</span><span class="p">.</span><span class="nf">add_input</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="sh">"</span><span class="s">warandpeace.txt</span><span class="sh">"</span><span class="p">)</span>
<span class="n">t</span><span class="p">.</span><span class="nf">add_output</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="sh">"</span><span class="s">outfile.txt</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <ul> <li>任务共享一组公共选项。<strong>每个任务都可以用其执行所需的资源（CPU 核心、GPU 设备、内存、磁盘空间）进行标记。这允许每个</strong><strong>Worker</strong><strong>打包适当数量的任务。</strong>例如，在 64 核计算机上运行的工作程序可以运行 32 个双核任务、16 个四核任务或总计为 64 个核心的任何其他组合。<strong>如果您不知道所需的资源，</strong><strong>可以通过 Resource Monitor **</strong>来自动跟踪、报告和分配每个任务使用的资源。**</li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">t</span><span class="p">.</span><span class="nf">set_cores</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">t</span><span class="p">.</span><span class="nf">set_memory</span><span class="p">(</span><span class="mi">4096</span><span class="p">)</span>
<span class="n">t</span><span class="p">.</span><span class="nf">set_tag</span><span class="p">(</span><span class="sh">"</span><span class="s">config-4.5.0</span><span class="sh">"</span><span class="p">)</span>

<span class="c1"># this can once again be done at task declaration as well:
</span> <span class="n">t</span> <span class="o">=</span> <span class="n">vine</span><span class="p">.</span><span class="nc">Task</span><span class="p">(</span>
    <span class="n">command</span> <span class="o">=</span> <span class="sh">"</span><span class="s">./gzip &lt; my-file &gt; my-file.gz</span><span class="sh">"</span><span class="p">,</span>
    <span class="n">cores</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">memory</span> <span class="o">=</span> <span class="mi">4096</span><span class="p">,</span>
    <span class="n">tag</span> <span class="o">=</span> <span class="sh">"</span><span class="s">config-4.5.0</span><span class="sh">"</span>
 <span class="p">)</span>
</code></pre></div></div> <ul> <li>TaskVine 很容易部署在现有的 HPC 和云设施上。<strong>工作进程是独立的可执行文件，TaskVine 安排将所有必要的任务依赖项移至工作进程，使系统能够自托管。</strong>应用程序通常包含数以百万计的任务，这些任务运行在数千名 worker 上。提供的工具可轻松在 HTCondor、SLURM 和 Grid Engine 上部署 worker。</li> </ul> <h3 id="三种任务形式">三种任务形式</h3> <ul> <li>标准任务由 Unix 命令行组成</li> <li>Python 任务由 Python 函数及其依赖项组成</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">def</span> <span class="n">my_sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="o">:</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span>

<span class="cp"># task to execute x = my_sum(1, 2)
</span><span class="n">t</span> <span class="o">=</span> <span class="n">vine</span><span class="p">.</span><span class="n">PythonTask</span><span class="p">(</span><span class="n">my_sum</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</code></pre></div></div> <ul> <li>无服务器任务由远程库中的函数调用组成</li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">my_sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span>

<span class="k">def</span> <span class="nf">my_mul</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span>

<span class="n">libtask</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="nf">create_library_from_functions</span><span class="p">(</span><span class="sh">"</span><span class="s">my_library</span><span class="sh">"</span><span class="p">,</span> <span class="n">my_sum</span><span class="p">,</span> <span class="n">my_mul</span><span class="p">)</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">vine</span><span class="p">.</span><span class="nc">FunctionCall</span><span class="p">(</span><span class="sh">"</span><span class="s">my_library</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">my_mul</span><span class="sh">"</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">);</span>
<span class="n">t</span><span class="p">.</span><span class="nf">set_cores</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">t</span><span class="p">.</span><span class="nf">set_memory</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="n">t</span><span class="p">.</span><span class="nf">set_disk</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="n">m</span><span class="p">.</span><span class="nf">submit</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
</code></pre></div></div> <h3 id="taskvine-online-status-display">TaskVine Online Status Display</h3> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/KkY4b61aVot5hjxt5QHcjKfynqh-480.webp 480w, /assets/img/feishu_docs_static/KkY4b61aVot5hjxt5QHcjKfynqh-800.webp 800w, /assets/img/feishu_docs_static/KkY4b61aVot5hjxt5QHcjKfynqh-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/KkY4b61aVot5hjxt5QHcjKfynqh.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <h3 id="taskvine-factory">TaskVine Factory</h3> <ul> <li>可以给每个 worker 配置不同的参数种类！</li> <li>如果您可以访问其他机器，您可以简单地在那里进行 ssh 并运行工作程序。一般来说，启动的 worker 越多，工作完成的速度就越快。如果 worker 失败，TaskVine 基础设施将在其他地方重试工作，因此将许多 worker 提交给不可靠的系统是安全的。</li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">workers</span> <span class="o">=</span> <span class="n">vine</span><span class="p">.</span><span class="nc">Factory</span><span class="p">(</span><span class="sh">"</span><span class="s">condor</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">myproject</span><span class="sh">"</span><span class="p">)</span>
<span class="n">workers</span><span class="p">.</span><span class="n">cores</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">workers</span><span class="p">.</span><span class="n">memory</span> <span class="o">=</span> <span class="mi">4000</span>
<span class="n">workers</span><span class="p">.</span><span class="n">disk</span> <span class="o">=</span> <span class="mi">5000</span>
<span class="n">workers</span><span class="p">.</span><span class="n">max_workers</span> <span class="o">=</span> <span class="mi">20</span>
<span class="k">with</span> <span class="n">workers</span><span class="p">:</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">m</span><span class="p">.</span><span class="nf">empty</span><span class="p">():</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="nf">wait</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
        <span class="bp">...</span>
</code></pre></div></div> <h3 id="更高效的文件管理机制">更高效的文件管理机制</h3> <h4 id="缓存机制--具体实现技术没有很理解">缓存机制 =&gt; 具体实现技术没有很理解</h4> <h4 id="支持执行上下文">支持执行上下文</h4> <ul> <li>已经非常类似容器的管理方案了，可以为每一个执行的进程都配置自己所需要的上下文</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
    <span class="s">"conda"</span><span class="o">:</span> <span class="p">{</span>
        <span class="s">"channels"</span><span class="o">:</span> <span class="p">[</span>
            <span class="s">"conda-forge"</span>
        <span class="p">],</span>
        <span class="s">"dependencies"</span><span class="o">:</span> <span class="p">[</span>
            <span class="s">"python=3.10"</span><span class="p">,</span>
            <span class="s">"numpy=1.24.2"</span>
        <span class="p">]</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="更高效的任务处理机制">更高效的任务处理机制</h3> <h4 id="安全--不关心">安全 =&gt; 不关心</h4> <h4 id="失败重试机制">失败重试机制</h4> <ul> <li>在 TaskVine 中，设计了失败重试机制！</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">t</span><span class="p">.</span><span class="n">set_retries</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>   <span class="err">#</span> <span class="n">Task</span> <span class="n">will</span> <span class="n">be</span> <span class="k">try</span> <span class="n">at</span> <span class="n">most</span> <span class="mi">6</span> <span class="n">times</span> <span class="p">(</span><span class="mi">5</span> <span class="n">retries</span><span class="p">).</span>

<span class="cp"># this can be done at task declaration as well:
</span><span class="n">t</span> <span class="o">=</span> <span class="n">vine</span><span class="p">.</span><span class="n">Task</span><span class="p">(</span>
    <span class="n">command</span> <span class="o">=</span> <span class="p">...,</span>
    <span class="n">retries</span> <span class="o">=</span> <span class="mi">5</span>
<span class="p">)</span>
</code></pre></div></div> <h4 id="流水线提交">流水线提交</h4> <ul> <li>如果您有大量任务要运行，则可能无法提交所有任务，然后等待所有任务。相反，提交少量任务，然后交替等待和提交，以在管理器中保持恒定的数量。饥饿者会告诉您是否需要更多提交：</li> </ul> <h4 id="磁盘文件的自动垃圾回收">磁盘文件的自动垃圾回收</h4> <ul> <li>对于在计算出最终结果后生成不再需要的部分结果的工作流程，当应用程序指示不再需要它们时，TaskVine 可以自动从磁盘中删除它们</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">partial_result</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">declare_file</span><span class="p">(</span><span class="s">"my_partial_result"</span><span class="p">,</span> <span class="n">unlink_when_done</span><span class="o">=</span><span class="n">True</span><span class="p">)</span>

<span class="n">t1</span> <span class="o">=</span> <span class="n">Task</span><span class="p">(...)</span>
<span class="n">t1</span><span class="p">.</span><span class="n">add_output</span><span class="p">(</span><span class="n">partial_result</span><span class="p">,</span> <span class="s">"my_partial_result"</span><span class="p">)</span>
<span class="p">...</span>

<span class="n">t2</span> <span class="o">=</span> <span class="n">Task</span><span class="p">(...)</span>
<span class="n">t2</span><span class="p">.</span><span class="n">add_input</span><span class="p">(</span><span class="n">partial_result</span><span class="p">,</span> <span class="s">"my_partial_result"</span><span class="p">)</span>
<span class="p">...</span>

<span class="cp"># once t2 is done, the following call will remove the file from the
# taskvine workflow. Further, when no task refers to the file, the file
# will be removed from the manager's disk because of unlink_when_done=True
# at its declaration.
</span><span class="n">m</span><span class="p">.</span><span class="n">undeclare_file</span><span class="p">(</span><span class="n">partial_result</span><span class="p">)</span>
</code></pre></div></div> <h4 id="自动断开慢的-workers">自动断开慢的 workers</h4> <ul> <li>大型计算通常会因落后者而减慢速度。如果您有大量需要很短时间的小任务，那么自动断开慢速 worker 的连接会有所帮助。启用此功能后，将保留任务执行时间的统计信息并终止统计异常值。如果同一 worker 中取消了两个不同的任务，则该 worker 将被断开连接并列入黑名单。</li> </ul> <h4 id="支持任务的取消-适合流式任务场景">支持任务的取消: 适合流式任务场景</h4> <ul> <li>此功能在存在冗余任务或随着其他任务完成而变得过时的任务的工作流中非常有用。可以通过 task_id 或 tag 来删除任务。以这种方式删除的任务仍将通过等待以通常的方式返回，结果为 VINE_RESULT_CANCELLED。例如：</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp"># create task as usual and tag it with an arbitrary string.
</span><span class="n">t</span> <span class="o">=</span> <span class="n">vine</span><span class="p">.</span><span class="n">Task</span><span class="p">(...)</span>
<span class="n">t</span><span class="p">.</span><span class="n">set_tag</span><span class="p">(</span><span class="s">"my-tag"</span><span class="p">)</span>

<span class="cp"># or set tag in task declaration
</span><span class="n">t</span> <span class="o">=</span> <span class="n">vine</span><span class="p">.</span><span class="n">Task</span><span class="p">(</span>
    <span class="n">command</span> <span class="o">=</span> <span class="p">...,</span>
    <span class="n">tag</span> <span class="o">=</span> <span class="s">"my-tag"</span>
<span class="p">)</span>

<span class="n">taskid</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">submit</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

<span class="cp"># cancel task by id.
</span><span class="n">m</span><span class="p">.</span><span class="n">cancel_by_taskid</span><span class="p">(</span><span class="n">taskid</span><span class="p">)</span>

<span class="cp"># or cancel task by tag.
</span><span class="n">m</span><span class="p">.</span><span class="n">cancel_by_tasktag</span><span class="p">(</span><span class="s">"my-tag"</span><span class="p">)</span>
</code></pre></div></div> <h3 id="资源管理模块">资源管理模块</h3> <h4 id="task-resources">Task Resources</h4> <ul> <li>要在 worker 中运行多个任务，每个任务都必须有其使用的资源的描述，包括核心、内存、磁盘和 GPU。虽然时间不完全是一种资源，但指定任务的运行时间通常有助于将任务映射到 worker。可以按以下示例指定这些资源： <ul> <li>t.set_cores(1) =&gt; CPU 核心</li> <li>t.set_memory(1024) =&gt; Mem</li> <li>t.set_disk(4096) =&gt; Disk 空间的配置</li> <li>t.set_gpus(0) =&gt; 配置需要的 GPU 数量</li> <li>t.set_time_max(100) =&gt; 任务可以执行的最大时间，实际执行时超过这个时间的任务会被 kill</li> <li>t.set_time_min(10) =&gt; 用户设置的一个最短时间，用于辅助任务在系统中找到合适的 worker</li> </ul> </li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">t</span><span class="p">.</span><span class="n">set_cores</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>           <span class="err">#</span> <span class="n">task</span> <span class="n">needs</span> <span class="n">one</span> <span class="n">core</span>
<span class="n">t</span><span class="p">.</span><span class="n">set_memory</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>       <span class="err">#</span> <span class="n">task</span> <span class="n">needs</span> <span class="mi">1024</span> <span class="n">MB</span> <span class="n">of</span> <span class="n">memory</span>
<span class="n">t</span><span class="p">.</span><span class="n">set_disk</span><span class="p">(</span><span class="mi">4096</span><span class="p">)</span>         <span class="err">#</span> <span class="n">task</span> <span class="n">needs</span> <span class="mi">4096</span> <span class="n">MB</span> <span class="n">of</span> <span class="n">disk</span> <span class="n">space</span>
<span class="n">t</span><span class="p">.</span><span class="n">set_gpus</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>            <span class="err">#</span> <span class="n">task</span> <span class="n">does</span> <span class="n">not</span> <span class="n">need</span> <span class="n">a</span> <span class="n">gpu</span>
<span class="n">t</span><span class="p">.</span><span class="n">set_time_max</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>      <span class="err">#</span> <span class="n">task</span> <span class="n">is</span> <span class="n">allowed</span> <span class="n">to</span> <span class="n">run</span> <span class="n">in</span> <span class="mi">100</span> <span class="n">seconds</span>
<span class="n">t</span><span class="p">.</span><span class="n">set_time_min</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>       <span class="err">#</span> <span class="n">task</span> <span class="n">needs</span> <span class="n">at</span> <span class="n">least</span> <span class="mi">10</span> <span class="n">seconds</span> <span class="n">to</span> <span class="n">run</span> <span class="p">(</span><span class="n">see</span> <span class="n">vine_worker</span> <span class="o">--</span><span class="n">wall</span><span class="o">-</span><span class="n">time</span> <span class="n">option</span> <span class="n">above</span><span class="p">)</span>
<span class="n">t</span><span class="p">.</span><span class="n">add_feature</span><span class="p">(</span><span class="s">"NVIDIA RTX A2000"</span><span class="p">)</span>  <span class="err">#</span> <span class="n">task</span> <span class="k">requires</span> <span class="k">this</span> <span class="n">specific</span> <span class="n">GPU</span> <span class="n">type</span>

<span class="cp"># these can be set when the task is declared as well:
</span> <span class="n">t</span> <span class="o">=</span> <span class="n">vine</span><span class="p">.</span><span class="n">Task</span><span class="p">(</span>
    <span class="n">command</span> <span class="o">=</span> <span class="s">"./gzip &lt; my-file &gt; my-file.gz"</span><span class="p">,</span>
    <span class="n">cores</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">memory</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">,</span>
    <span class="n">disk</span> <span class="o">=</span> <span class="mi">4096</span><span class="p">,</span>
    <span class="n">gpus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">time_max</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
    <span class="n">time_min</span> <span class="o">=</span> <span class="mi">10</span>
<span class="p">)</span>
</code></pre></div></div> <ul> <li>资源分配的主要原则 <ul> <li>如果任务没有指定任何资源，那么它会被分配一个完整的 worker。</li> <li>任务将分配至少与指定资源值一样多的资源。例如，指定两个核心的任务将被分配至少两个核心。</li> <li>如果 GPU 仍未指定，则为任务分配零个 GPU。</li> <li>如果任务指定 GPU，但未指定核心，则为该任务分配零个核心???</li> <li>在所有其他情况下，worker 的核心、内存和磁盘将根据指定任务需求占 worker 资源的最大比例进行平均分配。</li> </ul> </li> </ul> <h4 id="worker-resources">Worker Resources</h4> <ul> <li>默认情况下，worker 尝试使用其正在运行的机器的所有资源。 Worker 启动时会显示检测到的资源。也可以可以手动调整由 worker 管理的资源</li> </ul> <h4 id="factory-resources">Factory Resources</h4> <ul> <li>vine_factory 接受参数 –cores、–memory、–disk 和 –gpus 来设置 worker 的资源配置。</li> </ul> <h4 id="gpu-type-选择">GPU Type 选择</h4> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">t</span><span class="p">.</span><span class="n">add_feature</span><span class="p">(</span><span class="s">"NVIDIA RTX A2000"</span><span class="p">)</span> <span class="err">#</span> <span class="n">task</span> <span class="k">requires</span> <span class="n">worker</span> <span class="n">with</span> <span class="k">this</span> <span class="n">feature</span>
</code></pre></div></div> <h4 id="监控资源的运行情况">监控资源的运行情况</h4> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">t</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="k">if</span> <span class="n">t</span><span class="o">:</span>
    <span class="n">print</span><span class="p">(</span><span class="s">"Task used {} cores, {} MB memory, {} MB disk"</span><span class="p">,</span>
        <span class="n">t</span><span class="p">.</span><span class="n">resources_measured</span><span class="p">.</span><span class="n">cores</span><span class="p">,</span>
        <span class="n">t</span><span class="p">.</span><span class="n">resources_measured</span><span class="p">.</span><span class="n">memory</span><span class="p">,</span>
        <span class="n">t</span><span class="p">.</span><span class="n">resources_measured</span><span class="p">.</span><span class="n">disk</span><span class="p">)</span>
    <span class="n">print</span><span class="p">(</span><span class="s">"Task was allocated {} cores, {} MB memory, {} MB disk"</span><span class="p">,</span>
        <span class="n">t</span><span class="p">.</span><span class="n">resources_requested</span><span class="p">.</span><span class="n">cores</span><span class="p">,</span>
        <span class="n">t</span><span class="p">.</span><span class="n">resources_requested</span><span class="p">.</span><span class="n">memory</span><span class="p">,</span>
        <span class="n">t</span><span class="p">.</span><span class="n">resources_requested</span><span class="p">.</span><span class="n">disk</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">t</span><span class="p">.</span><span class="n">limits_exceeded</span> <span class="n">and</span> <span class="n">t</span><span class="p">.</span><span class="n">limits_exceeded</span><span class="p">.</span><span class="n">cores</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="o">:</span>
        <span class="n">print</span><span class="p">(</span><span class="s">"Task exceeded its cores allocation."</span><span class="p">)</span>
</code></pre></div></div> <h4 id="把具有类似资源需求的任务组合起来">把具有类似资源需求的任务组合起来</h4> <ul> <li>多个任务通常共享相同的资源描述，为此，TaskVine 允许您将任务分为称为类别的组。您可以将资源描述附加到每个类别，然后标记任务以将其设置为类别的一部分。</li> <li>我们可以创建一些类别及其资源描述，如下所示：</li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># memory and disk values in MB.
</span><span class="n">m</span><span class="p">.</span><span class="nf">set_category_resources_max</span><span class="p">(</span><span class="sh">'</span><span class="s">my-category-a</span><span class="sh">'</span><span class="p">,</span> <span class="p">{</span><span class="sh">'</span><span class="s">cores</span><span class="sh">'</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="sh">'</span><span class="s">memory</span><span class="sh">'</span><span class="p">:</span> <span class="mi">1024</span><span class="p">,</span> <span class="sh">'</span><span class="s">disk</span><span class="sh">'</span><span class="p">:</span> <span class="mi">2048</span><span class="p">,</span> <span class="sh">'</span><span class="s">gpus</span><span class="sh">'</span><span class="p">:</span> <span class="mi">0</span><span class="p">})</span>
<span class="n">m</span><span class="p">.</span><span class="nf">set_category_resources_max</span><span class="p">(</span><span class="sh">'</span><span class="s">my-category-b</span><span class="sh">'</span><span class="p">,</span> <span class="p">{</span><span class="sh">'</span><span class="s">cores</span><span class="sh">'</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span>
<span class="n">m</span><span class="p">.</span><span class="nf">set_category_resources_max</span><span class="p">(</span><span class="sh">'</span><span class="s">my-category-c</span><span class="sh">'</span><span class="p">,</span> <span class="p">{})</span>
</code></pre></div></div> <h4 id="自动资源管理">自动资源管理</h4> <ul> <li><strong>如果类别使用的资源未知，则可以引导 TaskVine 找到有效的资源值，以最大化吞吐量或最小化资源浪费。</strong>在这些模式中，如果使用 set_resources_max 设置资源值，则将其用作理论最大值。</li> <li>自动计算资源时，如果 set_resources_max 中未指定任何核心、内存或磁盘，那么 TaskVine 将使用整个 worker 运行一些任务来收集一些资源使用统计信息。如果设置了所有核心、内存和磁盘，则 TaskVine 将使用这些最大值，而不是使用整个 worker。和之前一样，未指定的 GPU 默认为 0。</li> <li>一旦一些统计数据可用，如果这种更改会增加吞吐量，则可以使用较小的分配来运行更多任务。如果任务耗尽其资源，将使用 set_resources_max 的值或整个 worker 重试，如前所述。</li> </ul> <h3 id="性能管理模块">性能管理模块</h3> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/KoTlbFUf2o540txfb3acqv1JnQh-480.webp 480w, /assets/img/feishu_docs_static/KoTlbFUf2o540txfb3acqv1JnQh-800.webp 800w, /assets/img/feishu_docs_static/KoTlbFUf2o540txfb3acqv1JnQh-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/KoTlbFUf2o540txfb3acqv1JnQh.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/PdBvb9wS2oiO7rxz7LkcmwmanTe-480.webp 480w, /assets/img/feishu_docs_static/PdBvb9wS2oiO7rxz7LkcmwmanTe-800.webp 800w, /assets/img/feishu_docs_static/PdBvb9wS2oiO7rxz7LkcmwmanTe-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/PdBvb9wS2oiO7rxz7LkcmwmanTe.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/IVTLbfzlxoRZJ2xtSbIcme8vnZb-480.webp 480w, /assets/img/feishu_docs_static/IVTLbfzlxoRZJ2xtSbIcme8vnZb-800.webp 800w, /assets/img/feishu_docs_static/IVTLbfzlxoRZJ2xtSbIcme8vnZb-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/IVTLbfzlxoRZJ2xtSbIcme8vnZb.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <h3 id="workflow-integration">Workflow Integration</h3> <h4 id="和-parsl-集成">和 Parsl 集成</h4> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/QFuyb9n7aoSFZqxP3m8cW0pFnqc-480.webp 480w, /assets/img/feishu_docs_static/QFuyb9n7aoSFZqxP3m8cW0pFnqc-800.webp 800w, /assets/img/feishu_docs_static/QFuyb9n7aoSFZqxP3m8cW0pFnqc-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/QFuyb9n7aoSFZqxP3m8cW0pFnqc.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <ul> <li>TaskVine 可以用作 Parsl 工作流的工作流执行引擎，补充 Parsl 的资源管理能力</li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">parsl</span>
<span class="kn">from</span> <span class="n">parsl</span> <span class="kn">import</span> <span class="n">python_app</span>
<span class="kn">from</span> <span class="n">parsl.config</span> <span class="kn">import</span> <span class="n">Config</span>
<span class="kn">from</span> <span class="n">parsl.executors.taskvine</span> <span class="kn">import</span> <span class="n">TaskVineExecutor</span>
<span class="kn">from</span> <span class="n">parsl.executors.taskvine</span> <span class="kn">import</span> <span class="n">TaskVineFactoryConfig</span>
<span class="kn">from</span> <span class="n">parsl.executors.taskvine</span> <span class="kn">import</span> <span class="n">TaskVineManagerConfig</span>

<span class="n">config</span> <span class="o">=</span> <span class="nc">Config</span><span class="p">(</span>
    <span class="n">executors</span><span class="o">=</span><span class="p">[</span>
        <span class="nc">TaskVineExecutor</span><span class="p">(</span>
            <span class="n">factory_config</span><span class="o">=</span><span class="nc">TaskVineFactoryConfig</span><span class="p">(</span>
                <span class="n">batch_type</span><span class="o">=</span><span class="sh">"</span><span class="s">condor</span><span class="sh">"</span><span class="p">,</span>
                <span class="n">min_workers</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">max_workers</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">cores</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span>
            <span class="p">),</span>
            <span class="n">manager_config</span><span class="o">=</span><span class="nc">TaskVineManagerConfig</span><span class="p">(</span>
                <span class="n">project_name</span><span class="o">=</span><span class="sh">"</span><span class="s">taskvine_parsl</span><span class="sh">"</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="p">]</span>
<span class="p">)</span>

<span class="n">parsl</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="n">Config</span><span class="p">)</span>

<span class="n">l</span> <span class="o">=</span> <span class="p">[</span><span class="sh">"</span><span class="s">Cooperative</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">Computing</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">Lab</span><span class="sh">"</span><span class="p">]</span>

<span class="nd">@python_app</span>
<span class="k">def</span> <span class="nf">hello_taskvine</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">l</span><span class="o">=</span><span class="n">l</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">l</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>

<span class="n">futures</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
    <span class="n">futures</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nf">hello_taskvine</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">futures</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="nf">result</span><span class="p">())</span>
</code></pre></div></div> <h4 id="和-dask-集成">和 Dask 集成</h4> <ul> <li>TaskVine 可用于使用管理器作为 Dask 调度程序来执行 Dask 工作流程。 DaskVine 类实现了一个 TaskVine 管理器，它有一个 get 方法</li> </ul> <h2 id="work-queue">Work Queue</h2> <p>工作队列（Work Queue）是一个用于构建大型管理者-工作者应用程序的框架。使用工作队列库，你可以创建一个自定义管理程序，定义并提交大量小型任务。每个任务都分配给一个远程工作进程，由其执行并返回结果。随着结果的产生，管理器可能会生成更多任务来执行。编写将数百万个任务分配给数千个远程工作者的程序并不罕见。</p> <h2 id="makeflow">Makeflow</h2> <p>Makeflow 是用于大规模分布式计算的工作流引擎。它接受要执行的大量工作的规范，并尽可能在远程计算机上并行运行。此外，Makeflow 是容错的，因此您可以使用它来协调非常大的任务，这些任务可能在出现故障时运行数天或数周。Makeflow 的设计与 Make 类似，因此如果可以编写 Makefile，那么就可以编写 Makeflow。</p> <p>Makeflow 使得将大量工作从一个设施移动到另一个设施变得很容易。在编写了一个工作流之后，您可以在本地笔记本电脑上进行测试，然后在您的大学计算中心运行它，将其转移到类似 XSEDE 这样的国家级计算设施，然后再转到商业云系统。使用（捆绑的）工作队列系统，您甚至可以同时跨多个系统运行。无论您在何处运行任务，工作流语言都保持不变。</p> <p>Makeflow 在生产中用于支持科学和工程中的大规模问题。生物信息学、生物特征学、地理学和高能物理等领域的研究人员都使用 Makeflow 从现有应用程序中组合工作流。</p> <p>Makeflow 可以将您的作业发送到各种各样的服务，例如批处理系统（HTCondor、SGE、PBS、Torque）、集群管理器（Mesos 和 Kubernetes）、云服务（amazonec2 或 Lambda）和容器环境（如 Docker 和 Singularity）。批处理系统支持部分提供了每个系统的详细信息。</p> <h2 id="resource-monitor-低配版-automap">Resource Monitor: 低配版 Automap</h2> <ul> <li>resources_monitor 是一个工具，用于监视由作为参数给出的命令及其所有后代创建的<strong>进程</strong>所使用的计算资源。监视器间接工作，即通过观察<strong>进程运行时</strong>环境如何变化，因此报告的所有信息都应被视为估计。</li> <li> <p>resource_monitor 最多生成三个日志文件：</p> <ul> <li>一个 JSON 编码的摘要文件，其中包含<strong>所用资源的最大值及其发生时间</strong></li> <li>a time-series that shows the resources used at given time intervals</li> <li>执行期间打开的文件列表： resource_monitor 可以设置为根据某些文件中的事件（例如，当创建、删除文件或文件中出现正则表达式模式时）生成测量快照。最大资源限制可以以文件或命令行给出的字符串的形式指定。如果其中一项资源超出了指定的限制，则监视器将终止任务，并报告哪个资源超出了相应的限制。</li> </ul> </li> <li>JSON 编码的摘要文件包含的信息</li> <li>时间序列日志每个时间样本都有一行。对于每一行，各列具有以下含义：</li> </ul> <h2 id="jx-language">JX Language</h2> <ul> <li>支持使用 JX 工作流语言描述，使得整个工作流的描述非常便捷</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
    <span class="s">"define"</span> <span class="o">:</span> <span class="p">{</span>
        <span class="s">"RANGE"</span>    <span class="o">:</span> <span class="n">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span>
        <span class="s">"FILELIST"</span> <span class="o">:</span> <span class="p">[</span> <span class="s">"output."</span> <span class="o">+</span> <span class="n">N</span> <span class="o">+</span> <span class="s">".txt"</span> <span class="k">for</span> <span class="n">N</span> <span class="n">in</span> <span class="n">RANGE</span> <span class="p">],</span>
    <span class="p">},</span>

    <span class="s">"categories"</span> <span class="o">:</span> <span class="p">{</span>
        <span class="s">"simulate"</span> <span class="o">:</span> <span class="p">{</span>
                        <span class="s">"resources"</span> <span class="o">:</span> <span class="p">{</span> <span class="s">"cores"</span> <span class="o">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s">"memory"</span> <span class="o">:</span> <span class="mi">512</span><span class="p">,</span> <span class="s">"disk"</span> <span class="o">:</span> <span class="mi">1024</span> <span class="p">}</span>
        <span class="p">},</span>
        <span class="s">"collect"</span>  <span class="o">:</span> <span class="p">{</span>
                        <span class="s">"resources"</span> <span class="o">:</span> <span class="p">{</span> <span class="s">"cores"</span> <span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s">"memory"</span> <span class="o">:</span> <span class="mi">512</span><span class="p">,</span> <span class="s">"disk"</span> <span class="o">:</span> <span class="mi">8192</span> <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">},</span>

    <span class="s">"rules"</span> <span class="o">:</span> <span class="p">[</span>
                <span class="p">{</span>
                    <span class="s">"command"</span>  <span class="o">:</span> <span class="s">"python ./simulate.py --parameter "</span> <span class="o">+</span> <span class="n">N</span> <span class="o">+</span> <span class="s">" &gt; output."</span><span class="o">+</span><span class="n">N</span><span class="o">+</span><span class="s">".txt"</span><span class="p">,</span>
                    <span class="s">"inputs"</span>   <span class="o">:</span> <span class="p">[</span> <span class="s">"simulate.py"</span> <span class="p">],</span>
                    <span class="s">"outputs"</span>  <span class="o">:</span> <span class="p">[</span> <span class="s">"output."</span> <span class="o">+</span> <span class="n">N</span> <span class="o">+</span> <span class="s">".txt"</span> <span class="p">],</span>
                    <span class="s">"category"</span> <span class="o">:</span> <span class="s">"simulate"</span>
                <span class="p">}</span> <span class="k">for</span> <span class="n">N</span> <span class="n">in</span> <span class="n">RANGE</span><span class="p">,</span>
                <span class="p">{</span>
                    <span class="s">"command"</span>  <span class="o">:</span> <span class="s">"/bin/cat "</span> <span class="o">+</span> <span class="n">join</span><span class="p">(</span><span class="n">FILELIST</span><span class="p">,</span><span class="s">" "</span><span class="p">)</span> <span class="o">+</span> <span class="s">" &gt; output.all.txt"</span><span class="p">,</span>
                    <span class="s">"inputs"</span>   <span class="o">:</span> <span class="n">FILELIST</span><span class="p">,</span>
                    <span class="s">"outputs"</span>  <span class="o">:</span> <span class="p">[</span> <span class="s">"output.all.txt"</span> <span class="p">],</span>
                    <span class="s">"category"</span> <span class="o">:</span> <span class="s">"collect"</span>
                <span class="p">}</span>
              <span class="p">]</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="开源项目源码"/><category term="系统-高性能计算"/><summary type="html"><![CDATA[CCTools调度框架介绍]]></summary></entry><entry><title type="html">RADICAL-Cybertools调度框架介绍</title><link href="https://xlcbingo1999.github.io/blog/2024/RADICAL-Cybertools/" rel="alternate" type="text/html" title="RADICAL-Cybertools调度框架介绍"/><published>2024-05-22T00:00:00+00:00</published><updated>2024-05-22T00:00:00+00:00</updated><id>https://xlcbingo1999.github.io/blog/2024/RADICAL-Cybertools</id><content type="html" xml:base="https://xlcbingo1999.github.io/blog/2024/RADICAL-Cybertools/"><![CDATA[<blockquote> <p>更好的排版请阅读: https://we5lw6jk7r.feishu.cn/wiki/KQGIw9x6Li549gkUOfWcRRlYnmh?from=from_copylink</p> </blockquote> <h1 id="radical-cybertools">RADICAL Cybertools</h1> <ul> <li>RADICAL-Cybertools 是一套基于抽象的明确定义的功能，专为可扩展、可互操作和可持续的方法而设计，以支持一系列高性能和分布式计算系统上的科学。</li> <li> <p>它目前由三个组件组成：</p> <ul> <li>RADICAL-SAGA：一个基于标准的接口，提供跨一系列计算中间件的基本互操作性 【RADICAL Cybertools 堆栈的基础设施访问层。它为大多数生产 HPC 排队系统、网格和云服务提供同质编程接口。 RADICAL-SAGA 支持 XSDE 和 OSG 资源以及学术和商业云计算平台。】</li> <li>RADICAL-Pilot：一个可扩展且灵活的 Pilot-Job 系统，提供灵活的应用程序级资源管理功能</li> <li>Ensemble Toolkit (RADICAL-EnTK)： 简化实现基于集成的应用程序的能力【提供了一种简单的方法来开发由多个任务组成并遵循预定义模式的应用程序。该工具预定义了常见的执行模式，因此用户可以快速调整该工具包以满足他们的需求；可以定义更复杂的执行模式。通过基于 RADICAL-Pilot 构建，Ensemble Toolkit 可以利用灵活且可扩展的资源管理技术。】</li> </ul> </li> <li> <p>特点</p> <ul> <li>实际任务黑盒化: 没有任何的任务图内部节点的优化逻辑</li> <li>bash 描述所有逻辑</li> <li>任务数据依赖需要文件系统的接入</li> <li>异构的支持在于实际任务放置节点的支持程度</li> </ul> </li> </ul> <h1 id="radical-entk">RADICAL-EnTK</h1> <h2 id="常见模式-ensemble-of-pipelines">常见模式: Ensemble of Pipelines</h2> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/UP37b4iAWoJmlpxdgmMctjPrnYf-480.webp 480w, /assets/img/feishu_docs_static/UP37b4iAWoJmlpxdgmMctjPrnYf-800.webp 800w, /assets/img/feishu_docs_static/UP37b4iAWoJmlpxdgmMctjPrnYf-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/UP37b4iAWoJmlpxdgmMctjPrnYf.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <ul> <li>Pipeline 并行执行</li> <li>Pipeline 中的 Stage 是串行的，由 Barrier 管理其同步</li> <li>Stage 中的 Task 是并行的，执行的程序理应是类似的逻辑</li> </ul> <h2 id="常见模式-sequence-of-workflows">常见模式: Sequence of Workflows</h2> <ul> <li>另一种常见的执行模式由同会话顺序工作流程组成，其中多个并发管道具有多个阶段，其中每个阶段由多个任务组成。我们称之为工作流程序列。</li> <li>在以下示例中，我们创建 2 个 Sequence of Workflows，每个工作流有 2 个 Pipeline，每个管道有 3 个 Stage。出于演示目的，每个任务除了“睡眠”3 秒之外什么都不做。该示例建议使用 autoterminate=False 启动 AppManager，并在所有管道完成后使用 appman.terminate()。这允许您对第二个工作流程使用相同的应用程序管理器。</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#!/usr/bin/env python
</span>
<span class="n">from</span> <span class="n">radical</span><span class="p">.</span><span class="n">entk</span> <span class="k">import</span> <span class="n">Pipeline</span><span class="p">,</span> <span class="n">Stage</span><span class="p">,</span> <span class="n">Task</span><span class="p">,</span> <span class="n">AppManager</span>


<span class="n">def</span> <span class="n">generate_pipeline</span><span class="p">()</span><span class="o">:</span>

    <span class="n">p</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">()</span>
    <span class="n">s1</span> <span class="o">=</span> <span class="n">Stage</span><span class="p">()</span>

    <span class="n">t1</span> <span class="o">=</span> <span class="n">Task</span><span class="p">()</span>
    <span class="n">t1</span><span class="p">.</span><span class="n">executable</span> <span class="o">=</span> <span class="err">'</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">sleep</span><span class="err">'</span>
    <span class="n">t1</span><span class="p">.</span><span class="n">arguments</span> <span class="o">=</span> <span class="p">[</span><span class="sc">'3'</span><span class="p">]</span>

    <span class="n">s1</span><span class="p">.</span><span class="n">add_tasks</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span>

    <span class="n">p</span><span class="p">.</span><span class="n">add_stages</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span>
    <span class="n">s2</span> <span class="o">=</span> <span class="n">Stage</span><span class="p">()</span>
    <span class="n">t2</span> <span class="o">=</span> <span class="n">Task</span><span class="p">()</span>
    <span class="n">t2</span><span class="p">.</span><span class="n">executable</span> <span class="o">=</span> <span class="err">'</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">sleep</span><span class="err">'</span>
    <span class="n">t2</span><span class="p">.</span><span class="n">arguments</span> <span class="o">=</span> <span class="p">[</span><span class="sc">'3'</span><span class="p">]</span>

    <span class="n">s2</span><span class="p">.</span><span class="n">add_tasks</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span>
    <span class="n">p</span><span class="p">.</span><span class="n">add_stages</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span>
    <span class="n">s3</span> <span class="o">=</span> <span class="n">Stage</span><span class="p">()</span>

    <span class="n">t3</span> <span class="o">=</span> <span class="n">Task</span><span class="p">()</span>
    <span class="n">t3</span><span class="p">.</span><span class="n">executable</span> <span class="o">=</span> <span class="err">'</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">sleep</span><span class="err">'</span>
    <span class="n">t3</span><span class="p">.</span><span class="n">arguments</span> <span class="o">=</span> <span class="p">[</span><span class="sc">'3'</span><span class="p">]</span>

    <span class="n">s3</span><span class="p">.</span><span class="n">add_tasks</span><span class="p">(</span><span class="n">t3</span><span class="p">)</span>
    <span class="n">p</span><span class="p">.</span><span class="n">add_stages</span><span class="p">(</span><span class="n">s3</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">p</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="err">'</span><span class="n">__main__</span><span class="err">'</span><span class="o">:</span>

    <span class="n">appman</span>   <span class="o">=</span> <span class="n">AppManager</span><span class="p">()</span>
    <span class="n">res_dict</span> <span class="o">=</span> <span class="p">{</span>
        <span class="err">'</span><span class="n">resource</span><span class="err">'</span><span class="o">:</span> <span class="err">'</span><span class="n">local</span><span class="p">.</span><span class="n">localhost</span><span class="err">'</span><span class="p">,</span>
        <span class="err">'</span><span class="n">walltime</span><span class="err">'</span><span class="o">:</span> <span class="mi">10</span><span class="p">,</span>
        <span class="err">'</span><span class="n">cpus</span><span class="err">'</span>    <span class="o">:</span>  <span class="mi">8</span>
    <span class="p">}</span>
    <span class="n">appman</span><span class="p">.</span><span class="n">resource_desc</span> <span class="o">=</span> <span class="n">res_dict</span>


    <span class="n">pipelines</span> <span class="o">=</span> <span class="n">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">cnt</span> <span class="n">in</span> <span class="n">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">:</span>
        <span class="n">pipelines</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">generate_pipeline</span><span class="p">())</span>

    <span class="n">appman</span><span class="p">.</span><span class="n">workflow</span> <span class="o">=</span> <span class="n">set</span><span class="p">(</span><span class="n">pipelines</span><span class="p">)</span>
    <span class="n">appman</span><span class="p">.</span><span class="n">run</span><span class="p">()</span>

    <span class="n">print</span><span class="p">(</span><span class="err">'</span><span class="mi">1</span> <span class="o">===================================================</span><span class="err">'</span><span class="p">)</span>


    <span class="n">pipelines</span> <span class="o">=</span> <span class="n">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">cnt</span> <span class="n">in</span> <span class="n">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">:</span>
        <span class="n">pipelines</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">generate_pipeline</span><span class="p">())</span>

    <span class="n">appman</span><span class="p">.</span><span class="n">workflow</span> <span class="o">=</span> <span class="n">set</span><span class="p">(</span><span class="n">pipelines</span><span class="p">)</span>
    <span class="n">appman</span><span class="p">.</span><span class="n">run</span><span class="p">()</span>

    <span class="n">print</span><span class="p">(</span><span class="err">'</span><span class="mi">2</span> <span class="o">===================================================</span><span class="err">'</span><span class="p">)</span>

    <span class="n">appman</span><span class="p">.</span><span class="n">terminate</span><span class="p">()</span>

    <span class="n">print</span><span class="p">(</span><span class="err">'</span><span class="n">t</span> <span class="o">===================================================</span><span class="err">'</span><span class="p">)</span>
</code></pre></div></div> <h2 id="类图">类图</h2> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/Y5JMbZP4soPUnzxvD61coexdn6e-480.webp 480w, /assets/img/feishu_docs_static/Y5JMbZP4soPUnzxvD61coexdn6e-800.webp 800w, /assets/img/feishu_docs_static/Y5JMbZP4soPUnzxvD61coexdn6e-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/Y5JMbZP4soPUnzxvD61coexdn6e.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <h2 id="顺序流图">顺序流图</h2> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/DlIzbjK4GoBzcZxXajQcs0bnn4f-480.webp 480w, /assets/img/feishu_docs_static/DlIzbjK4GoBzcZxXajQcs0bnn4f-800.webp 800w, /assets/img/feishu_docs_static/DlIzbjK4GoBzcZxXajQcs0bnn4f-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/DlIzbjK4GoBzcZxXajQcs0bnn4f.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <h2 id="状态转换图">状态转换图</h2> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/AOZBbDypWoon8txbMj2cezRWnwb-480.webp 480w, /assets/img/feishu_docs_static/AOZBbDypWoon8txbMj2cezRWnwb-800.webp 800w, /assets/img/feishu_docs_static/AOZBbDypWoon8txbMj2cezRWnwb-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/AOZBbDypWoon8txbMj2cezRWnwb.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div>]]></content><author><name></name></author><category term="开源项目源码"/><category term="系统-高性能计算"/><summary type="html"><![CDATA[RADICAL-Cybertools调度框架介绍]]></summary></entry><entry><title type="html">Parsl调度框架介绍</title><link href="https://xlcbingo1999.github.io/blog/2024/Parsl/" rel="alternate" type="text/html" title="Parsl调度框架介绍"/><published>2024-05-18T00:00:00+00:00</published><updated>2024-05-18T00:00:00+00:00</updated><id>https://xlcbingo1999.github.io/blog/2024/Parsl</id><content type="html" xml:base="https://xlcbingo1999.github.io/blog/2024/Parsl/"><![CDATA[<blockquote> <p>更好的排版请阅读: https://we5lw6jk7r.feishu.cn/wiki/ZRXVwWjgLi5Mz5kJnJjcjufGnCe?from=from_copylink</p> </blockquote> <h1 id="parsl">Parsl</h1> <h1 id="特点">特点</h1> <h2 id="实际任务黑盒化-没有任何的任务图内部节点的优化逻辑">实际任务黑盒化: 没有任何的任务图内部节点的优化逻辑</h2> <h2 id="pythonbash-描述所有逻辑">python+bash 描述所有逻辑</h2> <h2 id="任务数据依赖需要文件系统的接入">任务数据依赖需要文件系统的接入</h2> <ul> <li>在 bash_app 中，return 用于表示这个 task 需要执行的 shell 脚本具体内容，然后 bash_app 的输出结果是需要用文件进行同步的。如果是 python_app 不会遇到这个问题，return 的是 AppFuture 直接获取返回值即可。所以，在多元应用中，无法全部都用 Python 任务逻辑表达的时候，是需要依赖文件进行数据的同步的！</li> </ul> <h2 id="executors-抽象适合将规模扩展到万节点以上规模">Executors 抽象适合将规模扩展到万节点以上规模</h2> <h1 id="带着问题看">带着问题看</h1> <h2 id="是否支持异构">是否支持异构？</h2> <h3 id="宏观角度看异构设备">宏观角度看异构设备</h3> <ul> <li>Cuda：只看到简单的应用</li> <li>OpenMP：看到在 mpi 的测试用例里面使用</li> <li>HIP：没看到</li> <li>sycl/kokkos：没看到</li> </ul> <h3 id="executors-逻辑处理器-类似-legion-的-processor">Executors 逻辑处理器 [类似 Legion 的 Processor]</h3> <ul> <li>parsl.executors.ThreadPoolExecutor: 支持本地的多线程</li> <li>parsl.executors.HighThroughputExecutor: 该执行器使用试点作业模型实现分层调度和批处理，以在多达 4000 个节点上提供高吞吐量任务执行。</li> <li>parsl.executors.WorkQueueExecutor: 集成了 zmp 的工作队列，可以扩展到万级核心，并且可以通过动态资源调整实现任务的可靠执行。</li> <li>parsl.executors.taskvine.TaskVineExecutor：该执行器使用 TaskVine 作为执行后端。 TaskVine 可扩展到数万个核心，并积极使用计算节点上的本地存储来提供各种以性能为导向的功能，包括：智能缓存并在任务和计算节点之间共享公共大文件、任务的可靠执行、动态资源大小调整、自动 Python 环境检测和共享。这些执行器涵盖了广泛的执行要求。与其他 Parsl 组件一样，有一个标准接口 (ParslExecutor) 可以实现以添加对其他执行器的支持。</li> </ul> <h3 id="execution-providers-与资源提供者的交互-结合-slurm">Execution providers: 与资源提供者的交互 [结合 Slurm]</h3> <ul> <li>资源提供者允许 Parsl 获得计算能力。对于超级计算机，获取资源通常需要向调度程序（例如 Slurm）请求资源。 Parsl 提供商代表您编写申请“块”（例如超级计算机节点）的请求。 Parsl 预先打包了与大多数超级计算机和一些云计算服务兼容的提供程序。</li> <li>云、超级计算机和本地 PC 提供截然不同的访问模式。</li> <li> <p>主要的 Execution providers</p> <ul> <li>parsl.providers.LocalProvider：该提供程序允许您在笔记本电脑或工作站上本地运行。</li> <li>parsl.providers.CobaltProvider：此提供程序允许您通过 Cobalt 调度程序来调度资源。该提供程序已弃用，并将于 2024 年 4 月删除。</li> <li>parsl.providers.SlurmProvider：此提供程序允许您通过 Slurm 调度程序来调度资源。</li> <li>parsl.providers.CondorProvider：此提供程序允许您通过 Condor 调度程序来调度资源。</li> <li>parsl.providers.GridEngineProvider：此提供程序允许您通过 GridEngine 调度程序来调度资源。</li> <li>parsl.providers.TorqueProvider：此提供程序允许您通过 Torque 调度程序来调度资源。</li> <li>parsl.providers.AWSProvider：此提供程序允许您从 Amazon Web Services 供应和管理云节点。</li> <li>parsl.providers.GoogleCloudProvider：此提供商允许您从 Google Cloud 预配和管理云节点。</li> <li>parsl.providers.KubernetesProvider：此提供程序允许您在 Kubernetes 集群上配置和管理容器。</li> <li>parsl.providers.AdHocProvider：此提供程序允许您管理节点集合上的执行以形成临时集群。</li> <li>parsl.providers.LSFProvider：该提供程序允许您通过 IBM 的 LSF 调度程序来调度资源。</li> </ul> </li> </ul> <h2 id="是否支持分布式-支持">是否支持分布式？ 支持</h2> <ul> <li>看代码是通过 zmq 消息队列进行一些传输</li> </ul> <h3 id="launchers-分布式任务发射器">Launchers: 分布式任务发射器</h3> <ul> <li>Launchers 定义了如何将工作人员分散到块中可用的所有节点上。一个常见的例子是 MPILauncher，它使用 MPI 的机制在多个计算节点上启动单个程序。与 Provider 一样，Parsl 附带了适用于大多数超级计算机和云的启动器。</li> <li> <p>主要的 Launcher</p> <ul> <li>parsl.launchers.SrunLauncher：基于 Srun 的启动器，适用于基于 Slurm 的系统。</li> <li>parsl.launchers.AprunLauncher：Crays 的基于 Aprun 的启动器。</li> <li>parsl.launchers.SrunMPILauncher：用于使用 Srun 启动 MPI 应用程序的启动器。</li> <li>parsl.launchers.GnuParallelLauncher：使用 GNU 并行的启动器跨节点和核心启动工作程序。</li> <li>parsl.launchers.MpiExecLauncher：使用 Mpiexec 启动。</li> <li>parsl.launchers.SimpleLauncher：启动器默认为单个工作程序启动。</li> <li>parsl.launchers.SingleNodeLauncher：此启动器在单个节点上启动 workers_per_node 计数 worker。</li> </ul> </li> </ul> <h2 id="如何支持多元任务">如何支持多元任务</h2> <ul> <li>核心：把任务包装成 @python_app ，然后发射到后端执行，非阻塞返回一个 future，最终通过 future.result()获取执行的结果</li> <li> <p>主要的两种抽象任务【主要的服务对象都是顶层的前端脚本语言】</p> <ul> <li>python_app</li> <li>bash_app： 用于执行 bash 脚本</li> </ul> </li> <li> <p>一些神奇的内容</p> <ul> <li>parsl/tests/integration/test_channels 里包含 ssh, scp 的相关内容</li> </ul> </li> </ul> <h2 id="如何进行任务依赖管理">如何进行任务依赖管理</h2> <h3 id="data-flow-kernel-dfk">Data-Flow Kernel (DFK)</h3> <h2 id="如何管理数据">如何管理数据</h2> <h3 id="数据传输方案-files-通过文件来进行任务间数据的传递">数据传输方案 Files： 通过文件来进行任务间数据的传递</h3> <ul> <li>缺点：效率也太低下了</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="n">parsl</span>
<span class="n">from</span> <span class="n">parsl</span><span class="p">.</span><span class="n">data_provider</span><span class="p">.</span><span class="n">files</span> <span class="k">import</span> <span class="n">File</span>
<span class="n">from</span> <span class="n">parsl</span> <span class="k">import</span> <span class="n">bash_app</span>
<span class="k">import</span> <span class="n">os</span>

<span class="n">parsl</span><span class="p">.</span><span class="n">load</span><span class="p">()</span>

<span class="err">@</span><span class="n">bash_app</span>
<span class="n">_def_</span> <span class="n">cat</span><span class="p">(</span><span class="n">_inputs_</span><span class="o">=</span><span class="p">[],</span> <span class="n">_outputs_</span><span class="o">=</span><span class="p">[])</span><span class="o">:</span>
    <span class="k">return</span> <span class="err">'</span><span class="n">cat</span> <span class="p">{}</span> <span class="o">&gt;</span> <span class="p">{}</span><span class="err">'</span><span class="p">.</span><span class="n">format</span><span class="p">(</span><span class="s">" "</span><span class="p">.</span><span class="n">join</span><span class="p">([</span><span class="n">i</span><span class="p">.</span><span class="n">filepath</span> <span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="n">_inputs_</span><span class="p">]),</span> <span class="n">_outputs_</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="n">concat</span> <span class="o">=</span> <span class="n">cat</span><span class="p">(</span><span class="n">_inputs_</span><span class="o">=</span><span class="p">[</span><span class="n">File</span><span class="p">(</span><span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="p">.</span><span class="n">getcwd</span><span class="p">(),</span> <span class="err">'</span><span class="n">hello</span><span class="o">-</span><span class="mf">0.</span><span class="n">txt</span><span class="err">'</span><span class="p">)),</span>
                    <span class="n">File</span><span class="p">(</span><span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="p">.</span><span class="n">getcwd</span><span class="p">(),</span> <span class="err">'</span><span class="n">hello</span><span class="o">-</span><span class="mf">1.</span><span class="n">txt</span><span class="err">'</span><span class="p">)),</span>
                    <span class="n">File</span><span class="p">(</span><span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="p">.</span><span class="n">getcwd</span><span class="p">(),</span> <span class="err">'</span><span class="n">hello</span><span class="o">-</span><span class="mf">2.</span><span class="n">txt</span><span class="err">'</span><span class="p">))],</span>
             <span class="n">_outputs_</span><span class="o">=</span><span class="p">[</span><span class="n">File</span><span class="p">(</span><span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="p">.</span><span class="n">getcwd</span><span class="p">(),</span> <span class="err">'</span><span class="n">all_hellos</span><span class="p">.</span><span class="n">txt</span><span class="err">'</span><span class="p">))])</span>

<span class="cp"># Open the concatenated file
</span><span class="n">with</span> <span class="n">open</span><span class="p">(</span><span class="n">concat</span><span class="p">.</span><span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">result</span><span class="p">(),</span> <span class="sc">'r'</span><span class="p">)</span> <span class="n">as</span> <span class="n">f</span><span class="o">:</span>
     <span class="n">print</span><span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="n">read</span><span class="p">())</span>
</code></pre></div></div> <h3 id="datafuture-由-appfuture-内部管理的返回值">DataFuture: 由 AppFuture 内部管理的返回值</h3> <ul> <li>AppFutures 代表异步应用程序的执行，而 DataFutures 代表它生成的文件。 Parsl 的数据流模型（其中数据通过文件从一个应用程序流向另一个应用程序）需要这样一种构造，以使应用程序能够验证所需文件的创建，并随后在创建输入文件时解决依赖关系。调用应用程序时，Parsl 要求指定输出文件列表（使用 outputs 关键字参数）。应用程序执行时会返回每个文件的 DataFuture。在应用程序的整个执行过程中，Parsl 将监视这些文件，以 1) 确保它们已创建，2) 将它们传递给任何依赖的应用程序。</li> <li>核心思想：在 bash_app 中，return 用于表示这个 task 需要执行的 shell 脚本具体内容，然后 bash_app 的输出结果是需要用文件进行同步的。如果是 python_app 不会遇到这个问题，return 的是 AppFuture 直接获取返回值即可。所以，在多元应用中，无法全部都用 Python 任务逻辑表达的时候，是需要依赖文件进行数据的同步的！</li> </ul> <h3 id="分布式数据传输方案-remote--files">分布式数据传输方案 Remote Files</h3> <ul> <li>Parsl 文件抽象还可以表示远程可访问的文件。在这种情况下，您可以使用文件的远程位置实例化文件对象。在执行任何依赖的应用程序之前，Parsl 会隐式地将文件暂存到执行环境。 Parsl 还会将文件的位置转换为本地文件路径，以便任何依赖的应用程序都可以像本地文件一样访问该文件。 Parsl 支持可通过 Globus、FTP 和 HTTP 访问的文件。</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div> <h2 id="核心的几种并行方式">核心的几种并行方式</h2> <h3 id="bag-of-tasks-顺序发射-支持并行执行">Bag of Tasks [顺序发射, 支持并行执行]</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="n">parsl</span>
<span class="n">from</span> <span class="n">parsl</span> <span class="k">import</span> <span class="n">python_app</span>

<span class="n">parsl</span><span class="p">.</span><span class="n">load</span><span class="p">()</span>

<span class="cp"># Map function that returns double the input integer
</span><span class="err">@</span><span class="n">python_app</span>
<span class="n">_def_</span> <span class="n">app_random</span><span class="p">(</span><span class="n">_index_</span><span class="p">)</span><span class="o">:</span>
    <span class="k">import</span> <span class="n">random</span>
    <span class="cp"># return random.random()
</span>    <span class="n">print</span><span class="p">(</span><span class="n">_f_</span><span class="s">"run {_index_}"</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_index_</span>

<span class="n">results</span> <span class="o">=</span>  <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="n">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span><span class="o">:</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">app_random</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="n">results</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="k">for</span> <span class="n">r</span> <span class="n">in</span> <span class="n">results</span><span class="o">:</span>
    <span class="n">print</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">result</span><span class="p">())</span>
</code></pre></div></div> <h3 id="sequential-workflows">Sequential Workflows</h3> <ul> <li>本质上就是把上一个任务返回的 future 传递给下一个任务</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="n">parsl</span>
<span class="n">from</span> <span class="n">parsl</span> <span class="k">import</span> <span class="n">python_app</span><span class="p">,</span> <span class="n">bash_app</span>

<span class="n">parsl</span><span class="p">.</span><span class="n">load</span><span class="p">()</span>

<span class="cp"># Generate a random number
</span><span class="err">@</span><span class="n">python_app</span>
<span class="n">_def_</span> <span class="n">generate</span><span class="p">(</span><span class="n">_limit_</span><span class="p">)</span><span class="o">:</span>
    <span class="n">from</span> <span class="n">random</span> <span class="k">import</span> <span class="n">randint</span>
    <span class="s">"""Generate a random integer and return it"""</span>
    <span class="k">return</span> <span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">_limit_</span><span class="p">)</span>

<span class="cp"># Write a message to a file
</span><span class="err">@</span><span class="n">bash_app</span>
<span class="n">_def_</span> <span class="n">save</span><span class="p">(</span><span class="n">_message_</span><span class="p">,</span> <span class="n">_outputs_</span><span class="o">=</span><span class="p">())</span><span class="o">:</span>
    <span class="k">return</span> <span class="err">'</span><span class="n">echo</span> <span class="p">{}</span> <span class="o">&amp;&gt;</span> <span class="p">{}</span><span class="err">'</span><span class="p">.</span><span class="n">format</span><span class="p">(</span><span class="n">_message_</span><span class="p">,</span> <span class="n">_outputs_</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="n">message</span> <span class="o">=</span> <span class="n">generate</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>

<span class="n">saved</span> <span class="o">=</span> <span class="n">save</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">_outputs_</span><span class="o">=</span><span class="p">[</span><span class="err">'</span><span class="n">output</span><span class="p">.</span><span class="n">txt</span><span class="err">'</span><span class="p">])</span>

<span class="n">with</span> <span class="n">open</span><span class="p">(</span><span class="n">saved</span><span class="p">.</span><span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">result</span><span class="p">(),</span> <span class="sc">'r'</span><span class="p">)</span> <span class="n">as</span> <span class="n">f</span><span class="o">:</span>
    <span class="n">print</span><span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="n">read</span><span class="p">())</span>
</code></pre></div></div> <h3 id="parallel-workflows">Parallel Workflows</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="n">parsl</span>
<span class="n">from</span> <span class="n">parsl</span> <span class="k">import</span> <span class="n">python_app</span>

<span class="n">parsl</span><span class="p">.</span><span class="n">load</span><span class="p">()</span>

<span class="err">@</span><span class="n">python_app</span>
<span class="n">_def_</span> <span class="n">wait_sleep_double</span><span class="p">(</span><span class="n">_x_</span><span class="p">,</span> <span class="n">_foo_1_</span><span class="p">,</span> <span class="n">_foo_2_</span><span class="p">)</span><span class="o">:</span>
     <span class="k">import</span> <span class="n">time</span>
     <span class="n">time</span><span class="p">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>   <span class="err">#</span> <span class="n">Sleep</span> <span class="k">for</span> <span class="mi">2</span> <span class="n">seconds</span>
     <span class="k">return</span> <span class="n">_x_</span><span class="o">*</span><span class="mi">2</span>

<span class="cp"># Launch two apps, which will execute in parallel, since they do not have to
# wait on any futures
</span><span class="n">doubled_x</span> <span class="o">=</span> <span class="n">wait_sleep_double</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">None</span><span class="p">,</span> <span class="n">None</span><span class="p">)</span>
<span class="n">doubled_y</span> <span class="o">=</span> <span class="n">wait_sleep_double</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">None</span><span class="p">,</span> <span class="n">None</span><span class="p">)</span>

<span class="cp"># The third app depends on the first two:
#    doubled_x   doubled_y     (2 s)
#           \     /
#           doublex_z          (2 s)
</span><span class="n">doubled_z</span> <span class="o">=</span> <span class="n">wait_sleep_double</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">doubled_x</span><span class="p">,</span> <span class="n">doubled_y</span><span class="p">)</span>

<span class="cp"># doubled_z will be done in ~4s
</span><span class="n">print</span><span class="p">(</span><span class="n">doubled_z</span><span class="p">.</span><span class="n">result</span><span class="p">())</span>
</code></pre></div></div> <h3 id="parallel-dataflow">Parallel dataflow</h3> <ul> <li>可以通过在应用程序之间传递数据来开发并行数据流。在此示例中，我们创建一组文件，每个文件都有一个随机数，然后将这些文件连接成一个文件并计算该文件中所有数字的总和。对第一个应用程序的调用每个都会创建一个文件，第二个应用程序读取这些文件并创建一个新文件。最终的应用程序将总和作为 Python 整数返回。</li> </ul>]]></content><author><name></name></author><category term="开源项目源码"/><category term="系统-高性能计算"/><summary type="html"><![CDATA[Parsl调度框架介绍]]></summary></entry><entry><title type="html">并行编程模型的整理</title><link href="https://xlcbingo1999.github.io/blog/2024/parellel-model/" rel="alternate" type="text/html" title="并行编程模型的整理"/><published>2024-05-08T00:00:00+00:00</published><updated>2024-05-08T00:00:00+00:00</updated><id>https://xlcbingo1999.github.io/blog/2024/parellel-model</id><content type="html" xml:base="https://xlcbingo1999.github.io/blog/2024/parellel-model/"><![CDATA[<blockquote> <p>更好的排版请阅读: https://we5lw6jk7r.feishu.cn/wiki/DhhbwZoczi3wubkmSiGcV7KLntd?from=from_copylink</p> </blockquote> <h1 id="并行编程模型的整理">并行编程模型的整理</h1> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/GkoGbak9CoxNA4xgG8OcfsO4nwf-480.webp 480w, /assets/img/feishu_docs_static/GkoGbak9CoxNA4xgG8OcfsO4nwf-800.webp 800w, /assets/img/feishu_docs_static/GkoGbak9CoxNA4xgG8OcfsO4nwf-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/GkoGbak9CoxNA4xgG8OcfsO4nwf.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <h1 id="基于编程接口的并行编程模型">基于编程接口的并行编程模型</h1> <h2 id="标准编程接口">标准编程接口</h2> <ul> <li>受支持不同网络类型的 MPI 消息传递接口启发，当前有许多组织以及机构尝试为多种架构的计算设备提供统一的编程接口，从而实现程序在不同计算设备之间的性能可移植。</li> </ul> <h3 id="cuda">Cuda</h3> <ul> <li>nvidia 提供</li> <li>只能在 nvidia gpu 硬件上使用</li> </ul> <h3 id="opencl">OpenCL</h3> <ul> <li>Khronos 组织提出</li> <li>可以将各种处理器都抽象为统一的模型，包括 Intel 的 Xeon Phi、Nvidia GPU、AMD GPU、神威太湖之光 等硬件都可以使用</li> <li>缺点：编程接口很底层，程序开发效率低</li> </ul> <h3 id="skelcl">SkelCL</h3> <ul> <li>基于 OpenCL 优化，封装并简化了 OpenCL 的数据和任务管理操作</li> </ul> <h3 id="bolt">Bolt</h3> <ul> <li>基于 OpenCL 优化，封装并简化了 OpenCL 的数据和任务管理操作</li> <li>实现了常用的并行算法</li> </ul> <h3 id="boostcompute">Boost.compute</h3> <ul> <li>基于 OpenCL 优化，封装并简化了 OpenCL 的数据和任务管理操作</li> <li>实现了常用的并行算法</li> </ul> <h3 id="sycl">SYCL</h3> <ul> <li>Khronos 组织提出</li> <li>OpenCL 之上的抽象层，SYCL 标准支持高维数组，简化了 OpenCL 中的数据与任务管理操作。</li> </ul> <h3 id="dpc">DPC++</h3> <ul> <li>Intel 提出</li> <li>基于 SYCL 设计的编程标准，对 SYCL 进行了扩展，支持跨 CPU 和协加速器的数据并行编程</li> </ul> <h3 id="c-amp">C++ AMP</h3> <ul> <li>微软提出</li> <li>比 OpenCL 拥有更高层次的计算设备抽象，因此代码非常简洁，只需要在 for 循环中指定计算域以及内嵌的 lambda 函数就能完成并行计算。C++ AMP 的支持多维数组以及内存数据布局（Row/column major, AOS, SOA），依托于 Visual Studio 的支持，以及微软为 C++ AMP 专门开发的并行算法库，其为 Windows 开发者提供了良好的支持。</li> </ul> <h2 id="核心-性能可移植-适配不同编程接口的模板函数">(核心: 性能可移植) 适配不同编程接口的模板函数</h2> <ul> <li>有一些编程模型通过用统一的接口适配不同的并行编程标准，达到使程序在不同架构计算设备之间性能可移植的目标。</li> </ul> <h3 id="kokkos">Kokkos</h3> <ul> <li><strong>核心是(高维)数组的模版化抽象容器, 统一的接口适配不同的并行化后端，公开版本包括 OpenMP，Pthreads 和 CUDA</strong></li> <li>帮助程序实现在不同架构的计算设备之间性能可移植的 C++ 模板，其核心是数组的抽象容器 view 以及数据并行操作的抽象类 functor。</li> <li>view 不仅支持多维数组，还把内存对齐、下标映射、内存数据布局、以 及访问控制等封装起来。functor 类包含程序员定义的数据操作函数以及这些函数需要操 作的数组容器，其主要作用是将设备的执行空间与存储空间连接起来。</li> <li>Kokkos 目前支持的 编程标准包括 OpenMP，Pthreads、CUDA、以及 OpenCL 等。</li> </ul> <h3 id="raja">Raja</h3> <ul> <li>帮助程序实现在不同架构计算设备间性能可移植的 C++ 模板库</li> <li>其参考了劳伦斯利物莫国家实验室的一系列结构以及非结构网格程序的特点，认为这些程 序中对网格进行遍历操作的 for 循环的各循环实例之间不存在数据依赖，可以并行执 行。RAJA 将这些 for 循环抽象成为模板函数，模板函数的参数包括用户指定的循环体执行 策略以及目标编程标准等。</li> </ul> <h3 id="课题二semd">(课题二)SEMD</h3> <h3 id="op2">OP2</h3> <ul> <li>OP2 将非结构网格程序划分为 4 部分：集合（边的集合，网格的集合等）、集合相关 的数据、集合之间的映射关系（边与网格的对应关系）、以及对集合的操作。</li> <li>其认为所有 非结构网格程序都是对相关集合进行算数操作，体现在代码上就是使用 for 循环对集合的 元素进行遍历，直接或通过映射关系间接访问并操作集合的数据。</li> <li> <p>使用 OP2 可以实现程序 的<strong>节点间</strong>以及<strong>节点内</strong>并行，</p> <ul> <li>节点间并行基于 MPI 编程标准实现：在实现节点间并行 时，OP2 框架使用 ParMETISs[34]以及 PTScotch[35]对整个计算域的网格进行划分以确保节 点之间的负载平衡</li> <li>节点内并行根据后端 计算设备可以基于 Pthread、OpenMP、CUDA、OpenCL 等编程标准实现： 在实现节点内并行时，OP2 采用图着色算法实现节点内处理单元的任 务分配及负载平衡</li> </ul> </li> <li><strong>数据布局</strong>：OP2 框架还可以根据不同后端计算设备的特点，选择不同的数据布局 方式（AOS 或 SOA）。</li> <li><strong>编译</strong>：早期的 OP2 框架基于 ROSE 源码编译器实现源码编译，而最新的 OP2 框架 [36]采用 LLVM-Clang 重新实现了源码编译功能。</li> </ul> <h1 id="基于编译指导语句的编程模型">基于编译指导语句的编程模型</h1> <h2 id="基于编译指导语句的编程模型-1">基于编译指导语句的编程模型</h2> <ul> <li>对于数量庞大的遗产代码，使用插入编译指导语句的方式可以帮助开发人员使用不同 计算设备对其进行加速。</li> </ul> <h3 id="openacc">OpenACC</h3> <ul> <li>OpenACC[16]是由 Cray、PGI、以及英伟达发起的一个编程标准， 与 OpenMP 类似，其允许将编译指导语句插入 Fortran,C 和 C++ 程序的代码中，以帮助编译器 将计算任务调度到协加速器上。</li> <li>目前对 OpenACC 进行支持的设备包括 NVIDIA GPU, AMD GPU, SW26010, Intel Xeon Phi,FPGA 等。OpenACC 的出现极大的方便了程序开发人员使用 协处理器加速数量庞大的遗产代码。</li> </ul> <h3 id="openhmpp">OpenHMPP</h3> <ul> <li>HMPP[18]是由 CAPS 组织发起的一种 基于编译指导语句的编程标准，其支持 C 和 Fortran 两种语言。目前 NIVIDA 系列 GPU 对 HMPP 进行了支持。</li> <li>HMPP 编译器可以根据#pragma 编译指导语句生成在相应计算设备上执行的二 进制文件。</li> </ul> <h3 id="openmp-4x">OpenMP 4.X</h3> <ul> <li>自从 OpenMP 4.X[17]开始，OpenMP 中也引入了用于协处理器加速的指导语句， 目前 NVIDIA GPU, AMD GPU, Intel Xeon Phi、以及 IBM Power 处理器都对 OpenMP 4.X 进行 了支持。</li> </ul> <h3 id="mint">Mint</h3> <ul> <li>使用简单的 5 条编译指导语句将科学计算中广泛存在的串行 Stencil 代码转换为 CUDA 代码。</li> </ul> <h1 id="基于语言的编程模型">基于语言的编程模型</h1> <ul> <li>当前还有许多工作设计新的编程语言，这些编程语言对并行编程所需的常用操作进行 总结，从而简化并行程序的开发难度。过去的很长一段时间，程序中描述算法的逻辑被性 能优化策略掩盖。针对特定计算设备进行性能优化后的代码基本被固定，不再具有良好的 <strong>可维护性</strong>，代码在进行跨计算设备移植时需要大范围重写。因此，程序开发人员往往采用 保守的方案，把性能优化留到最后一步。为了提高代码的性能可移植性，有研究将算法描 述和代码生成解耦，使用简单的语法对算法进行描述，然后再针对具体的计算设备生成相 应的优化代码，这样在不同的计算设备间移植算法时只需要对算法的代码生成模块进行替 换。本节将分别介绍算法描述与优化策略混合以及解耦的编程语言。</li> </ul> <h2 id="算法实现与优化混合的编程语言">算法实现与优化混合的编程语言</h2> <h3 id="x10">X10</h3> <ul> <li>X10[22]是 IBM 在美国 DARPA 的 HPCS（High Productivity Computing Systems）项目中 提出的一种编程语言，其基于 JAVA 进行扩展，使用异步划分地址空间模型(APGAS Model) 管理 CPU 以及 GPU，删除了 JAVA 中的并行控制部分，引入了新的并发控制库。X10 通过简单 扩展后使用自身的语义替代 CUDA 的相关语义，简化了 GPU 编程[38]。</li> </ul> <h2 id="算法实现与优化解耦的编程语言">算法实现与优化解耦的编程语言</h2> <ul> <li>目前，在高性能计算的某些特殊领域，已经有某些专用语言可以将程序的算法描述和代码生成完全解耦。该类领域专用语言能够帮助程序开发人员对领域算法进行描述，并在 不关心底层细节的情况下，仅通过调用优化接口就完成算法优化以及代码生成。</li> </ul> <h3 id="深度学习领域-tvm">深度学习领域: TVM</h3> <ul> <li>目前深度学习领域的研究十分活跃，每天都有新的神经网络算子（层）被提出来，以 期望进一步提升模型的精确度。同时，由于越来越多的厂商开始设计制作神经网络芯片， 运行神经网络模型时会有越来越多的后端计算设备可供选择。由于既要支持层出不穷的神 经网络算子（层），又要保证新的神经网络算子（层）可以运行于不同的后端计算设备之 上，深度学习框架面临着极大的挑战，由此导致了众多深度学习编译器项目的出 现。</li> <li>TVM[23]是一套完整的深度学习优化框架，其包括神经网络模型的图优化层以及算子 优化层。图优化层会执行算子合并等操作以对计算图进行优化；算子优化层会针对特定后 端计算设备，为计算图中的算子生成优化的代码。</li> </ul>]]></content><author><name></name></author><category term="技术杂记"/><category term="系统-高性能计算"/><summary type="html"><![CDATA[并行编程模型的整理]]></summary></entry><entry><title type="html">SYCL+OneAPI+DPC++软件栈</title><link href="https://xlcbingo1999.github.io/blog/2024/SYCL/" rel="alternate" type="text/html" title="SYCL+OneAPI+DPC++软件栈"/><published>2024-05-07T00:00:00+00:00</published><updated>2024-05-07T00:00:00+00:00</updated><id>https://xlcbingo1999.github.io/blog/2024/SYCL</id><content type="html" xml:base="https://xlcbingo1999.github.io/blog/2024/SYCL/"><![CDATA[<blockquote> <p>更好的排版请阅读: https://we5lw6jk7r.feishu.cn/wiki/GjQkwE6SciH2nhk3nERcwiC4nCq?from=from_copylink</p> </blockquote> <h1 id="sycloneapidpc-软件栈">SYCL+OneAPI+DPC++ 软件栈</h1> <h2 id="教程">教程</h2> <ul> <li>可视化的实例界面：<a href="https://tech.io/playgrounds/48226/introduction-to-sycl/sycl-kernel-programming---the-single_task-api">https://tech.io/playgrounds/48226/introduction-to-sycl/sycl-kernel-programming—the-single_task-api</a></li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/GRU0bCQw6o7rzRx2KcBcVspsnah-480.webp 480w, /assets/img/feishu_docs_static/GRU0bCQw6o7rzRx2KcBcVspsnah-800.webp 800w, /assets/img/feishu_docs_static/GRU0bCQw6o7rzRx2KcBcVspsnah-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/GRU0bCQw6o7rzRx2KcBcVspsnah.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/GUoObQspRobJvYx3S7RcWa8Bnsd-480.webp 480w, /assets/img/feishu_docs_static/GUoObQspRobJvYx3S7RcWa8Bnsd-800.webp 800w, /assets/img/feishu_docs_static/GUoObQspRobJvYx3S7RcWa8Bnsd-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/GUoObQspRobJvYx3S7RcWa8Bnsd.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <ul> <li>书籍：<a href="https://link.springer.com/book/10.1007/978-1-4842-5574-2">https://link.springer.com/book/10.1007/978-1-4842-5574-2</a></li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/Kg2sbznoJowPqnxPX0fc4Vaxn2d-480.webp 480w, /assets/img/feishu_docs_static/Kg2sbznoJowPqnxPX0fc4Vaxn2d-800.webp 800w, /assets/img/feishu_docs_static/Kg2sbznoJowPqnxPX0fc4Vaxn2d-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/Kg2sbznoJowPqnxPX0fc4Vaxn2d.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <ul> <li> <p>slide：</p> <ul> <li><a href="https://0cch.com/uploads/2022/09/c++2022.pdf">https://0cch.com/uploads/2022/09/c++2022.pdf</a></li> <li><a href="https://0cch.com/uploads/2022/11/sycl_coding_practice_and_compilation_design_analysis.pdf">https://0cch.com/uploads/2022/11/sycl_coding_practice_and_compilation_design_analysis.pdf</a></li> </ul> </li> <li> <p>Getting Started with oneAPI DPC++</p> <ul> <li><a href="https://intel.github.io/llvm-docs/GetStartedGuide.html">https://intel.github.io/llvm-docs/GetStartedGuide.html</a></li> </ul> </li> </ul> <h2 id="背景">背景</h2> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/MMizbJ36poSppcxrqhNcMNW0nTf-480.webp 480w, /assets/img/feishu_docs_static/MMizbJ36poSppcxrqhNcMNW0nTf-800.webp 800w, /assets/img/feishu_docs_static/MMizbJ36poSppcxrqhNcMNW0nTf-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/MMizbJ36poSppcxrqhNcMNW0nTf.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <ul> <li>Intel i7 6700K，但是我们必须意识到其 GPU 的运算能力并不弱。从面积上来 看，GPU 芯片的“占地面积”几乎和 CPU 平分秋色。也就是说，如果我们编写的程序只用到了 CPU 部分， 那么是相当不划算的，因为大量“面积”的计算能力是没有用到的。</li> <li>挑战：相同架构、指令集和语言的程序还比较容易写出来。那么不同架构，不同指令集，不同工具栏，不同语言的程序写起来就相当费劲了，这也是我们写异构程序时面临的重大挑战。</li> </ul> <h3 id="intel-oneapi">Intel oneAPI</h3> <ul> <li>oneAPI 就像操作系统的硬件抽象层，他让程序员不需要了解底层硬件有哪些，分别是什么。作为程序员，我们只需要知道我们的业务逻辑是什么，任务是什么，然后调用框架或者 oneAPI 接口即可。至于怎么和硬件交互，怎么把计算任务给到特定的加速器就不需要程序员关心了。当然了，既然 oneAPI 已经把硬件接管了，那么关于兼容性和移植性这些问题，也都是由 oneAPI 来处理的。</li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/Yf2ObkXMdoXCwgxQ0VXchkTOnPg-480.webp 480w, /assets/img/feishu_docs_static/Yf2ObkXMdoXCwgxQ0VXchkTOnPg-800.webp 800w, /assets/img/feishu_docs_static/Yf2ObkXMdoXCwgxQ0VXchkTOnPg-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/Yf2ObkXMdoXCwgxQ0VXchkTOnPg.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/XgvmbMt0NoMtL8x7eGycZMobnWd-480.webp 480w, /assets/img/feishu_docs_static/XgvmbMt0NoMtL8x7eGycZMobnWd-800.webp 800w, /assets/img/feishu_docs_static/XgvmbMt0NoMtL8x7eGycZMobnWd-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/XgvmbMt0NoMtL8x7eGycZMobnWd.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <h2 id="sycl更多的是一个规范">SYCL（更多的是一个规范）</h2> <h3 id="介绍">介绍</h3> <ul> <li> <p><strong>SYCL 是一种用于编程异构系统的开放式行业标准。SYCL 的设计允许编写标准的 C++ 源代码，使其可以在异构设备或主机上运行。【一次编写，到处运行】</strong></p> <ul> <li>SYCL 基于并行 API 或 OpenCL 等标准的基本概念、可移植性和效率，同时增加了单源 C++ 的易用性和灵活性。</li> <li>使用 SYCL 的开发人员能够使用他们习惯的许多技术（如继承和模板）编写标准的现代 C++ 代码。同时，开发人员可以通过 SYCL 库的功能访问底层实现（如 OpenCL）的全部功能，必要时还可以通过 API 与直接使用底层实现编写的代码进行互操作。</li> </ul> </li> <li> <p><strong>SYCL 以几种方式扩展了 OpenCL 模型等标准中的概念，超越了 C++ 特性的一般用途 【使用方式和 C++ 对齐】</strong></p> <ul> <li><strong>支持使用 C++ 编写内核函数</strong>： 在异构设备上执行并行内核既方便又灵活。常见的并行模式使用简单语法进行优先排序，通过一系列 C++ 类型，程序员可以在需要时表达额外的需求，如同步</li> <li><strong>RAII 风格</strong>： 当使用缓冲区和访问器时，SYCL 中的数据访问与数据存储分离。通过依赖 C++ 风格的资源获取即初始化（RAII）习惯用法来捕获设备代码块之间的数据依赖关系，运行时库可以跟踪数据移动并提供正确的行为，而无需手动管理内核实例之间的事件依赖关系，也无需程序员显式移动数据。这种方法使数据并行任务图（可能已经是执行模型的一部分）能够由 SYCL 程序员轻松安全地构建；</li> <li><strong>内存访问方案 1：统一共享内存（USM）</strong>：统一共享内存（USM）为显式数据分配和移动提供了一种机制。这种方法允许在异构设备上使用基于指针的算法和数据结构，并允许跨主机和设备增加代码的重用；</li> </ul> </li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/VF7VbPvD0o8BEpxbzGicoGkZnvf-480.webp 480w, /assets/img/feishu_docs_static/VF7VbPvD0o8BEpxbzGicoGkZnvf-800.webp 800w, /assets/img/feishu_docs_static/VF7VbPvD0o8BEpxbzGicoGkZnvf-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/VF7VbPvD0o8BEpxbzGicoGkZnvf.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <ul> <li><strong>内存方案方案 2：缓冲器和访问器</strong>。将数据对象，这里是 vector，作为参数传给 buffer 的构造函数，用于构造 buffer 对象，然后在命令组范围内使用 buffer 构造 accessor，最后才能在 内核函数中使用 accessor 去访问 vector 的数据。值得注意的是，buffer 必须使用一个<strong>作用域</strong>包括起来， 因为 buffer 只有在析构的时候才会将加速设备的数据转移到主机内存中。</li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/YoDzb4xD0owKGixhnOMcGwTNnxg-480.webp 480w, /assets/img/feishu_docs_static/YoDzb4xD0owKGixhnOMcGwTNnxg-800.webp 800w, /assets/img/feishu_docs_static/YoDzb4xD0owKGixhnOMcGwTNnxg-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/YoDzb4xD0owKGixhnOMcGwTNnxg.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <ul> <li><strong>并行语法</strong>：分层并行语法提供了一种以易于理解的现代 C++ 形式表达数据并行性的方法，类似于 OpenCL 设备或 OpenMP 目标设备执行模型。它更清晰地分层并行循环和同步点，以避免代码碎片，并更有效地映射到 CPU 风格的架构。</li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/SuWsbqZv5oquTWxX4ivcKGWanzg-480.webp 480w, /assets/img/feishu_docs_static/SuWsbqZv5oquTWxX4ivcKGWanzg-800.webp 800w, /assets/img/feishu_docs_static/SuWsbqZv5oquTWxX4ivcKGWanzg-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/SuWsbqZv5oquTWxX4ivcKGWanzg.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <h3 id="实例">实例</h3> <ul> <li> <p>一个执行向量加法的内核，在主程序种使用 SYCL 队列和缓冲区将数据传输到 GPU 设备上运行</p> <ul> <li>我们首先为要操作的数据设置主机存储。我们的目标是计算 c = a + b，其中变量是向量。</li> </ul> </li> <li>Host Code</li> <li>Device Code</li> <li>Queue：队列 queue 用于提交命令组(command group)到 SYCL 运行时执行，它是一种将工作(work)提交到设备的机制。一个队列可以映射(map)到一个设备，多个队列(multiple queue)可以映射到同一设备。queue 的成员函数 parallel_for 可以将命令提交到队列，不过这只是一种简化写法，更加完整的写法是调用 submit 函数，submit 函数将提交一个命令组 lambda 表达式，在表达式中命令组对象的成员函数再调用 parallel_for 函数，将内核函数提交给队列。</li> <li>Selector：队列可以将命令提交给设备，但是具体提交给什么设备应该是可以指定的。所以 SYCL 提供了几种方法指定设备，一种是直接指定设备类别，比如 default_selector、cpu_selector、gpu_selector 等，这种选择器都是 SYCL 标准中预设好的。不过这种选择设备的方式也有局限性，因为如果同一类型存在多种不同的设备，上述方式就没有选择。</li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/JAVHbG7DYoEyYjxUvyKc1Rcdnwd-480.webp 480w, /assets/img/feishu_docs_static/JAVHbG7DYoEyYjxUvyKc1Rcdnwd-800.webp 800w, /assets/img/feishu_docs_static/JAVHbG7DYoEyYjxUvyKc1Rcdnwd-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/JAVHbG7DYoEyYjxUvyKc1Rcdnwd.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <ul> <li>自定义：这个函数中，可以通过参数 device 来获取设备信息，比如类型和名称，然后通过这些信息选择目标设备。比如这里的代码示例，就是选择一个 Intel 的 GPU 设备并返回 100，数值越大优先级越高</li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/KO52bk1pwoYtNoxhCl5cUXtqnXg-480.webp 480w, /assets/img/feishu_docs_static/KO52bk1pwoYtNoxhCl5cUXtqnXg-800.webp 800w, /assets/img/feishu_docs_static/KO52bk1pwoYtNoxhCl5cUXtqnXg-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/KO52bk1pwoYtNoxhCl5cUXtqnXg.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span><span class="n">include</span> <span class="o">&lt;</span><span class="n">iostream</span><span class="o">&gt;</span>
<span class="o">#</span><span class="n">include</span> <span class="o">&lt;</span><span class="n">CL</span><span class="o">/</span><span class="n">sycl</span><span class="p">.</span><span class="n">hpp</span><span class="o">&gt;</span>

<span class="k">class</span> <span class="n">vector_addition</span><span class="p">;</span>

<span class="nb">int</span> <span class="n">main</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">char</span><span class="o">**</span><span class="p">)</span> <span class="p">{</span>
   <span class="o">//</span> <span class="k">Host</span> <span class="k">Storage</span>
   <span class="o">//</span> <span class="err">我们首先为要操作的数据设置主机存储。我们的目标是计算</span> <span class="k">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="err">，其中变量是向量。</span>
   <span class="n">cl</span><span class="p">::</span><span class="n">sycl</span><span class="p">::</span><span class="n">float4</span> <span class="n">a</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">.</span><span class="mi">0</span> <span class="p">};</span>
   <span class="n">cl</span><span class="p">::</span><span class="n">sycl</span><span class="p">::</span><span class="n">float4</span> <span class="n">b</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">4</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span> <span class="p">};</span>
   <span class="n">cl</span><span class="p">::</span><span class="n">sycl</span><span class="p">::</span><span class="n">float4</span> <span class="k">c</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span> <span class="p">};</span>

   <span class="o">//</span> <span class="err">在</span> <span class="n">SYCL</span> <span class="err">中，有不同的方法来配置和选择我们想要使用的设备。</span> 
   <span class="o">//</span> <span class="n">SYCL</span> <span class="err">提供了一个默认选择器，尝试选择系统中最合适的设备。</span>
   <span class="o">//</span> <span class="err">可以使用自定义选择器，但由于我们只有一台设备，所以我们使用默认选择器。</span>
   <span class="n">cl</span><span class="p">::</span><span class="n">sycl</span><span class="p">::</span><span class="n">default_selector</span> <span class="n">device_selector</span><span class="p">;</span>

   <span class="o">//</span> <span class="err">为了发送要在目标设备上计划和执行的任务，我们需要使用</span> <span class="n">SYCL</span> <span class="err">队列。</span>
   <span class="o">//</span> <span class="err">我们对其进行设置并向其传递我们的选择器，以便它知道在运行任务时选择什么设备。</span>
   <span class="n">cl</span><span class="p">::</span><span class="n">sycl</span><span class="p">::</span><span class="n">queue</span> <span class="n">queue</span><span class="p">(</span><span class="n">device_selector</span><span class="p">);</span>
   <span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="nv">"Running on "</span>
             <span class="o">&lt;&lt;</span> <span class="n">queue</span><span class="p">.</span><span class="n">get_device</span><span class="p">().</span><span class="n">get_info</span><span class="o">&lt;</span><span class="n">cl</span><span class="p">::</span><span class="n">sycl</span><span class="p">::</span><span class="n">info</span><span class="p">::</span><span class="n">device</span><span class="p">::</span><span class="n">name</span><span class="o">&gt;</span><span class="p">()</span>
             <span class="o">&lt;&lt;</span> <span class="nv">"</span><span class="se">\n</span><span class="nv">"</span><span class="p">;</span>
   <span class="p">{</span>
      <span class="o">//</span> <span class="err">发送到设备内存上</span>
      <span class="n">cl</span><span class="p">::</span><span class="n">sycl</span><span class="p">::</span><span class="n">buffer</span><span class="o">&lt;</span><span class="n">cl</span><span class="p">::</span><span class="n">sycl</span><span class="p">::</span><span class="n">float4</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">a_sycl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="n">cl</span><span class="p">::</span><span class="n">sycl</span><span class="p">::</span><span class="k">range</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
      <span class="n">cl</span><span class="p">::</span><span class="n">sycl</span><span class="p">::</span><span class="n">buffer</span><span class="o">&lt;</span><span class="n">cl</span><span class="p">::</span><span class="n">sycl</span><span class="p">::</span><span class="n">float4</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">b_sycl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">,</span> <span class="n">cl</span><span class="p">::</span><span class="n">sycl</span><span class="p">::</span><span class="k">range</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
      <span class="n">cl</span><span class="p">::</span><span class="n">sycl</span><span class="p">::</span><span class="n">buffer</span><span class="o">&lt;</span><span class="n">cl</span><span class="p">::</span><span class="n">sycl</span><span class="p">::</span><span class="n">float4</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">c_sycl</span><span class="p">(</span><span class="o">&amp;</span><span class="k">c</span><span class="p">,</span> <span class="n">cl</span><span class="p">::</span><span class="n">sycl</span><span class="p">::</span><span class="k">range</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
  
      <span class="o">//</span> <span class="err">提交一个</span><span class="n">lambda</span><span class="err">函数，异步执行</span>
      <span class="n">queue</span><span class="p">.</span><span class="n">submit</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">cl</span><span class="p">::</span><span class="n">sycl</span><span class="p">::</span><span class="k">handler</span><span class="o">&amp;</span> <span class="n">cgh</span><span class="p">)</span> <span class="p">{</span>
         <span class="o">//</span> <span class="err">为数据设置权限</span> <span class="k">read</span><span class="p">,</span> <span class="n">discard_write</span>
         <span class="n">auto</span> <span class="n">a_acc</span> <span class="o">=</span> <span class="n">a_sycl</span><span class="p">.</span><span class="n">get_access</span><span class="o">&lt;</span><span class="n">cl</span><span class="p">::</span><span class="n">sycl</span><span class="p">::</span><span class="k">access</span><span class="p">::</span><span class="k">mode</span><span class="p">::</span><span class="k">read</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cgh</span><span class="p">);</span>
         <span class="n">auto</span> <span class="n">b_acc</span> <span class="o">=</span> <span class="n">b_sycl</span><span class="p">.</span><span class="n">get_access</span><span class="o">&lt;</span><span class="n">cl</span><span class="p">::</span><span class="n">sycl</span><span class="p">::</span><span class="k">access</span><span class="p">::</span><span class="k">mode</span><span class="p">::</span><span class="k">read</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cgh</span><span class="p">);</span>
         <span class="n">auto</span> <span class="n">c_acc</span> <span class="o">=</span> <span class="n">c_sycl</span><span class="p">.</span><span class="n">get_access</span><span class="o">&lt;</span><span class="n">cl</span><span class="p">::</span><span class="n">sycl</span><span class="p">::</span><span class="k">access</span><span class="p">::</span><span class="k">mode</span><span class="p">::</span><span class="n">discard_write</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cgh</span><span class="p">);</span>

         <span class="o">//</span> <span class="err">定义了需要在设备上执行的内核函数</span>
         <span class="n">cgh</span><span class="p">.</span><span class="n">single_task</span><span class="o">&lt;</span><span class="k">class</span> <span class="n">vector_addition</span><span class="o">&gt;</span><span class="p">([</span><span class="o">=</span><span class="p">]</span> <span class="p">()</span> <span class="p">{</span>
         <span class="n">c_acc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">a_acc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">b_acc</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
         <span class="p">});</span>
      <span class="p">});</span>
   <span class="p">}</span>
   <span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="nv">"  A { "</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">x</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="nv">", "</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">y</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="nv">", "</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">z</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="nv">", "</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">w</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="nv">" }</span><span class="se">\n</span><span class="nv">"</span>
        <span class="o">&lt;&lt;</span> <span class="nv">"+ B { "</span> <span class="o">&lt;&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">x</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="nv">", "</span> <span class="o">&lt;&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">y</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="nv">", "</span> <span class="o">&lt;&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">z</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="nv">", "</span> <span class="o">&lt;&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">w</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="nv">" }</span><span class="se">\n</span><span class="nv">"</span>
        <span class="o">&lt;&lt;</span> <span class="nv">"------------------</span><span class="se">\n</span><span class="nv">"</span>
        <span class="o">&lt;&lt;</span> <span class="nv">"= C { "</span> <span class="o">&lt;&lt;</span> <span class="k">c</span><span class="p">.</span><span class="n">x</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="nv">", "</span> <span class="o">&lt;&lt;</span> <span class="k">c</span><span class="p">.</span><span class="n">y</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="nv">", "</span> <span class="o">&lt;&lt;</span> <span class="k">c</span><span class="p">.</span><span class="n">z</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="nv">", "</span> <span class="o">&lt;&lt;</span> <span class="k">c</span><span class="p">.</span><span class="n">w</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="nv">" }"</span>
        <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="p">::</span><span class="n">endl</span><span class="p">;</span>
   
   <span class="o">//</span> <span class="n">SYCL</span> <span class="err">的特点之一是它使用</span> <span class="k">C</span><span class="o">++</span> <span class="n">RAII</span><span class="err">（资源获取即初始化）。</span>
   <span class="o">//</span> <span class="err">这意味着没有显式清理，一切都是通过</span> <span class="n">SYCL</span> <span class="err">对象析构函数完成的。</span>

   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="dpcintel-的一个开源项目-扩展了-sycl">DPC++（Intel 的一个开源?项目, 扩展了 SYCL）</h2> <h3 id="代码放置到设备上执行">代码放置到设备上执行</h3> <h4 id="单源代码-在-host-和-device-上执行的代码可以放在同一个源文件中">单源代码: 在 host 和 device 上执行的代码可以放在同一个源文件中</h4> <ul> <li>主机代码：管理数据和管理依赖关系</li> <li> <p>设备代码</p> <ul> <li>异步执行：本质上就是不阻塞主机代码的执行方式</li> <li>内存限制：不支持动态内存分配</li> <li>API 限制：部分函数和查询功能只能在设备代码中使用</li> </ul> </li> <li>动作 Action：把设备代码提交给设备队列的过程叫做 Action，这种动作不只是<strong>代码的执行提交</strong>，还包括<strong>内存数据的移动</strong>。 【这个也太像 Legion 的核心目标了！】</li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/HKBXbtWgvoqpKcxhD3XcIuKPnUh-480.webp 480w, /assets/img/feishu_docs_static/HKBXbtWgvoqpKcxhD3XcIuKPnUh-800.webp 800w, /assets/img/feishu_docs_static/HKBXbtWgvoqpKcxhD3XcIuKPnUh-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/HKBXbtWgvoqpKcxhD3XcIuKPnUh.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/Ms0ZbC6DZo3WDNx2EIUc6qihntg-480.webp 480w, /assets/img/feishu_docs_static/Ms0ZbC6DZo3WDNx2EIUc6qihntg-800.webp 800w, /assets/img/feishu_docs_static/Ms0ZbC6DZo3WDNx2EIUc6qihntg-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/Ms0ZbC6DZo3WDNx2EIUc6qihntg.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <h4 id="c-lambda-functions-in-sycl">C++ Lambda Functions in SYCL</h4> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span> <span class="n">capture</span><span class="o">-</span><span class="n">list</span> <span class="p">]</span> <span class="p">(</span> <span class="n">params</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ret</span> <span class="p">{</span> <span class="n">body</span> <span class="p">}</span>
</code></pre></div></div> <ul> <li><strong>capture-list</strong>： SYCL uses <code class="language-plaintext highlighter-rouge">[=]</code> as kernel does not support capturing variable by reference</li> <li><strong>params</strong>： In SYCL, it can be unique 1D id, or 2D/3D id</li> <li><strong>ret</strong>：SYCL kernels must always have a <code class="language-plaintext highlighter-rouge">void</code> return type thus it is not specified in SYCL kernel</li> <li><strong>body</strong>： SYCL kernel body does not have any <code class="language-plaintext highlighter-rouge">return</code> statement</li> </ul> <h3 id="在任何设备上都可以运行">在任何设备上都可以运行</h3> <ul> <li>当我们不关心我们的设备代码将在哪里运行时，我们可以直接让运行时系统进行选择。</li> <li>如果没有指定队列应该绑定的设备，就会在运行时选择可用的设备，<strong>SYCL 保证至少有一个设备总是可用的，即主机设备本身</strong>。</li> </ul> <h3 id="设备选择接口-selector">设备选择接口 selector</h3> <ul> <li> <p>内置的设备选择接口</p> <ul> <li>default_selector</li> <li>host_selector</li> <li>cpu_selector</li> <li>gpu_selector</li> <li>accelerator_selector</li> <li>DPC++ 提供： ext::intel::fpga_selector</li> </ul> </li> <li> <p>自定义选择器接口</p> <ul> <li>my_selector</li> </ul> </li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;CL/sycl.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sycl/ext/intel/fpga_extensions.hpp&gt;</span><span class="c1"> // For fpga_selector</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">sycl</span><span class="p">;</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">queue</span> <span class="n">my_gpu_queue</span><span class="p">(</span> <span class="n">gpu_selector</span><span class="p">{}</span> <span class="p">);</span>
    <span class="n">queue</span> <span class="nf">my_fpga_queue</span><span class="p">(</span> <span class="n">ext</span><span class="o">::</span><span class="n">intel</span><span class="o">::</span><span class="n">fpga_selector</span><span class="p">{}</span> <span class="p">);</span>
    
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Selected device 1: "</span> <span class="o">&lt;&lt;</span><span class="n">my_gpu_queue</span><span class="p">.</span><span class="n">get_device</span><span class="p">().</span><span class="n">get_info</span><span class="o">&lt;</span><span class="n">info</span><span class="o">::</span><span class="n">device</span><span class="o">::</span><span class="n">name</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Selected device 2: "</span> <span class="o">&lt;&lt;</span><span class="n">my_fpga_queue</span><span class="p">.</span><span class="n">get_device</span><span class="p">().</span><span class="n">get_info</span><span class="o">&lt;</span><span class="n">info</span><span class="o">::</span><span class="n">device</span><span class="o">::</span><span class="n">name</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">my_selector</span> <span class="o">:</span> <span class="k">public</span> <span class="n">device_selector</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">device</span> <span class="o">&amp;</span><span class="n">dev</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">dev</span><span class="p">.</span><span class="n">get_info</span><span class="o">&lt;</span><span class="n">info</span><span class="o">::</span><span class="n">device</span><span class="o">::</span><span class="n">name</span><span class="o">&gt;</span><span class="p">().</span><span class="n">find</span><span class="p">(</span><span class="s">"Arria"</span><span class="p">)</span><span class="o">!=</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">npos</span> <span class="o">&amp;&amp;</span>
            <span class="n">dev</span><span class="p">.</span><span class="n">get_info</span><span class="o">&lt;</span><span class="n">info</span><span class="o">::</span><span class="n">device</span><span class="o">::</span><span class="n">vendor</span><span class="o">&gt;</span><span class="p">().</span><span class="n">find</span><span class="p">(</span><span class="s">"Intel"</span><span class="p">)</span><span class="o">!=</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">npos</span>
        <span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <h2 id="任务流图调度">任务流图调度</h2> <h3 id="核心要素-actiondependence">核心要素: Action+Dependence</h3> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/WQwwb48VNoYlxmxGBXlcsYISn2d-480.webp 480w, /assets/img/feishu_docs_static/WQwwb48VNoYlxmxGBXlcsYISn2d-800.webp 800w, /assets/img/feishu_docs_static/WQwwb48VNoYlxmxGBXlcsYISn2d-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/WQwwb48VNoYlxmxGBXlcsYISn2d.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <h3 id="命令组-command-group--actiondependence">命令组 Command Group = Action+Dependence+…</h3> <ul> <li> <p>Command Group 包含的内容</p> <ul> <li>Action</li> <li>Dependence：当某个 kernel 的依赖关系被满足，kernel 就会被执行</li> <li>其他主机代码</li> </ul> </li> <li> <p>Command Group 会在 Host 上被执行，在提交到队列的时候执行，且只会执行一次。</p> </li> </ul> <h4 id="action">Action</h4> <ul> <li>Device Code Execution（就是 Kernel）：通过 parallel_for 或 single_task 将工作提交到 device 的工作队列中</li> <li>Explicit Memory Operation（显式内存操作）：USM 的 memcpy, memset, fill 操作、 缓冲区的 copy, fill, update_host 操作</li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/NUukbq5l3oLSxVxdgTgcelznnTG-480.webp 480w, /assets/img/feishu_docs_static/NUukbq5l3oLSxVxdgTgcelznnTG-800.webp 800w, /assets/img/feishu_docs_static/NUukbq5l3oLSxVxdgTgcelznnTG-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/NUukbq5l3oLSxVxdgTgcelznnTG.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <h4 id="dependence-顺序队列和-waitdepends_on-和-accessor-隐式指定">Dependence: 顺序队列和 wait+depends_on 和 accessor 隐式指定</h4> <ul> <li>顺序队列：左图</li> <li>wait+depends_on，但是用 wait()和 depends_on()表示执行依赖：右图</li> <li> <p>accessor 隐式指定数据依赖</p> <ul> <li>Read After Write：B 任务需要依赖于 A 任务计算得到的结果，此时会出现隐式的数据依赖</li> <li>Write After Read：当 A 任务读取了某个数据，可能执行还没结束的时候，B 任务需要写这个数据，此时会有隐式的数据依赖</li> <li>Write After Write：当 A 任务在写某个数据的时候，B 任务也需要写某个数据</li> </ul> </li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/TwRDbpT1VooHLNxcVDWczLNPnRd-480.webp 480w, /assets/img/feishu_docs_static/TwRDbpT1VooHLNxcVDWczLNPnRd-800.webp 800w, /assets/img/feishu_docs_static/TwRDbpT1VooHLNxcVDWczLNPnRd-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/TwRDbpT1VooHLNxcVDWczLNPnRd.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/KtKkbZtQso2mWCxxagacG6jSnfd-480.webp 480w, /assets/img/feishu_docs_static/KtKkbZtQso2mWCxxagacG6jSnfd-800.webp 800w, /assets/img/feishu_docs_static/KtKkbZtQso2mWCxxagacG6jSnfd-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/KtKkbZtQso2mWCxxagacG6jSnfd.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <h3 id="和-host-同步方案">和 host 同步方案</h3> <ul> <li>方案 1：阻塞等待队列的完成 Q.wait() 和 Q.wait_and_throw()</li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/OMjybf1bEoPt2uxiUZ7cuxJ9nvb-480.webp 480w, /assets/img/feishu_docs_static/OMjybf1bEoPt2uxiUZ7cuxJ9nvb-800.webp 800w, /assets/img/feishu_docs_static/OMjybf1bEoPt2uxiUZ7cuxJ9nvb-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/OMjybf1bEoPt2uxiUZ7cuxJ9nvb.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <ul> <li>方案 2：对事件进行同步，允许程序在特定的命令组上同步</li> <li>方案 3：使用 host_accessor，确保被复制回 host 的数据是 device 计算完成后的数值</li> <li>方案 4（少见）：使用缓冲区的属性 use_mutex 进行信号量同步</li> </ul> <h2 id="数据管理">数据管理</h2> <ul> <li> <p>三种管理方式</p> <ul> <li>统一共享内存 Unified Shared Memory, USM：基于指针管理，支持 USM 的设备会有统一的虚拟地址空间，任何 host 上的 USM 动态内存分配函数返回的指针可以被 device 访问</li> </ul> </li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/BYhPbnXHEoX7KdxwxyWcYnLknXb-480.webp 480w, /assets/img/feishu_docs_static/BYhPbnXHEoX7KdxwxyWcYnLknXb-800.webp 800w, /assets/img/feishu_docs_static/BYhPbnXHEoX7KdxwxyWcYnLknXb-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/BYhPbnXHEoX7KdxwxyWcYnLknXb.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <ul> <li>缓冲区【Legion 的数据访问方式，但是没有 Legion 那么优秀】：代表一个或者多个 C++ 类型的对象，可以是标量数据（int、float、double），向量数据，用户定义的 struct。 缓冲区变量不是具体的内存地址，需要用 accessor 对象进行访问</li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/WF8qbZL6romP3gxCQtocGwmVnSc-480.webp 480w, /assets/img/feishu_docs_static/WF8qbZL6romP3gxCQtocGwmVnSc-800.webp 800w, /assets/img/feishu_docs_static/WF8qbZL6romP3gxCQtocGwmVnSc-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/WF8qbZL6romP3gxCQtocGwmVnSc.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <ul> <li>Images：专门用于图像处理的缓冲区管理</li> <li> <p>存储器的管理方式</p> <ul> <li>显式管理</li> <li>运行时隐式管理：由运行时系统自动完成，可以保证正确性。 缺点：性能差</li> </ul> </li> </ul> <h3 id="统一共享内存-unified-shared-memory-usm">统一共享内存 Unified Shared Memory, USM</h3> <ul> <li> <p>三种方式</p> <ul> <li>设备分配：直接在 device 上分配空间，host 无法访问，如果 host 需要这些数据需要使用 USM 的 memcpy 复制过来</li> <li>主机分配：在主机的内存中分配空间，host 和 device 都可以直接访问，但是不能直接迁移到 device 的存储器中，device 的访问是远程内进行的，通常需要经过 PCI-E 总线</li> <li>共享分配：可以被 host 和 device 访问，自行进行数据迁移，但是自动数据迁移会有延迟</li> </ul> </li> <li> <p>C 风格内存分配：分配完后得到 void*类型的数据，然后再进行强制类型转换</p> <ul> <li>malloc_device =&gt; aligned_alloc_device(用于返回对齐的内存指针)</li> <li>malloc_host =&gt; aligned_alloc_host</li> <li>malloc_shared =&gt; aligned_alloc_shared</li> </ul> </li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/BCFLbU6H3o6OLBxeYNOcXN0ynof-480.webp 480w, /assets/img/feishu_docs_static/BCFLbU6H3o6OLBxeYNOcXN0ynof-800.webp 800w, /assets/img/feishu_docs_static/BCFLbU6H3o6OLBxeYNOcXN0ynof-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/BCFLbU6H3o6OLBxeYNOcXN0ynof.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <ul> <li> <p>C++ 风格内存分配：可以使用模板函数，返回的是对应类型的指针</p> <ul> <li>支持 C++ allocator 进行内存释放</li> </ul> </li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/L6cXbWRT7o8rwdx4xxRcKcSYnHc-480.webp 480w, /assets/img/feishu_docs_static/L6cXbWRT7o8rwdx4xxRcKcSYnHc-800.webp 800w, /assets/img/feishu_docs_static/L6cXbWRT7o8rwdx4xxRcKcSYnHc-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/L6cXbWRT7o8rwdx4xxRcKcSYnHc.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <ul> <li> <p>数据初始化</p> <ul> <li>Memset</li> <li>Fill</li> </ul> </li> <li> <p>数据移动</p> <ul> <li>显式数据移动：memcpy</li> <li>隐式数据移动：</li> </ul> </li> </ul> <h3 id="缓冲区">缓冲区</h3> <ul> <li>核心思想：本身只能代表数据，如何管理数据（存储和移动）都是运行时的工作</li> <li> <p>创建缓冲区</p> <ul> <li>直接创建</li> </ul> </li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/XlmybzwVQoOKp9x6Cdxc32r6n9c-480.webp 480w, /assets/img/feishu_docs_static/XlmybzwVQoOKp9x6Cdxc32r6n9c-800.webp 800w, /assets/img/feishu_docs_static/XlmybzwVQoOKp9x6Cdxc32r6n9c-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/XlmybzwVQoOKp9x6Cdxc32r6n9c.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <ul> <li>从标量数组创建</li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/RJxqbHmG5owlwFxmogocIrhbnTv-480.webp 480w, /assets/img/feishu_docs_static/RJxqbHmG5owlwFxmogocIrhbnTv-800.webp 800w, /assets/img/feishu_docs_static/RJxqbHmG5owlwFxmogocIrhbnTv-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/RJxqbHmG5owlwFxmogocIrhbnTv.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <ul> <li>从 vector 创建</li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/QlIob1D5mo5R9MxXM9mcXqcinBh-480.webp 480w, /assets/img/feishu_docs_static/QlIob1D5mo5R9MxXM9mcXqcinBh-800.webp 800w, /assets/img/feishu_docs_static/QlIob1D5mo5R9MxXM9mcXqcinBh-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/QlIob1D5mo5R9MxXM9mcXqcinBh.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <ul> <li>使用缓冲区数据 Accessor：无法直接使用缓冲区的数据，必须定义对应数据的 accessor 才可以继续使用 <ul> <li>为 Accessor 设置访问标记：read_write, read_only, write_only, read_constant</li> </ul> </li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/UKUkbGJ1HoWtHUx1EbRcYHmHn3f-480.webp 480w, /assets/img/feishu_docs_static/UKUkbGJ1HoWtHUx1EbRcYHmHn3f-800.webp 800w, /assets/img/feishu_docs_static/UKUkbGJ1HoWtHUx1EbRcYHmHn3f-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/UKUkbGJ1HoWtHUx1EbRcYHmHn3f.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/Jw8bbR7xOoBFC0xb5hcc0Pp2nKf-480.webp 480w, /assets/img/feishu_docs_static/Jw8bbR7xOoBFC0xb5hcc0Pp2nKf-800.webp 800w, /assets/img/feishu_docs_static/Jw8bbR7xOoBFC0xb5hcc0Pp2nKf-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/Jw8bbR7xOoBFC0xb5hcc0Pp2nKf.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <h2 id="kernel-的三种表达方式">Kernel 的三种表达方式</h2> <h3 id="基本数据并行-spmd单程序多数据流">基本数据并行 SPMD(单程序多数据流)</h3> <ul> <li>基本的数据并行 kernel 的功能是通过三个 C++ 类表示的：<code class="language-plaintext highlighter-rouge">range</code>、<code class="language-plaintext highlighter-rouge">id</code> 和 <code class="language-plaintext highlighter-rouge">item</code> <ul> <li>range 表示一个一维、二维或三维的范围，维度需要在编译期确定，但每个维度的大小可以是动态的</li> <li>id 表示一个一维、二维或三维范围内的索引。尽管我们可以构造一个 id 来代表一个任意的索引，但为了获得与特定 kernel 实例相关的索引，我们必须将其作为 kernel 函数的一个参数。</li> <li>item 代表了一个 kernel 函数的单个实例，同时封装了其执行范围和实例在该范围内的索引。和 id 的主要区别在于 item 给出了额外的函数来查询范围与线性化的索引。</li> </ul> </li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/BKLjb8Aw7o0aT4xjabSc1H3znzl-480.webp 480w, /assets/img/feishu_docs_static/BKLjb8Aw7o0aT4xjabSc1H3znzl-800.webp 800w, /assets/img/feishu_docs_static/BKLjb8Aw7o0aT4xjabSc1H3znzl-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/BKLjb8Aw7o0aT4xjabSc1H3znzl.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/K2UZbUHYFox9ZuxniL5cfyhPnc7-480.webp 480w, /assets/img/feishu_docs_static/K2UZbUHYFox9ZuxniL5cfyhPnc7-800.webp 800w, /assets/img/feishu_docs_static/K2UZbUHYFox9ZuxniL5cfyhPnc7-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/K2UZbUHYFox9ZuxniL5cfyhPnc7.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/VowSb2lyQoz7Dpxl9TEca3DYnph-480.webp 480w, /assets/img/feishu_docs_static/VowSb2lyQoz7Dpxl9TEca3DYnph-800.webp 800w, /assets/img/feishu_docs_static/VowSb2lyQoz7Dpxl9TEca3DYnph-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/VowSb2lyQoz7Dpxl9TEca3DYnph.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/DoocbW5m4oM4qdxGgVgc5uk9n0b-480.webp 480w, /assets/img/feishu_docs_static/DoocbW5m4oM4qdxGgVgc5uk9n0b-800.webp 800w, /assets/img/feishu_docs_static/DoocbW5m4oM4qdxGgVgc5uk9n0b-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/DoocbW5m4oM4qdxGgVgc5uk9n0b.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <h3 id="nd-range-数据并行">ND-range 数据并行</h3> <ul> <li>三种划分方式 <ul> <li>Work-group：表示一个 kernel 函数的实例，可以按任何顺序执行，除了对全局内存的原子内存操作外，不能相互通信或同步。每个 work-group 中的 work-item 可以访问 work-group 的本地内存，可以映射到一些设备上的本地存储器，可以用 work-group barriers 进行同步。<strong>[同一 work-group 内的 work-item 可以保证同时执行，不同 work-group 内的 work-item 不能保证同时执行]</strong></li> <li>Sub-group：用于进一步的局部调度，可以使用编译器向量化的功能使得 sub-group 内的 work-item 并行执行，sub-group 没有自己的本地内存，可以用 shuffle 操作直接交换数据</li> <li>work-items：</li> </ul> </li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/KxRxbXb57oxxQ2xRzV2clkvAnKb-480.webp 480w, /assets/img/feishu_docs_static/KxRxbXb57oxxQ2xRzV2clkvAnKb-800.webp 800w, /assets/img/feishu_docs_static/KxRxbXb57oxxQ2xRzV2clkvAnKb-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/KxRxbXb57oxxQ2xRzV2clkvAnKb.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/Al53bEE32ogJURxIbbJcnl5wnRf-480.webp 480w, /assets/img/feishu_docs_static/Al53bEE32ogJURxIbbJcnl5wnRf-800.webp 800w, /assets/img/feishu_docs_static/Al53bEE32ogJURxIbbJcnl5wnRf-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/Al53bEE32ogJURxIbbJcnl5wnRf.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <h3 id="分层数据并行不太详细">分层数据并行(不太详细)</h3> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/BdxvbRdQwoxnPhxjs2qcey87nhd-480.webp 480w, /assets/img/feishu_docs_static/BdxvbRdQwoxnPhxjs2qcey87nhd-800.webp 800w, /assets/img/feishu_docs_static/BdxvbRdQwoxnPhxjs2qcey87nhd-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/BdxvbRdQwoxnPhxjs2qcey87nhd.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <h2 id="通信与同步-针对-nd-range-数据并行">通信与同步: 针对 ND-range 数据并行</h2> <h3 id="基于-barrier-确保-work-group-内的-work-item-的同步">基于 Barrier 确保 work-group 内的 work-item 的同步</h3> <ul> <li>同一个 work-group 内的四个 work-items 通过 barrier 进行同步，尽管每个 work-item 的执行时间可能不同，但 没有任何 work-item 可以跨过 Barrier 执行，直到所有 work-item 都遇到了 Barrier。执行 Barrier 功能之后，所有工作 项就有了一致的内存。</li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/LDRabw0phooS5OxezqjcqSA1nQb-480.webp 480w, /assets/img/feishu_docs_static/LDRabw0phooS5OxezqjcqSA1nQb-800.webp 800w, /assets/img/feishu_docs_static/LDRabw0phooS5OxezqjcqSA1nQb-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/LDRabw0phooS5OxezqjcqSA1nQb.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <h3 id="基于-work-group-的本地内存进行同步">基于 Work-group 的本地内存进行同步</h3> <ul> <li>通信可以通过 USM 或缓冲区进行，但可能效率不高，因而可以专门划分一部分内存用于通信，作为 work-group 的本地内存。</li> <li>每个 work-group 都可以访问全局内存或自己的本地内存</li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/YBMwb79mmoHy8mx95y5cV1GhnZt-480.webp 480w, /assets/img/feishu_docs_static/YBMwb79mmoHy8mx95y5cV1GhnZt-800.webp 800w, /assets/img/feishu_docs_static/YBMwb79mmoHy8mx95y5cV1GhnZt-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/YBMwb79mmoHy8mx95y5cV1GhnZt.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div>]]></content><author><name></name></author><category term="开源项目源码"/><category term="系统-高性能计算"/><summary type="html"><![CDATA[SYCL+OneAPI+DPC++软件栈]]></summary></entry><entry><title type="html">阅读笔记 - (ATC’23)Beware of Fragmentation Scheduling GPU-Sharing Workloads with Fragmentation Gradient Descent</title><link href="https://xlcbingo1999.github.io/blog/2024/ATC23-BoF/" rel="alternate" type="text/html" title="阅读笔记 - (ATC’23)Beware of Fragmentation Scheduling GPU-Sharing Workloads with Fragmentation Gradient Descent"/><published>2024-04-23T00:00:00+00:00</published><updated>2024-04-23T00:00:00+00:00</updated><id>https://xlcbingo1999.github.io/blog/2024/ATC23-BoF</id><content type="html" xml:base="https://xlcbingo1999.github.io/blog/2024/ATC23-BoF/"><![CDATA[<p>Redirecting to Introduction of Introduction of (ATC’23)Beware of Fragmentation Scheduling GPU-Sharing Workloads with Fragmentation Gradient Descent</p>]]></content><author><name></name></author><category term="论文阅读笔记"/><category term="系统-ML任务级调度论文集合"/><summary type="html"><![CDATA[Introduction of (ATC'23)Beware of Fragmentation Scheduling GPU-Sharing Workloads with Fragmentation Gradient Descent]]></summary></entry><entry><title type="html">阿里GPU Sharing源码导读</title><link href="https://xlcbingo1999.github.io/blog/2024/Ali-GPU-Sharing/" rel="alternate" type="text/html" title="阿里GPU Sharing源码导读"/><published>2024-04-23T00:00:00+00:00</published><updated>2024-04-23T00:00:00+00:00</updated><id>https://xlcbingo1999.github.io/blog/2024/Ali-GPU-Sharing</id><content type="html" xml:base="https://xlcbingo1999.github.io/blog/2024/Ali-GPU-Sharing/"><![CDATA[<p>Redirecting to 阿里GPU Sharing源码导读</p>]]></content><author><name></name></author><category term="论文阅读笔记"/><category term="系统-ML任务级调度论文集合"/><summary type="html"><![CDATA[阿里GPU Sharing源码导读]]></summary></entry><entry><title type="html">Beware of Fragmentation模拟器</title><link href="https://xlcbingo1999.github.io/blog/2024/BoF-Simulation/" rel="alternate" type="text/html" title="Beware of Fragmentation模拟器"/><published>2024-04-23T00:00:00+00:00</published><updated>2024-04-23T00:00:00+00:00</updated><id>https://xlcbingo1999.github.io/blog/2024/BoF-Simulation</id><content type="html" xml:base="https://xlcbingo1999.github.io/blog/2024/BoF-Simulation/"><![CDATA[<p>Redirecting to Introduction of Beware of Fragmentation模拟器</p>]]></content><author><name></name></author><category term="论文阅读笔记"/><category term="系统-ML任务级调度论文集合"/><summary type="html"><![CDATA[Introduction of Beware of Fragmentation模拟器]]></summary></entry><entry><title type="html">CGraph源码导读与线程池优化研读</title><link href="https://xlcbingo1999.github.io/blog/2024/CGraph/" rel="alternate" type="text/html" title="CGraph源码导读与线程池优化研读"/><published>2024-04-23T00:00:00+00:00</published><updated>2024-04-23T00:00:00+00:00</updated><id>https://xlcbingo1999.github.io/blog/2024/CGraph</id><content type="html" xml:base="https://xlcbingo1999.github.io/blog/2024/CGraph/"><![CDATA[<blockquote> <p>更好的排版请阅读: https://we5lw6jk7r.feishu.cn/wiki/IhxUwMQ0gi8SjbkeIFyctZusnoc?from=from_copylink</p> </blockquote> <h1 id="cgraph">CGraph</h1> <h1 id="核心主工程代码">核心主工程代码</h1> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/OsNPbkXWBojXpDxKao3csBoDn3d-480.webp 480w, /assets/img/feishu_docs_static/OsNPbkXWBojXpDxKao3csBoDn3d-800.webp 800w, /assets/img/feishu_docs_static/OsNPbkXWBojXpDxKao3csBoDn3d-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/OsNPbkXWBojXpDxKao3csBoDn3d.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/EJiKbjhCpoaDIIxG0lScn3Oknid-480.webp 480w, /assets/img/feishu_docs_static/EJiKbjhCpoaDIIxG0lScn3Oknid-800.webp 800w, /assets/img/feishu_docs_static/EJiKbjhCpoaDIIxG0lScn3Oknid-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/EJiKbjhCpoaDIIxG0lScn3Oknid.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <h2 id="gpipeline-表示一个任务流的核心数据结构">GPipeline: 表示一个任务流的核心数据结构</h2> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">_class_</span> <span class="n">GPipeline</span> <span class="o">:</span> <span class="n">_public_</span> <span class="n">CObject</span> <span class="p">{</span>

<span class="nl">_public:</span><span class="n">_</span>
    <span class="cm">/**
     * 初始化pipeline信息
     * _@return_
     */</span>
    <span class="n">CSTATUS</span> <span class="n">init</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>

    <span class="cm">/**
     * 执行pipeline信息
     * _@return_
     */</span>
    <span class="n">CSTATUS</span> <span class="n">run</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>

    <span class="cm">/**
     * 逆初始化pipeline信息
     * _@return_
     */</span>
    <span class="n">CSTATUS</span> <span class="n">deinit</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>

    <span class="cm">/**
     * 一次性执行完成初始化，执行runTimes次，和逆初始化的过程
     * _@param_ _runTimes_
     * _@return_
     */</span>
    <span class="n">CSTATUS</span> <span class="n">process</span><span class="p">(</span><span class="n">_int_</span> <span class="n">_runTimes_</span> <span class="o">=</span> <span class="mi">1</span><span class="p">);</span>

    <span class="cm">/**
     * 根据传入的info信息，创建node节点
     * _@tparam_ T
     * _@param_ _info_
     * _@return_
     */</span>
    <span class="n">_template_</span><span class="o">&lt;</span><span class="n">_typename_</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="n">GElementPtr</span> <span class="n">createGNode</span><span class="p">(</span><span class="k">const</span> <span class="n">GNodeInfo</span> <span class="o">&amp;</span><span class="n">_info_</span><span class="p">);</span>

    <span class="cm">/**
     * 根据传入的信息，创建Group信息
     * _@tparam_ T
     * _@param_ _elements_
     * _@param_ _dependElements_
     * _@param_ _name_
     * _@param_ _loop_
     * _@return_
     */</span>
    <span class="n">_template_</span><span class="o">&lt;</span><span class="n">_typename_</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="n">GElementPtr</span> <span class="n">createGGroup</span><span class="p">(</span><span class="k">const</span> <span class="n">GElementPtrArr</span> <span class="o">&amp;</span><span class="n">_elements_</span><span class="p">,</span>
                             <span class="k">const</span> <span class="n">GElementPtrSet</span> <span class="o">&amp;</span><span class="n">_dependElements_</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">GElementPtr</span><span class="o">&gt;</span><span class="p">(),</span>
                             <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">_name_</span> <span class="o">=</span> <span class="s">""</span><span class="p">,</span>
                             <span class="n">_int_</span> <span class="n">_loop_</span> <span class="o">=</span> <span class="mi">1</span><span class="p">);</span>

    <span class="cm">/**
     * 在图中注册一个Element信息
     * 如果注册的是可执行节点，则内部自动生成；如果注册的是不可执行节点（如region或cluster），则需外部提前生成，然后注册进来
     * _@tparam_ T
     * _@param_ _elementRef_
     * _@param_ _dependElements_
     * _@param_ _name_
     * _@param_ _loop_
     * _@return_
     */</span>
    <span class="n">_template_</span><span class="o">&lt;</span><span class="n">_typename_</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="n">CSTATUS</span> <span class="n">registerGElement</span><span class="p">(</span><span class="n">GElementPtr</span> <span class="o">*</span><span class="n">_elementRef_</span><span class="p">,</span>
                             <span class="k">const</span> <span class="n">GElementPtrSet</span> <span class="o">&amp;</span><span class="n">_dependElements_</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">GElementPtr</span><span class="o">&gt;</span><span class="p">(),</span>
                             <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">_name_</span> <span class="o">=</span> <span class="s">""</span><span class="p">,</span>
                             <span class="n">_int_</span> <span class="n">_loop_</span> <span class="o">=</span> <span class="mi">1</span><span class="p">);</span>

<span class="nl">_protected:</span><span class="n">_</span>
    <span class="k">explicit</span> <span class="n">GPipeline</span><span class="p">();</span>

    <span class="o">~</span><span class="n">GPipeline</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>

    <span class="cm">/**
     * element元素，添加依赖节点信息
     * _@param_ _element_
     * _@param_ _dependElements_
     * _@return_
     */</span>
    <span class="n">CSTATUS</span> <span class="n">addDependElements</span><span class="p">(</span><span class="n">GElementPtr</span> <span class="n">_element_</span><span class="p">,</span>
                              <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">GElementPtr</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">_dependElements_</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

<span class="nl">_private:</span><span class="n">_</span>
    <span class="n">_bool_</span> <span class="n">is_init_</span><span class="p">;</span>                                       <span class="c1">// 标志位</span>
    <span class="n">GElementManagerPtr</span> <span class="n">element_manager_</span><span class="p">;</span>                 <span class="c1">// 节点管理类（管理所有注册过的element信息）</span>
    <span class="n">GraphThreadPoolPtr</span> <span class="n">thread_pool_</span><span class="p">;</span>                     <span class="c1">// 线程池类</span>
    <span class="n">GElementPtrSet</span> <span class="n">element_repository_</span><span class="p">;</span>                  <span class="c1">// 标记创建的所有节点，最终释放使用</span>
    <span class="n">GParamManagerPtr</span> <span class="n">param_manager_</span><span class="p">;</span>

    <span class="k">friend</span> <span class="n">_class_</span> <span class="n">GPipelineFactory</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="工厂类-gpipelinefactory-基于工厂模式来生成对应的-pipeline-并用于保存-pipeline-内容">工厂类 GPipelineFactory: 基于工厂模式来生成对应的 Pipeline, 并用于保存 pipeline 内容</h3> <ul> <li>工厂模式的代码其实都可以用 static 去实现，连保存的 Pipeline 列表也要用 static 存储，可以实现全局共享！</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">_class_</span> <span class="n">GPipelineFactory</span> <span class="o">:</span> <span class="n">_public_</span> <span class="n">CObject</span> <span class="p">{</span>

<span class="nl">_public:</span><span class="n">_</span>
    <span class="cm">/**
     * 创建一个pipeline信息
     * _@return_
     */</span>
    <span class="k">static</span> <span class="n">GPipelinePtr</span> <span class="n">create</span><span class="p">();</span>

    <span class="cm">/**
     * 销毁一个pipeline信息
     * _@return_
     */</span>
    <span class="k">static</span> <span class="n">_void_</span> <span class="n">destroy</span><span class="p">(</span><span class="n">GPipelinePtr</span> <span class="n">_pipeline_</span><span class="p">);</span>

    <span class="cm">/**
     * 清空所有的pipeline信息
     */</span>
    <span class="k">static</span> <span class="n">_void_</span> <span class="n">clear</span><span class="p">();</span>

<span class="nl">_protected:</span><span class="n">_</span>
    <span class="n">CSTATUS</span> <span class="n">run</span><span class="p">();</span>
    <span class="n">GPipelineFactory</span><span class="p">();</span>

<span class="nl">_private:</span><span class="n">_</span>
    <span class="k">static</span> <span class="n">GPipelinePtrList</span> <span class="n">pipeline_list_</span><span class="p">;</span>    <span class="c1">// 记录所有的</span>
    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">lock_</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="函数-registergelement用于注册一个新的-element-节点到-element_manager_中">函数 registerGElement()：用于注册一个新的 Element 节点到 element_manager_中</h3> <ul> <li>先判断 Element 是否存在于 element_manager_，如果存在就要删掉，然后重新进行生成</li> <li>设置当前 Element 节点的 ParamManager，每个 Pipeline 只有一个 ParamManager</li> <li>传入 name 表示当前节点的名字</li> <li>传入 loop 表示当前节点需要被循环遍历的次数</li> <li> <p>【核心功能】传入依赖的 element 集合，然后在 DAG 图中将这些依赖的 element 进行处理</p> <ul> <li>无法依赖空的 element</li> <li>无法依赖自身 element</li> <li>需要将被依赖的 element 的 run_before_（set&lt;GElement*&gt;）数据结构中加入当前的 element</li> <li>需要在当前 element 中加入被依赖的 element</li> <li>最后对当前的 element 设定 left_depend_字段，表示距离这个 element 可以执行还有多少任务的依赖！</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div> </div> </li> </ul> <p>CSTATUS GPipeline::addDependElements(GElementPtr <em>element</em>, const std::set<GElementPtr>&amp; _dependElements_) const { CGRAPH_FUNCTION_BEGIN</GElementPtr></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// TODO 这个功能可以下沉到element里去实现
CGRAPH_ASSERT_INIT(false)
CGRAPH_ASSERT_NOT_NULL(_element_)

for (GElementPtr cur : _dependElements_) {
    // 如果传入的信息中，有nullptr，则所有的信息均不参与计算
    CGRAPH_ASSERT_NOT_NULL(cur);
}

for (GElementPtr cur : _dependElements_) {
    if (cur == _element_) {
        continue;        // 本节点无法依赖本节点
    }

    cur-&gt;run_before_.insert(_element_);
    _element_-&gt;dependence_.insert(cur);
}

_element_-&gt;left_depend_ = _element_-&gt;dependence_.size();

CGRAPH_FUNCTION_END
</code></pre></div></div> <p>}</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
- 在element_manager_中加入当前element

- 在element_repository_中加入当前的element

```cpp
_template_&lt;_typename_ T&gt;
CSTATUS GPipeline::registerGElement(GElementPtr *_elementRef_,
                                    const GElementPtrSet &amp;_dependElements_,
                                    const std::string &amp;_name_,
                                    _int_ _loop_) {
    CGRAPH_FUNCTION_BEGIN
    CGRAPH_ASSERT_INIT(false)

    if (element_manager_-&gt;hasElement(*_elementRef_)) {
        element_manager_-&gt;deleteElement(*_elementRef_);    // 每次注册，都默认为是新的节点
    }

    /**
     * 如果是GNode类型，则直接创建节点
     * 如果不是GNode类型，则需要外部创建好，然后注册进来
     * */
    if (std::is_base_of&lt;GNode, T&gt;::value) {
        (*_elementRef_) = new(std::nothrow) T();
    }

    CGRAPH_ASSERT_NOT_NULL(*elementRef)
    status = (*_elementRef_)-&gt;setParamManager(this-&gt;param_manager_);
    CGRAPH_FUNCTION_CHECK_STATUS

    (*_elementRef_)-&gt;setName(_name_);
    (*_elementRef_)-&gt;setLoop(_loop_);
    status = addDependElements(*_elementRef_, _dependElements_);
    CGRAPH_FUNCTION_CHECK_STATUS

    status = element_manager_-&gt;addElement(dynamic_cast&lt;GElementPtr&gt;(*_elementRef_));
    CGRAPH_FUNCTION_CHECK_STATUS
    element_repository_.insert(*_elementRef_);
    CGRAPH_FUNCTION_END
}
</code></pre></div></div> <h3 id="函数-init初始化并-mock-执行以分析整张-dag-图">函数 init()：初始化并 mock 执行以分析整张 DAG 图</h3> <ul> <li> <p>检查核心成员变量是否存在</p> <ul> <li>thread_pool_</li> <li>element_manager_</li> <li>param_maneger_</li> </ul> </li> <li> <p>初始化 element_manager_：用于管理整张图的 Element</p> <ul> <li>第一步，判断 DAG 图的每个节点是否是独立联通的 isLinkable，【每个节点只能有一个依赖，每个节点的依赖节点只有一个后继节点且为当前（不能并行？？？）】</li> <li>第二步，分析 DAG 图【只会遍历分析 left_depend_小于等于 0 的节点，且节点不是 isLinkable 的】 <ul> <li>针对每个 element，都会新建一个 GCluster，并将当前遍历到的节点加入到 GCluster 中，然后不断遍历节点的后续节点，一起放到 GCluster 中。【这里似乎是一个 DFS 的遍历逻辑，如果一个节点有多个后继节点，只会选择第一个联通的 element 放入 GCluster 中】</li> <li>总共会创建 element 数量个 GCluster，多个 Cluster 理论上应该是可以并行的？放置在临时 vector 变量 curClusterArr 中，同时 para_cluster_arrs_需要将这个 curClusterArr 加入状态中？</li> <li>拷贝 curClusterArr 为 runnableClusterArr 并清空 curClusterArr，其中每个 GCluster 都要进行一次 mock 执行，不会执行实际的 Run，只是做一些逻辑上的处理，然后每次都构建新的 curClusterArr，不太清楚为什么要这么构造</li> </ul> </li> <li>第三步，初始化所有 element</li> </ul> </li> </ul> <h3 id="函数-run异步执行-dag-图上的任务">函数 run()：异步执行 DAG 图上的任务</h3> <ul> <li> <p>检查核心字段是否正常</p> <ul> <li>is_init_</li> <li>thread_pool_</li> <li>element_manager_</li> <li>param_maneger_</li> </ul> </li> <li>构建一个 future<CSTATUS>的数组</CSTATUS></li> <li> <p>遍历可以并行的 cluster 数组，每次都要把 futures 数组清空，然后再遍历 GCluster</p> <ul> <li>针对每个 GCluster，需要让 Pipeline 的线程池去 commit GCluster【本质上就是任务添加到队列中，队列的内容就是一个个 lambda 函数，如果线程池中空闲的线程少了，就增加点新的线程】，返回的 future 会被加入到 futures 中</li> <li>遍历所有的 futures，用于获取状态【不知道为什么】</li> </ul> </li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">CSTATUS</span> <span class="n">GPipeline</span><span class="o">::</span><span class="n">run</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">CGRAPH_FUNCTION_BEGIN</span>

    <span class="n">CGRAPH_ASSERT_INIT</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span>
    <span class="n">CGRAPH_ASSERT_NOT_NULL</span><span class="p">(</span><span class="n">thread_pool_</span><span class="p">)</span>
    <span class="n">CGRAPH_ASSERT_NOT_NULL</span><span class="p">(</span><span class="n">element_manager_</span><span class="p">)</span>
    <span class="n">CGRAPH_ASSERT_NOT_NULL</span><span class="p">(</span><span class="n">param_manager_</span><span class="p">)</span>

    <span class="kt">int</span> <span class="n">runElementSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="n">CSTATUS</span><span class="o">&gt;&gt;</span> <span class="n">futures</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">GClusterArr</span><span class="o">&amp;</span> <span class="n">clusterArr</span> <span class="o">:</span> <span class="n">element_manager_</span><span class="o">-&gt;</span><span class="n">para_cluster_arrs_</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">futures</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">GCluster</span><span class="o">&amp;</span> <span class="n">cluster</span> <span class="o">:</span> <span class="n">clusterArr</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">futures</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">thread_pool_</span><span class="o">-&gt;</span><span class="n">commit</span><span class="p">(</span><span class="n">cluster</span><span class="p">)));</span>
            <span class="n">runElementSize</span> <span class="o">+=</span> <span class="n">cluster</span><span class="p">.</span><span class="n">getElementNum</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">fut</span> <span class="o">:</span> <span class="n">futures</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">status</span> <span class="o">=</span> <span class="n">fut</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
            <span class="n">CGRAPH_FUNCTION_CHECK_STATUS</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">param_manager_</span><span class="o">-&gt;</span><span class="n">reset</span><span class="p">();</span>
    <span class="n">status</span> <span class="o">=</span> <span class="n">element_manager_</span><span class="o">-&gt;</span><span class="n">afterRunCheck</span><span class="p">(</span><span class="n">runElementSize</span><span class="p">);</span>
    <span class="n">CGRAPH_FUNCTION_END</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="函数-deinit用于逆初始化结束计算">函数 deinit()：用于逆初始化，结束计算</h3> <ul> <li>核心的内容是对 param_manager_的哈希表进行清空，删除 value 指针的对象，然后将整个哈希表 clear</li> </ul> <h3 id="函数-process--initrundeinit-的集合">函数 process(): init+run+deinit 的集合</h3> <h3 id="函数-createggroup-用于创建一个节点组合">函数 createGGroup()： 用于创建一个节点组合</h3> <ul> <li>创建一种 GGroup，可以是 GCluster 或者是 GCondition，然后将每一个 element 加入 vector 中</li> </ul> <h3 id="函数-creategnode用于创建一个自定义的节点">函数 createGNode()：用于创建一个自定义的节点</h3> <ul> <li>GNode 是继承 GElement 的一个对象，可以根据 Info 来创建</li> </ul> <h3 id="核心成员变量">核心成员变量</h3> <ul> <li>bool is_init_：表示当前的 pipeline 是否被初始化了</li> <li>GElementManagerPtr element_manager_： 用于管理所有的 element</li> <li>GraphThreadPoolPtr thread_pool_： 用于放置线程池</li> <li>GElementPtrSet element_repository_： 用于标记所有被创建的节点，可以在最终释放的时候被使用！</li> <li>GParamManagerPtr param_manager_：参数管理器，整个 pipeline 会全局共享所有的参数</li> </ul> <h2 id="gelement-表示一个-dag-图中的节点">GElement: 表示一个 DAG 图中的节点</h2> <h3 id="管理类-gelementmanager">管理类 GElementManager</h3> <h4 id="函数-preruncheck用于在执行之前检查每个-element-是否为-linkable-的">函数 preRunCheck()：用于在执行之前检查每个 Element 是否为 linkable 的</h4> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">CSTATUS</span> <span class="n">GElementManager</span><span class="o">::</span><span class="n">preRunCheck</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">CGRAPH_FUNCTION_BEGIN</span>

    <span class="cm">/**
     * 认定图可以连通的判定条件：
     * 1，当前节点仅有一个依赖
     * 2，当前节点依赖的节点，只有一个后继
     * 3，当前节点的依赖的后继，仍是当前节点
     */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">GElement</span><span class="o">*</span> <span class="n">element</span> <span class="o">:</span> <span class="n">manager_elements_</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="mi">1</span> <span class="o">==</span> <span class="n">element</span><span class="o">-&gt;</span><span class="n">dependence_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span>
            <span class="o">&amp;&amp;</span> <span class="mi">1</span> <span class="o">==</span> <span class="p">(</span><span class="o">*</span><span class="n">element</span><span class="o">-&gt;</span><span class="n">dependence_</span><span class="p">.</span><span class="n">begin</span><span class="p">())</span><span class="o">-&gt;</span><span class="n">run_before_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span>
            <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">element</span><span class="o">-&gt;</span><span class="n">dependence_</span><span class="p">.</span><span class="n">begin</span><span class="p">()))</span><span class="o">-&gt;</span><span class="n">run_before_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">element</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">element</span><span class="o">-&gt;</span><span class="n">dependence_</span><span class="p">.</span><span class="n">begin</span><span class="p">()))</span><span class="o">-&gt;</span><span class="n">run_before_</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">element</span><span class="o">-&gt;</span><span class="n">linkable_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">CGRAPH_FUNCTION_END</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="函数-analyse-用于分析一张-dag-图中如何构建多个支持并行的-cluster">函数 analyse(): 用于分析一张 DAG 图中如何构建多个支持并行的 Cluster</h4> <h4 id="核心成员变量-1">核心成员变量</h4> <ul> <li>GElementPtrSet manager_elements_; // 保存节点信息的内容</li> <li>ParaWorkedClusterArrs para_cluster_arrs_; // 可以并行的 cluster 数组</li> </ul> <h3 id="核心成员变量-2">核心成员变量</h3> <ul> <li>bool done_ { false }; // 判定被执行结束</li> <li>bool is_init_ { false }; // 是否初始化了</li> <li>bool linkable_ { false }; // 判定是否可以连通计算</li> <li>int loop_ { 1 }; // 节点执行次数</li> <li>std::string name_; // 节点名称</li> <li>std::string session_; // 节点唯一 id 信息</li> <li>std::set&lt;GElement *&gt; run_before_; // 被依赖的节点</li> <li>std::set&lt;GElement *&gt; dependence_; // 依赖的节点信息</li> <li>std::atomic<int> left_depend_{ 0 }; // 当 left_depend_ 值为 0 的时候，即可以执行该 node 信息</int></li> <li>GParamManagerPtr param_manager_; // 整体流程的参数管理类，所有 pipeline 中的所有节点共享</li> </ul> <h2 id="ggroup-表示节点组合的一个基类-所有节点组合的功能都来自于此类">GGroup: 表示节点组合的一个基类, 所有节点组合的功能都来自于此类</h2> <h3 id="gcluster-表示-dag-图中的一个簇可以线性执行的几个-element">GCluster: 表示 DAG 图中的一个簇(可以线性执行的几个 element)</h3> <ul> <li>线性同步执行的一个组合</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">CSTATUS</span> <span class="n">GCluster</span><span class="o">::</span><span class="n">run</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">CGRAPH_FUNCTION_BEGIN</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">GElementPtr</span> <span class="n">element</span> <span class="o">:</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">cluster_elements_</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_int_</span> <span class="n">elementLoop</span> <span class="o">=</span> <span class="n">element</span><span class="o">-&gt;</span><span class="n">loop_</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">elementLoop</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// element需要被执行loop次</span>
            <span class="n">status</span> <span class="o">=</span> <span class="n">element</span><span class="o">-&gt;</span><span class="n">run</span><span class="p">();</span>
            <span class="n">CGRAPH_FUNCTION_CHECK_STATUS</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">CGRAPH_FUNCTION_END</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="gcondition-表示-dag-图中的一个条件类-选择-group-中的其中一个-element-执行">GCondition: 表示 DAG 图中的一个条件类, 选择 group 中的其中一个 element 执行</h3> <ul> <li>核心思想，在 GCondition 进行 run()的时候，根据 choose()函数来选择对应的执行 element</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">CSTATUS</span> <span class="n">GCondition</span><span class="o">::</span><span class="n">run</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">CGRAPH_FUNCTION_BEGIN</span>

    <span class="n">_int_</span> <span class="n">loop</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">_int_</span> <span class="n">index</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">choose</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">GROUP_LAST_ELEMENT_INDEX</span> <span class="o">==</span> <span class="n">index</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">condition_elements_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 如果返回-1，则直接执行最后一个条件（模仿default功能）</span>
        <span class="n">loop</span> <span class="o">=</span> <span class="n">condition_elements_</span><span class="p">.</span><span class="n">back</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">loop_</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">loop</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">status</span> <span class="o">=</span> <span class="n">condition_elements_</span><span class="p">.</span><span class="n">back</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">run</span><span class="p">();</span>
            <span class="n">CGRAPH_FUNCTION_CHECK_STATUS</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">index</span> <span class="o">&amp;&amp;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">condition_elements_</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
        <span class="c1">// 如果返回的内容，在元素范围之内，则直接执行元素的内容</span>
        <span class="n">loop</span> <span class="o">=</span> <span class="n">condition_elements_</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">loop_</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">loop</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">status</span> <span class="o">=</span> <span class="n">condition_elements_</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">run</span><span class="p">();</span>
            <span class="n">CGRAPH_FUNCTION_CHECK_STATUS</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// 设定的index不在范围内，返回错误信息</span>
        <span class="n">status</span> <span class="o">=</span> <span class="n">STATUS_ERR</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">CGRAPH_FUNCTION_END</span>
<span class="p">}</span>
</code></pre></div></div> <ul> <li>自定义注册一个 choose()方法</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">_class_</span> <span class="n">MyParamCondition</span> <span class="o">:</span> <span class="n">_public_</span> <span class="n">GCondition</span> <span class="p">{</span>

<span class="nl">_public:</span><span class="n">_</span>
    <span class="cm">/**
     * 在这里主要演示condition中可以通过获取上方参数的形式，
     * 来决定执行执行当前的第几个逻辑
     * _@return_
     */</span>
    <span class="n">_int_</span> <span class="n">choose</span> <span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
        <span class="n">MyParam</span><span class="o">*</span> <span class="n">myParam</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">getGParam</span><span class="o">&lt;</span><span class="n">MyParam</span><span class="o">&gt;</span><span class="p">(</span><span class="s">"param1"</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">nullptr</span> <span class="o">==</span> <span class="n">myParam</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">GROUP_LAST_ELEMENT_INDEX</span><span class="p">;</span>    <span class="c1">// 如果没获取到，固定执行最后一个逻辑</span>
        <span class="p">}</span>

        <span class="n">_int_</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">{</span>
            <span class="n">CGRAPH_PARAM_READ_CODE_BLOCK</span><span class="p">(</span><span class="n">myParam</span><span class="p">)</span>    <span class="c1">// 如果当前算子，跟其他相关依赖算子不存在并行关系，则参数可以直接使用，不需要加锁</span>
            <span class="n">cnt</span> <span class="o">=</span> <span class="n">myParam</span><span class="o">-&gt;</span><span class="n">iCount</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">%</span> <span class="n">getRange</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="gregion-表示子图内部还是可以并行的">GRegion: 表示子图内部还是可以并行的</h3> <ul> <li>此时在 GRegion 内部需要从外部注入一个 Thread_pool 进去，一般来说是和整个 DAG 共用一个线程池</li> </ul> <h4 id="重写函数-run-和-pipeline-的执行流程类似-支持子图内并行">重写函数 run(): 和 Pipeline 的执行流程类似, 支持子图内并行</h4> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">CSTATUS</span> <span class="n">GRegion</span><span class="o">::</span><span class="n">run</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">CGRAPH_FUNCTION_BEGIN</span>
    <span class="n">CGRAPH_ASSERT_INIT</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span>
    <span class="n">CGRAPH_ASSERT_NOT_NULL</span><span class="p">(</span><span class="n">thread_pool_</span><span class="p">)</span>
    <span class="n">CGRAPH_ASSERT_NOT_NULL</span><span class="p">(</span><span class="n">manager_</span><span class="p">)</span>

    <span class="n">_int_</span> <span class="n">runNodeSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="n">CSTATUS</span><span class="o">&gt;&gt;</span> <span class="n">futures</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">GClusterArr</span><span class="o">&amp;</span> <span class="n">clusterArr</span> <span class="o">:</span> <span class="n">manager_</span><span class="o">-&gt;</span><span class="n">para_cluster_arrs_</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">futures</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">GCluster</span><span class="o">&amp;</span> <span class="n">cluster</span> <span class="o">:</span> <span class="n">clusterArr</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">futures</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">thread_pool_</span><span class="o">-&gt;</span><span class="n">commit</span><span class="p">(</span><span class="n">cluster</span><span class="p">)));</span>
            <span class="n">runNodeSize</span> <span class="o">+=</span> <span class="n">cluster</span><span class="p">.</span><span class="n">getElementNum</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">_auto_</span><span class="o">&amp;</span> <span class="n">fut</span> <span class="o">:</span> <span class="n">futures</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">status</span> <span class="o">=</span> <span class="n">fut</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
            <span class="n">CGRAPH_FUNCTION_CHECK_STATUS</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">status</span> <span class="o">=</span> <span class="n">manager_</span><span class="o">-&gt;</span><span class="n">afterRunCheck</span><span class="p">(</span><span class="n">runNodeSize</span><span class="p">);</span>
    <span class="n">CGRAPH_FUNCTION_END</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="核心成员变量-3">核心成员变量</h4> <ul> <li>GElementManagerPtr manager_; // 在 GRegion 内部也是需要一个 ElementManager 管理器的，实例化一个 Region 的时候新建</li> <li>GraphThreadPoolPtr thread_pool_; // 这里需要使用 GPipeline 类的线程池</li> </ul> <h2 id="graphthreadpool-核心的线程池类">GraphThreadPool: 核心的线程池类</h2> <h3 id="核心成员变量-4">核心成员变量</h3> <ul> <li>std::vector<a href="std::thread">std::thread</a> pool_; // 线程池</li> <li>std::queue<TaskFunc> tasks_que_; // 任务队列</TaskFunc></li> <li>std::mutex mtx_; // 同步</li> <li>std::condition_variable task_cond_; // 条件阻塞</li> <li>std::atomic<bool> run_{ true }; // 线程池是否执行</bool></li> <li>std::atomic<int> idl_thd_num_{ 0 }; // 空闲线程数量</int></li> <li>std::atomic<int> max_thd_num_{ MAX_THREAD_NUM }; // 最大线程数</int></li> </ul> <h3 id="run-线程空转函数">run(): 线程空转函数</h3> <ul> <li>不断执行，每一次都是加锁后先进先出从队列中取一个 task【一般要用 std::move()实现对象的移动】，然后执行对应函数</li> <li>如果当前队列为空或者整个线程处于 idle 没有被使用的状态，会阻塞在 task_cond_的逻辑中，直到其他线程发起通知才可以继续进行。</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">_int_</span> <span class="nf">run</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">run_</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">TaskFunc</span> <span class="n">curFunc</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
        <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">{</span> <span class="n">mtx_</span> <span class="p">};</span>
            <span class="n">task_cond_</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="p">[</span><span class="k">this</span><span class="p">]{</span>
                <span class="c1">// 值为false的时候，会阻塞当前线程</span>
                <span class="c1">// 收到其他线程通知后，值为true的时候，会解除阻塞</span>
                <span class="k">return</span> <span class="p">(</span><span class="o">!</span><span class="n">run_</span> <span class="o">||</span> <span class="o">!</span><span class="n">tasks_que_</span><span class="p">.</span><span class="n">empty</span><span class="p">());</span>
            <span class="p">});</span>

            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">run_</span> <span class="o">&amp;&amp;</span> <span class="n">tasks_que_</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">curFunc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">tasks_que_</span><span class="p">.</span><span class="n">front</span><span class="p">());</span>    <span class="c1">// 按先进先出从队列取一个 task</span>
            <span class="n">tasks_que_</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="n">idl_thd_num_</span><span class="o">--</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">curFunc</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">curFunc</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="n">idl_thd_num_</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="commit-将一个-cluster-的内容加入到任务队列中">commit(): 将一个 Cluster 的内容加入到任务队列中</h3> <ul> <li>利用 std::bind()将 GCluster::process 和具体要执行的 GCluster 实例绑定在一起</li> <li>利用 std::packaged_tack&lt;int()&gt; 制作一个异步执行任务，然后将任务和对应的 future 绑定在一起，可以通过 get_future()来获取对应的句柄</li> <li>利用 std::make_shared&lt;&gt; 来构建 future 的智能指针，基于引用计数的方案可以实现 RAII</li> <li>利用 std::lock_guard 的对锁的管理属于 RAII 风格用法(Resource Acquisition Is Initialization)，在构造函数中自动绑定它的互斥体并加锁，在析构函数中解锁，大大减少了死锁的风险。</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="n">_int_</span><span class="o">&gt;</span> <span class="n">commit</span><span class="p">(</span><span class="k">const</span> <span class="n">GCluster</span><span class="o">&amp;</span> <span class="n">_cluster_</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">_auto_</span> <span class="n">curTask</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">packaged_task</span><span class="o">&lt;</span><span class="n">_int_</span><span class="p">()</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">GCluster</span><span class="o">::</span><span class="n">process</span><span class="p">,</span> <span class="n">_cluster_</span><span class="p">,</span> <span class="nb">false</span><span class="p">));</span>
    <span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="n">_int_</span><span class="o">&gt;</span> <span class="n">future</span> <span class="o">=</span> <span class="n">curTask</span><span class="o">-&gt;</span><span class="n">get_future</span><span class="p">();</span>
    <span class="p">{</span>
        <span class="c1">// 添加任务到队列</span>
        <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">{</span> <span class="n">mtx_</span> <span class="p">};</span>
        <span class="n">tasks_que_</span><span class="p">.</span><span class="n">push</span><span class="p">([</span><span class="n">curTask</span><span class="p">]()</span> <span class="p">{</span>
            <span class="p">(</span><span class="o">*</span><span class="n">curTask</span><span class="p">)();</span>
        <span class="p">});</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">idl_thd_num_</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">pool_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">max_thd_num_</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 如果空闲thread小于1，并且不超过max限制</span>
            <span class="n">addThread</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">task_cond_</span><span class="p">.</span><span class="n">notify_one</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">future</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="gparam-表示参数的类">GParam: 表示参数的类</h2> <ul> <li> <p>核心思想：读写锁管理一份共享的内存参数</p> <ul> <li>std::mutex 互斥锁 =&gt; std::lock_guard<a href="std::mutex">std::mutex</a> 实现 RAII</li> <li>std::shared_mutex 读写锁（共享级别：多个线程可以共享锁的所有权； 独占级别：仅有一个线程可以获得锁） <ul> <li>std::shared_lock<a href="std::shared_mutex">std::shared_mutex</a>：实现共享级别的 RAII</li> <li>std::unique_lock<a href="std::shared_mutex">std::shared_mutex</a>： 实现互斥级别的 RAII</li> </ul> </li> </ul> </li> <li> <p>中心化存储所有的参数数据，函数是没有返回值的也不会有参数，所有的函数都要重新自己去注册，写起来似乎也不是很方便。</p> </li> </ul> <h2 id="gaspect-表示切面-可以为某个-element-增加装饰器">GAspect: 表示切面, 可以为某个 Element 增加装饰器</h2> <ul> <li>一般来说需要协商好切面实现的接口 <ul> <li>beginInit</li> <li>finishInit</li> <li>beginRun</li> <li>finishRun</li> <li>beginDestroy</li> <li>finishDestroy</li> </ul> </li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">_class_</span> <span class="n">MyTraceAspect</span> <span class="o">:</span> <span class="n">_public_</span> <span class="n">CGraph</span><span class="o">::</span><span class="n">GAspect</span> <span class="p">{</span>
<span class="nl">_public:</span><span class="n">_</span>
    <span class="cm">/**
     * 实现几个切面函数逻辑，模拟在对应执行的位置，打印trace信息
     */</span>
    <span class="n">CStatus</span> <span class="n">beginInit</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
        <span class="n">CGraph</span><span class="o">::</span><span class="n">CGRAPH_ECHO</span><span class="p">(</span><span class="s">"----&gt; [MyTraceAspect] [%s] init begin ..."</span><span class="p">,</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">getName</span><span class="p">().</span><span class="n">c_str</span><span class="p">());</span>
        <span class="k">return</span> <span class="n">CStatus</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">CVoid</span> <span class="nf">finishInit</span><span class="p">(</span><span class="k">const</span> <span class="n">CStatus</span><span class="o">&amp;</span> <span class="n">_curStatus_</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
        <span class="n">CGraph</span><span class="o">::</span><span class="n">CGRAPH_ECHO</span><span class="p">(</span><span class="s">"----&gt; [MyTraceAspect] [%s] init finished, error code is [%d] ..."</span><span class="p">,</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">getName</span><span class="p">().</span><span class="n">c_str</span><span class="p">(),</span>
                            <span class="n">_curStatus_</span><span class="p">.</span><span class="n">getCode</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="n">CStatus</span> <span class="nf">beginRun</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
        <span class="n">CGraph</span><span class="o">::</span><span class="n">CGRAPH_ECHO</span><span class="p">(</span><span class="s">"----&gt; [MyTraceAspect] [%s] run begin ..."</span><span class="p">,</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">getName</span><span class="p">().</span><span class="n">c_str</span><span class="p">());</span>
        <span class="k">return</span> <span class="nf">CStatus</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">CVoid</span> <span class="nf">finishRun</span><span class="p">(</span><span class="k">const</span> <span class="n">CStatus</span><span class="o">&amp;</span> <span class="n">_curStatus_</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_curStatus_</span><span class="p">.</span><span class="n">isOK</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">CGraph</span><span class="o">::</span><span class="n">CGRAPH_ECHO</span><span class="p">(</span><span class="s">"----&gt; [MyTraceAspect] [%s] run finished, status is ok ..."</span><span class="p">,</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">getName</span><span class="p">().</span><span class="n">c_str</span><span class="p">());</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">CGraph</span><span class="o">::</span><span class="n">CGRAPH_ECHO</span><span class="p">(</span><span class="s">"----&gt; [MyTraceAspect] [%s] run finished, error code is [%d] ..."</span><span class="p">,</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">getName</span><span class="p">().</span><span class="n">c_str</span><span class="p">(),</span>
                                <span class="n">_curStatus_</span><span class="p">.</span><span class="n">getCode</span><span class="p">());</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">CStatus</span> <span class="nf">beginDestroy</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
        <span class="n">CGraph</span><span class="o">::</span><span class="n">CGRAPH_ECHO</span><span class="p">(</span><span class="s">"----&gt; [MyTraceAspect] [%s] destroy begin ..."</span><span class="p">,</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">getName</span><span class="p">().</span><span class="n">c_str</span><span class="p">());</span>
        <span class="k">return</span> <span class="nf">CStatus</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">CVoid</span> <span class="nf">finishDestroy</span><span class="p">(</span><span class="k">const</span> <span class="n">CStatus</span><span class="o">&amp;</span> <span class="n">_curStatus_</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
        <span class="n">CGraph</span><span class="o">::</span><span class="n">CGRAPH_ECHO</span><span class="p">(</span><span class="s">"----&gt; [MyTraceAspect] [%s] destroy finished, error code is [%d] ..."</span><span class="p">,</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">getName</span><span class="p">().</span><span class="n">c_str</span><span class="p">(),</span>
                            <span class="n">_curStatus_</span><span class="p">.</span><span class="n">getCode</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <ul> <li>本质上就是在执行之前，根据反射方法找到当前需要执行的 Aspect 类型，然后调用执行即可</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">CStatus</span> <span class="n">GElement</span><span class="o">::</span><span class="n">fatProcessor</span><span class="p">(</span><span class="k">const</span> <span class="n">CFunctionType</span><span class="o">&amp;</span> <span class="n">type</span><span class="p">,</span> <span class="n">CSize</span> <span class="n">loop</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">CGRAPH_FUNCTION_BEGIN</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">loop</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">case</span> <span class="n">CFunctionType</span><span class="o">::</span><span class="n">RUN</span><span class="p">:</span> <span class="p">{</span>
                <span class="cm">/** 执行带切面的run方法 */</span>
                <span class="n">status</span> <span class="o">=</span> <span class="n">doAspect</span><span class="p">(</span><span class="n">GAspectType</span><span class="o">::</span><span class="n">BEGIN_RUN</span><span class="p">);</span>
                <span class="n">CGRAPH_FUNCTION_CHECK_STATUS</span>
                <span class="k">do</span> <span class="p">{</span>
                    <span class="n">status</span> <span class="o">=</span> <span class="n">run</span><span class="p">();</span>
                    <span class="cm">/**
                     * 如果状态是ok的，并且被条件hold住，则循环执行
                     * 默认所有element的isHold条件均为false，即不hold，即执行一次
                     * 可以根据需求，对任意element类型，添加特定的isHold条件
                     * */</span>
                <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">status</span><span class="p">.</span><span class="n">isOK</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">isHold</span><span class="p">());</span>
                <span class="n">doAspect</span><span class="p">(</span><span class="n">GAspectType</span><span class="o">::</span><span class="n">FINISH_RUN</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">case</span> <span class="n">CFunctionType</span><span class="o">::</span><span class="n">INIT</span><span class="p">:</span> <span class="p">{</span>
                <span class="n">status</span> <span class="o">=</span> <span class="n">doAspect</span><span class="p">(</span><span class="n">GAspectType</span><span class="o">::</span><span class="n">BEGIN_INIT</span><span class="p">);</span>
                <span class="n">CGRAPH_FUNCTION_CHECK_STATUS</span>
                <span class="n">status</span> <span class="o">=</span> <span class="n">init</span><span class="p">();</span>
                <span class="n">doAspect</span><span class="p">(</span><span class="n">GAspectType</span><span class="o">::</span><span class="n">FINISH_INIT</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">case</span> <span class="n">CFunctionType</span><span class="o">::</span><span class="n">DESTROY</span><span class="p">:</span> <span class="p">{</span>
                <span class="n">status</span> <span class="o">=</span> <span class="n">doAspect</span><span class="p">(</span><span class="n">GAspectType</span><span class="o">::</span><span class="n">BEGIN_DESTROY</span><span class="p">);</span>
                <span class="n">CGRAPH_FUNCTION_CHECK_STATUS</span>
                <span class="n">status</span> <span class="o">=</span> <span class="n">destroy</span><span class="p">();</span>
                <span class="n">doAspect</span><span class="p">(</span><span class="n">GAspectType</span><span class="o">::</span><span class="n">FINISH_DESTROY</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">default</span><span class="o">:</span>
                <span class="n">CGRAPH_RETURN_ERROR_STATUS</span><span class="p">(</span><span class="s">"get function type error"</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">CGRAPH_FUNCTION_END</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="gdaemon-表示每隔几秒之后就要执行一次逻辑">GDaemon: 表示每隔几秒之后就要执行一次逻辑</h2> <ul> <li>std::async：C++11 提出的异步逻辑，会返回一个 std::future<T> </T> <ul> <li>参数 1：启动策略 <ul> <li>std::launch::async： 保证异步行为，异步函数将会在独立的线程中执行</li> <li>std::launch::deferred： 当其他线程调用 get()来访问状态的时候，将调用非异步行为</li> <li> <table> <tbody> <tr> <td>std::launch::async</td> <td>std::launch::deferred： 由系统来决定是否异步执行</td> </tr> </tbody> </table> </li> </ul> </li> <li>参数 2：实际的异步函数和回调返回 <ul> <li>直接使用函数</li> <li>使用函数对象 【比如在类中重载一个 operator() 】</li> <li>lambda 表达式</li> </ul> </li> </ul> </li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">_template_</span><span class="o">&lt;</span><span class="n">_typename_</span> <span class="n">FunctionType</span><span class="o">&gt;</span>
<span class="n">CVoid</span> <span class="nf">start</span><span class="p">(</span><span class="n">CMSec</span> <span class="n">_interval_</span><span class="p">,</span> <span class="k">const</span> <span class="n">FunctionType</span><span class="o">&amp;</span> <span class="n">_task_</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_stop_</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>    <span class="c1">// 如果正在执行中，则无法继续执行</span>
    <span class="p">}</span>

    <span class="n">is_stop_</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="cm">/**
     * std::launch::async：在调用async就开始创建线程。
     * std::launch::deferred：延迟加载方式创建线程。调用async时不创建线程，直到调用了future的get或者wait时才创建线程。
     * 后期会考虑将这个功能融合到线程池中去
     */</span>
    <span class="n">future_</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">async</span><span class="p">,</span> <span class="p">[</span><span class="k">this</span><span class="p">,</span> <span class="n">_interval_</span><span class="p">,</span> <span class="n">_task_</span><span class="p">]()</span> <span class="p">{</span>
         <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">is_stop_</span><span class="p">)</span> <span class="p">{</span>
             <span class="n">CGRAPH_UNIQUE_LOCK</span> <span class="n">lk</span><span class="p">(</span><span class="n">mutex_</span><span class="p">);</span>
             <span class="k">const</span> <span class="n">_auto_</span><span class="o">&amp;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">cv_</span><span class="p">.</span><span class="n">wait_for</span><span class="p">(</span><span class="n">lk</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="n">_interval_</span><span class="p">));</span>
             <span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cv_status</span><span class="o">::</span><span class="n">timeout</span> <span class="o">==</span> <span class="n">result</span><span class="p">)</span> <span class="p">{</span>
                 <span class="n">_task_</span><span class="p">();</span>
             <span class="p">}</span>
         <span class="p">}</span>
    <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div> <h1 id="dag-图调度优化">DAG 图调度优化</h1> <h2 id="dag-图的最大并发量计算">DAG 图的最大并发量计算</h2> <ul> <li>第一步：求出全路径</li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/BOambQ8W1ogoZyxMwXycdO9inUe-480.webp 480w, /assets/img/feishu_docs_static/BOambQ8W1ogoZyxMwXycdO9inUe-800.webp 800w, /assets/img/feishu_docs_static/BOambQ8W1ogoZyxMwXycdO9inUe-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/BOambQ8W1ogoZyxMwXycdO9inUe.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <ul> <li>第二步：根据全路径，得出所有可达点对</li> <li>第三步，根据上面的点集信息，得到对应的二维矩阵，其中 A 可以到达 BCDEF，B 可以到达 ADEF</li> <li>第四步，求出二维矩阵的最大独立集【独立集是一个顶点的集合，集合中的顶点两两不相邻】</li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/QOnZb33xnoCRi8xZSjccgV82nHb-480.webp 480w, /assets/img/feishu_docs_static/QOnZb33xnoCRi8xZSjccgV82nHb-800.webp 800w, /assets/img/feishu_docs_static/QOnZb33xnoCRi8xZSjccgV82nHb-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/QOnZb33xnoCRi8xZSjccgV82nHb.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <h2 id="退出暂停和恢复机制">退出、暂停和恢复机制</h2> <h1 id="线程池优化方案">线程池优化方案</h1> <ul> <li> <p>C++ 线程池的问题</p> <ul> <li>C++11 之前线程基本是没有标准库线程可以用的</li> <li>threadpool 和 barrier 需要自己去实现</li> </ul> </li> <li> <p>任务队列</p> <ul> <li>存放的元素都是一个个自定义输入输出的任务，任务入队之前要对 queue 的尾部加锁</li> <li>几个 thread 会竞争获取任务队列的头部任务，任务出队的时候要对 queue 的头部加锁</li> </ul> </li> <li> <p>并发优化的基本点</p> <ul> <li>增加扇入扇出</li> <li>增加负载</li> </ul> </li> <li> <p>目标</p> <ul> <li>开箱即用，使用 std 库手工实现</li> <li>简单易用，任务队列可以支持任意格式的任务</li> <li>性能强</li> </ul> </li> </ul> <h2 id="local-thread-机制-本地队列类似-gmp-中的-mp-模型">local-thread 机制: 本地队列(类似 GMP 中的 MP 模型)</h2> <ul> <li>修改方案： <ul> <li>n 个线程都有私有的本地线程队列，线程执行任务的时候就不需要加锁争抢，直接从本地任务队列中获取即可。</li> <li>本线程中产生的 Task 尽可能放在本线程的 Queue 中执行【Golang 的 GMP 也实现了这个】</li> </ul> </li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/PdXjbgEvRoobAlxC3o8c0KEonAb-480.webp 480w, /assets/img/feishu_docs_static/PdXjbgEvRoobAlxC3o8c0KEonAb-800.webp 800w, /assets/img/feishu_docs_static/PdXjbgEvRoobAlxC3o8c0KEonAb-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/PdXjbgEvRoobAlxC3o8c0KEonAb.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <h2 id="local-free-机制-无锁编程">local-free 机制: 无锁编程</h2> <ul> <li>无锁编程的实现方案 <ul> <li>基于 atomic 的原子操作 实现临界区的修改，本质上是在执行原子指令(比如 i++)的时候，变量内部维护了一个自旋锁（确保当前的线程不会被切换）和一个 CAS（一种乐观锁，确保写入的数值是正确的）</li> <li>基于内部封装的 mutex</li> <li>基于 CAS 机制 【Compare-And-Swap】</li> </ul> </li> </ul> <h2 id="work-stealing-机制-gmp-中的实现也存在这个方案">work-stealing 机制: GMP 中的实现也存在这个方案</h2> <ul> <li>当某个线程的本地执行队列为空的时候，从另一个线程的本地执行队列中 steal 一些任务</li> <li>一般来说都是按照 thread 的序号顺序，thread5 会按 thread6, thread7, thread0, … 这样的顺序来偷取</li> <li> <p>每个 thread 执行的任务顺序</p> <ul> <li>本地队列中的任务</li> <li>线程池 pool 中的任务</li> <li>从其他队列 steal 来的任务</li> </ul> </li> <li> <p>缺点和优化方案</p> <ul> <li>为了偷取一个任务，需要遍历所有的 thread 的本地队列来实现偷取，效率太低 =&gt; 只考虑从相邻的 3 个线程中偷取</li> </ul> </li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/CyHzbtO09o1wXKxy1aicy0bNn3t-480.webp 480w, /assets/img/feishu_docs_static/CyHzbtO09o1wXKxy1aicy0bNn3t-800.webp 800w, /assets/img/feishu_docs_static/CyHzbtO09o1wXKxy1aicy0bNn3t-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/CyHzbtO09o1wXKxy1aicy0bNn3t.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <h2 id="自动扩缩容机制-弹性伸缩-threadmachine机制">自动扩缩容机制: 弹性伸缩 thread(machine)机制</h2> <ul> <li>核心思想：在负载繁忙的时候，多增加一些 thread；当负载空闲的时候，就对 thread 进行自动回收</li> <li> <p>主线程（PrimaryThread）和辅助线程（SecondaryThread）和监控线程（MonitorThread）</p> <ul> <li>主线程恒定不变</li> <li>辅助线程可以根据负载繁忙情况来进行动态伸缩</li> <li>监控线程会每隔 TTL 时间，轮询检测所有的主线程是否都在 running 状态，如果是就是忙碌状态，需要增加一个新的辅助线程；否则则认为 Pool 处于空闲状态，会销毁当前的辅助线程。</li> </ul> </li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/MFfgbpcX7okVoixTuJjcRqlwnRg-480.webp 480w, /assets/img/feishu_docs_static/MFfgbpcX7okVoixTuJjcRqlwnRg-800.webp 800w, /assets/img/feishu_docs_static/MFfgbpcX7okVoixTuJjcRqlwnRg-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/MFfgbpcX7okVoixTuJjcRqlwnRg.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <ul> <li>注意事项 <ul> <li>线程不是越多越好的，因为线程的切换开销成本是比较大的</li> <li>一般计算密集型任务开辟和 cpu 核心数(n)相同的线程数来执行</li> <li>一般 I/O 密集型任务开辟 2n+1 个线程来执行</li> <li>最佳线程数量 = （（线程等待时间 + 线程 CPU 时间）/线程 CPU 时间 ）* CPU 数目</li> </ul> </li> </ul> <h2 id="批量处理机制-一次获取多个-task-执行">批量处理机制: 一次获取多个 Task 执行</h2> <ul> <li>主线程和辅助线程在从队列中获取/偷取任务的时候，整批整批地获取，减少争抢锁的次数，用于提高性能</li> <li> <p>注意事项</p> <ul> <li>这种机制会打乱 queue 中任务的执行顺序 =&gt; 解决方案：DAG 图调度的场景中，放入线程池中执行的任务，均是“互不依赖”的，有依赖的任务节点会等被依赖的节点执行完毕之后才会放入 Pool 中</li> </ul> </li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/K6YNbLCOSozy1WxMOWFcNkXznVg-480.webp 480w, /assets/img/feishu_docs_static/K6YNbLCOSozy1WxMOWFcNkXznVg-800.webp 800w, /assets/img/feishu_docs_static/K6YNbLCOSozy1WxMOWFcNkXznVg-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/K6YNbLCOSozy1WxMOWFcNkXznVg.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <h2 id="负载均衡机制">负载均衡机制</h2> <ul> <li>核心机制 <ul> <li>尽可能保证当前主线程产生的子 Task 会被放入到当前的队列中</li> <li>尽可能保证每个主线程队列中所有任务的总耗时基本一致</li> </ul> </li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/ClvEbX0xDopXHQxqit4ctXelnYd-480.webp 480w, /assets/img/feishu_docs_static/ClvEbX0xDopXHQxqit4ctXelnYd-800.webp 800w, /assets/img/feishu_docs_static/ClvEbX0xDopXHQxqit4ctXelnYd-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/ClvEbX0xDopXHQxqit4ctXelnYd.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <h2 id="避免忙等待避免阻塞等待-try_lockyield">避免忙等待(避免阻塞等待, try_lock+yield)</h2> <ul> <li> <p>这个核心思想在 Golang 和 Python 中均有体现</p> <ul> <li>yield 类似 return，在 Python 中可以基于此来实现一个生成器，调用 next()会从 yield 返回的位置开始执行。这里的 yield 类似 Golang 的 runtime.Gosched()</li> <li>try_lock 在 Golang 中也有实现，如果此时业务不能拿到锁，也不要让他阻塞等待着，而是利用 yield 来让出 CPU</li> </ul> </li> <li> <p>忙等待的方法主要运用在自旋锁场景中，可以用于 CAS 操作和 Atomic 操作中</p> <ul> <li>CAS 需要一致比较当前值和期望值是否一致</li> <li>Atomic 需要保证当前执行线程不退出</li> </ul> </li> </ul> <h2 id="分支预测优化少见">分支预测优化(少见)</h2> <h2 id="减少无用的-copystdmoveemplace">减少无用的 Copy(std::move+emplace)</h2> <ul> <li>std::move 用于直接转移对象的内容</li> <li> <p>指针的选型要避免 shared_ptr 和 unique_ptr 不断多次申请和来回赋值的问题</p> <ul> <li>禁止内部使用 shared_ptr【本质上就是引用计数管理内存，当指向某个实例的指针引用计数降低到 0，会自动释放动态分配的资源】【shared_ptr 内部存在 CAS 校验机制，占据内存也比较大】【shared_ptr 是线程安全的，引用计数是存在锁机制的！】【<strong>拷贝使得对象的引用计数增加 1</strong>，<strong>赋值使得原对象引用计数减 1，当计数为 0 时，自动释放内存</strong>。后来指向的对象引用计数加 1，指向后来的对象】</li> <li>采用 unique_ptr 来管理个别不定期申请和释放的资源【独享所有权的指针，不支持普通的拷贝和赋值操作，只能支持移动语义操作，如果转移一个 unique_ptr，会发生对象的所有权从源指针到目标指针的转移过程】</li> <li>weak_ptr【弱引用，避免循环引用的场景】：指向一个由 shared_ptr 管理的对象，只会引用但是不会计数，当一个对象同时被一个 shared_ptr 和一个 weak_ptr 引用，不管 weak_ptr 是否引用这个对象，shared_ptr 析构之后都会导致对象被释放</li> <li>auto_ptr【解决的是有异常抛出的时候发生内存泄漏的问题】：当抛出异常的时候，指针 p 指向的空间需要被合理回收。【auto_ptr 的构造函数是 explicit 函数，阻止指针的隐式转换，不能将一般的指针类型赋值给 auto_ptr，必须要用 auto_ptr 的构造函数来创建对象。被 explicit 修饰的构造函数的类，不能发生相应的隐式类型转换】【auto_ptr 析构函数中删除对象是用 delete，而不是 delete[]，不能用于管理数组】</li> </ul> </li> </ul> <h2 id="执行超时机制">执行超时机制</h2> <ul> <li>需要限制单个线程的执行时间，做一个时间限定，如果超过了限定时间就进行阻塞并返回错误信息。</li> </ul> <h2 id="任务组utaskgroup">任务组（UTaskGroup）</h2> <ul> <li>一批任务完成之后再执行其他的任务</li> <li>给同一批任务设定统一的等待时长</li> <li>在多批任务执行结束的时候，固定执行某个回调逻辑</li> </ul> <h2 id="优先级和阻塞执行">优先级和阻塞执行</h2> <ul> <li>用于给任务设置优先级</li> </ul>]]></content><author><name></name></author><category term="开源项目源码"/><category term="系统-高性能计算"/><summary type="html"><![CDATA[CGraph源码导读与线程池优化研读]]></summary></entry></feed>