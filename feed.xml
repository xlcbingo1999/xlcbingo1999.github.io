<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="cn"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://xlcbingo1999.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://xlcbingo1999.github.io/" rel="alternate" type="text/html" hreflang="cn"/><updated>2024-01-09T03:30:35+00:00</updated><id>https://xlcbingo1999.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">高性能任务级运行时平台 - Legion软件生态</title><link href="https://xlcbingo1999.github.io/blog/2024/Legion-Stack-Intro/" rel="alternate" type="text/html" title="高性能任务级运行时平台 - Legion软件生态"/><published>2024-01-06T00:00:00+00:00</published><updated>2024-01-06T00:00:00+00:00</updated><id>https://xlcbingo1999.github.io/blog/2024/Legion-Stack-Intro</id><content type="html" xml:base="https://xlcbingo1999.github.io/blog/2024/Legion-Stack-Intro/"><![CDATA[<p>Redirecting to Introduction of Legion Software Stack.</p>]]></content><author><name></name></author><category term="Slide"/><category term="系统类笔记"/><summary type="html"><![CDATA[Introduction of Legion Software Stack]]></summary></entry><entry><title type="html">CMake和Makefile相关学习</title><link href="https://xlcbingo1999.github.io/blog/2023/CMake-learning/" rel="alternate" type="text/html" title="CMake和Makefile相关学习"/><published>2023-12-27T17:39:00+00:00</published><updated>2023-12-27T17:39:00+00:00</updated><id>https://xlcbingo1999.github.io/blog/2023/CMake-learning</id><content type="html" xml:base="https://xlcbingo1999.github.io/blog/2023/CMake-learning/"><![CDATA[<h2 id="cmake">CMake</h2> <h3 id="cmake-通常的-build-和编译位置">CMake 通常的 build 和编译位置</h3> <ul> <li>参考文献：<a href="https://blog.csdn.net/shaoyou223/article/details/84764633">https://blog.csdn.net/shaoyou223/article/details/84764633</a></li> </ul> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 方案1: 创建</span>
<span class="nb">mkdir </span>build
<span class="nb">cd </span>build
cmake ..
make
</code></pre></div></div> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 方案2: 直接在主目录下进行</span>
cmake <span class="nt">-S</span> <span class="nb">.</span> <span class="nt">-B</span> build
cmake <span class="nt">--build</span>
</code></pre></div></div> <h3 id="ubuntu-安装-cmake">Ubuntu 安装 CMake</h3> <ul> <li>参考文献：<a href="https://askubuntu.com/questions/355565/how-do-i-install-the-latest-version-of-cmake-from-the-command-line">https://askubuntu.com/questions/355565/how-do-i-install-the-latest-version-of-cmake-from-the-command-line</a></li> <li>需要安装新版的 CMake 的时候就需要用这个文章里提到的方法</li> </ul> <h3 id="cmakelists-的编写规则">CMakelists 的编写规则</h3> <ul> <li>号称是全网最全的规则：<a href="https://zhuanlan.zhihu.com/p/534439206">https://zhuanlan.zhihu.com/p/534439206</a></li> </ul> <h3 id="fetchcontent-依赖库">FetchContent 依赖库</h3> <ul> <li>参考文献：<a href="https://juejin.cn/post/7102762548423819272">https://juejin.cn/post/7102762548423819272</a></li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp"># FetchContent 模块用于获取外部依赖库, 在构建生成文件的过程中被调用
</span><span class="n">include</span><span class="p">(</span><span class="n">FetchContent</span><span class="p">)</span>
<span class="cp"># FetchContent_Declare 描述如何下载依赖库
</span><span class="n">FetchContent_Declare</span><span class="p">(</span>
    <span class="n">pybind11</span>
    <span class="n">GIT_REPOSITORY</span> <span class="n">https</span><span class="o">:</span><span class="c1">//github.com/pybind/pybind11.git</span>
    <span class="n">GIT_TAG</span>        <span class="n">v2</span><span class="mf">.6.2</span>
    <span class="n">GIT_SHALLOW</span>    <span class="n">TRUE</span>
<span class="p">)</span>
<span class="cp"># FetchContent_MakeAvaliable 下载依赖库, 并使其可用
</span><span class="n">FetchContent_MakeAvailable</span><span class="p">(</span><span class="n">pybind11</span><span class="p">)</span>
</code></pre></div></div> <h3 id="cmake-的多版本共存">CMake 的多版本共存</h3> <ul> <li>请不要直接删除 cmake，可能会导致一些文件被删除</li> <li>多版本共存 CMake 参考文献：<a href="https://zhuanlan.zhihu.com/p/442561052">https://zhuanlan.zhihu.com/p/442561052</a></li> </ul> <h3 id="cmakepresets-简化-cmake-项目初始化繁杂步骤">CMakePresets: 简化 CMake 项目初始化繁杂步骤</h3> <ul> <li>参考文献：<a href="https://cloud.tencent.com/developer/article/2348379">https://cloud.tencent.com/developer/article/2348379</a></li> <li> <p>针对不同平台的 CMake 指令主流配置方案</p> <ul> <li>缺点：命令非常长，配置可能不同开发机器上都不一样，对工程在不同设备上编译带来很大的挑战，非常容易编译出错。而且在版本迭代过程中，工程的配置是不断在更新的，很容易忘记去修改 README 或者项目文档导致一些历史的编译脚本缺少一些关键指令丢失内容，这不符合 GitOps 思想。</li> </ul> </li> </ul> <table> <thead> <tr> <th>参数</th> <th>Win</th> <th>Linux</th> <th>macOS</th> <th>iOS</th> <th>Android</th> <th> </th> </tr> </thead> <tbody> <tr> <td>-G [用于指定生成器（Generator），即指定生成的项目文件（例如 Makefile、Visual Studio 项目文件等）的类型]</td> <td>Visual Studio</td> <td>Unix Makefiles</td> <td>Xcode</td> <td>Xcode</td> <td> </td> <td> </td> </tr> <tr> <td>-A [ 用于指定目标平台的体系结构（Architecture）]</td> <td>Win32/x64</td> <td> </td> <td> </td> <td> </td> <td> </td> <td> </td> </tr> <tr> <td>-DCMAKE_OSX_ARCHITECTURES [用于定义 CMake 变量]</td> <td> </td> <td> </td> <td> </td> <td> </td> <td> </td> <td> </td> </tr> <tr> <td>-DTOOLSETS</td> <td> </td> <td> </td> <td> </td> <td> </td> <td> </td> <td> </td> </tr> <tr> <td>-DCMAKE_SYSTEM_NAME</td> <td> </td> <td> </td> <td> </td> <td> </td> <td> </td> <td> </td> </tr> <tr> <td> </td> <td> </td> <td> </td> <td> </td> <td> </td> <td> </td> <td> </td> </tr> </tbody> </table> <ul> <li> <p>CMakePreset 的动机</p> <ul> <li>虽然不同的 IDE 或代码编辑器工具有提供一些自己的 CMake 初始化配置能力（如 Visual Studio Code 可通过 .vscode/settings.json 来配置一些默认值）但这都不是通用方案。每个人使用的开发工具都各要求。特别是开源项目，如果没有提供一套全平台对各类工具都支持的配置文件，这会让开发者在工程配置上就被劝退。所以我们期望对项目工程化改造的目标不仅仅是解决上面的痛苦问题，更期望能让开发人员在接手项目时不需要在编译工具链、工程配置上花费太多的心思，让主流的开发工具打开工程开箱即用。</li> <li>为了实现这个目标，CMake 从 3.19 版本就开始支持了 CMakePresets.json 配置。如果你的版本还低于 3.19 请尽快升级来体验下 C/C++ 生态工具链的魅力。</li> </ul> </li> <li> <p>CMakePreset 的几个阶段</p> <ul> <li>configure</li> <li>build</li> <li>test 【可选】</li> <li>package 【可选】</li> </ul> </li> <li> <p>常用的指令</p> <ul> <li><code class="language-plaintext highlighter-rouge">cmake --list-presets</code> ： 查看当前支持的配置</li> <li><code class="language-plaintext highlighter-rouge">cmake --preset=ios-release-arm64</code>：configure</li> <li><code class="language-plaintext highlighter-rouge">cmake --build --preset=ios-release-arm64</code>：build 阶段</li> </ul> </li> <li> <p>一个完整的 Preset 的例子</p> </li> </ul> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">{</span>
  <span class="s2">"version"</span>: 3,
  <span class="s2">"cmakeMinimumRequired"</span>: <span class="o">{</span>
    <span class="s2">"major"</span>: 3,
    <span class="s2">"minor"</span>: 19,
    <span class="s2">"patch"</span>: 0
  <span class="o">}</span>,
  <span class="s2">"configurePresets"</span>: <span class="o">[</span> <span class="c"># configure阶段的配置</span>
    <span class="o">{</span>
      <span class="s2">"name"</span>: <span class="s2">"macos"</span>,
      <span class="s2">"hidden"</span>: <span class="nb">true</span>,
      <span class="s2">"condition"</span>: <span class="o">{</span>
        <span class="s2">"type"</span>: <span class="s2">"equals"</span>,
        <span class="s2">"lhs"</span>: <span class="s2">"</span><span class="k">${</span><span class="nv">hostSystemName</span><span class="k">}</span><span class="s2">"</span>,
        <span class="s2">"rhs"</span>: <span class="s2">"Darwin"</span>
      <span class="o">}</span>,
      <span class="s2">"generator"</span>: <span class="s2">"Xcode"</span>,
      <span class="s2">"warnings"</span>: <span class="o">{</span><span class="s2">"dev"</span>: <span class="nb">true</span>, <span class="s2">"deprecated"</span>: <span class="nb">true</span><span class="o">}</span>,
      <span class="s2">"cacheVariables"</span>: <span class="o">{</span>
        <span class="s2">"BUILD_TESTING"</span>: <span class="s2">"OFF"</span>
      <span class="o">}</span>
    <span class="o">}</span>,
    <span class="o">{</span>
      <span class="s2">"name"</span>: <span class="s2">"darwin-debug"</span>,
      <span class="s2">"inherits"</span>: <span class="s2">"macos"</span>,
      <span class="s2">"displayName"</span>: <span class="s2">"Darwin 10.14+ (Debug)"</span>,
      <span class="s2">"description"</span>: <span class="s2">"NetEase MSS C wrapper for macOS - Debug Configuration"</span>,
      <span class="s2">"binaryDir"</span>: <span class="s2">"</span><span class="k">${</span><span class="nv">sourceDir</span><span class="k">}</span><span class="s2">/build"</span>,
      <span class="s2">"cacheVariables"</span>: <span class="o">{</span>
        <span class="s2">"BUILD_TESTING"</span>: <span class="s2">"ON"</span>,
        <span class="s2">"CMAKE_BUILD_TYPE"</span>: <span class="s2">"Debug"</span>,
        <span class="s2">"CMAKE_INSTALL_PREFIX"</span>: <span class="s2">"</span><span class="k">${</span><span class="nv">sourceDir</span><span class="k">}</span><span class="s2">/darwin-debug"</span>
      <span class="o">}</span>
    <span class="o">}</span>,
    <span class="o">{</span>
      <span class="s2">"name"</span>: <span class="s2">"darwin-release-arm64"</span>,
      <span class="s2">"inherits"</span>: <span class="s2">"macos"</span>,
      <span class="s2">"displayName"</span>: <span class="s2">"Darwin arm64 10.14+ (Release)"</span>,
      <span class="s2">"description"</span>: <span class="s2">"NetEase MSS C wrapper for macOS arm64 - Release Configuration"</span>,
      <span class="s2">"binaryDir"</span>: <span class="s2">"</span><span class="k">${</span><span class="nv">sourceDir</span><span class="k">}</span><span class="s2">/build-darwin-arm64-realese"</span>,
      <span class="s2">"cacheVariables"</span>: <span class="o">{</span>
        <span class="s2">"CMAKE_BUILD_TYPE"</span>: <span class="s2">"Release"</span>,
        <span class="s2">"CMAKE_OSX_ARCHITECTURES"</span>: <span class="s2">"arm64"</span>,
        <span class="s2">"CONAN_PROFILE_BUILD"</span>: <span class="s2">"</span><span class="k">${</span><span class="nv">sourceDir</span><span class="k">}</span><span class="s2">/.profiles/darwin-x86_64"</span>,
        <span class="s2">"CONAN_PROFILE_HOST"</span>: <span class="s2">"</span><span class="k">${</span><span class="nv">sourceDir</span><span class="k">}</span><span class="s2">/.profiles/darwin-arm64"</span>,
        <span class="s2">"CMAKE_INSTALL_PREFIX"</span>: <span class="s2">"</span><span class="k">${</span><span class="nv">sourceDir</span><span class="k">}</span><span class="s2">/darwin-release-arm64"</span>
      <span class="o">}</span>
    <span class="o">}</span>,
    <span class="o">{</span>
      <span class="s2">"name"</span>: <span class="s2">"darwin-release-x86_64"</span>,
      <span class="s2">"inherits"</span>: <span class="s2">"macos"</span>,
      <span class="s2">"displayName"</span>: <span class="s2">"Darwin x86_64 10.14+ (Release)"</span>,
      <span class="s2">"description"</span>: <span class="s2">"NetEase MSS C wrapper for macOS x86_64 - Release Configuration"</span>,
      <span class="s2">"binaryDir"</span>: <span class="s2">"</span><span class="k">${</span><span class="nv">sourceDir</span><span class="k">}</span><span class="s2">/build-darwin-x86_64-realese"</span>,
      <span class="s2">"cacheVariables"</span>: <span class="o">{</span>
        <span class="s2">"CMAKE_BUILD_TYPE"</span>: <span class="s2">"Release"</span>,
        <span class="s2">"CONAN_PROFILE_BUILD"</span>: <span class="s2">"</span><span class="k">${</span><span class="nv">sourceDir</span><span class="k">}</span><span class="s2">/.profiles/darwin-x86_64"</span>,
        <span class="s2">"CONAN_PROFILE_HOST"</span>: <span class="s2">"</span><span class="k">${</span><span class="nv">sourceDir</span><span class="k">}</span><span class="s2">/.profiles/darwin-x86_64"</span>,
        <span class="s2">"CMAKE_INSTALL_PREFIX"</span>: <span class="s2">"</span><span class="k">${</span><span class="nv">sourceDir</span><span class="k">}</span><span class="s2">/darwin-release-x86_64"</span>
      <span class="o">}</span>
    <span class="o">}</span>,
    <span class="o">{</span>
      <span class="s2">"name"</span>: <span class="s2">"ios-release-arm64"</span>,
      <span class="s2">"inherits"</span>: <span class="s2">"macos"</span>,
      <span class="s2">"displayName"</span>: <span class="s2">"iOS arm64 9.0+ (Release)"</span>,
      <span class="s2">"description"</span>: <span class="s2">"NetEase MSS C wrapper for iOS arm64 - Release Configuration"</span>,
      <span class="s2">"binaryDir"</span>: <span class="s2">"</span><span class="k">${</span><span class="nv">sourceDir</span><span class="k">}</span><span class="s2">/build-ios-arm64-release"</span>,
      <span class="s2">"cacheVariables"</span>: <span class="o">{</span>
        <span class="s2">"CMAKE_BUILD_TYPE"</span>: <span class="s2">"Release"</span>,
        <span class="s2">"CMAKE_SYSTEM_NAME"</span>: <span class="s2">"iOS"</span>,
        <span class="s2">"CMAKE_OSX_DEPLOYMENT_TARGET"</span>: <span class="s2">"9.0"</span>,
        <span class="s2">"CMAKE_OSX_ARCHITECTURES"</span>: <span class="s2">"arm64"</span>,
        <span class="s2">"CMAKE_OSX_SYSROOT"</span>: <span class="s2">"iphoneos"</span>,
        <span class="s2">"CONAN_PROFILE_BUILD"</span>: <span class="s2">"</span><span class="k">${</span><span class="nv">sourceDir</span><span class="k">}</span><span class="s2">/.profiles/darwin-x86_64"</span>,
        <span class="s2">"CONAN_PROFILE_HOST"</span>: <span class="s2">"</span><span class="k">${</span><span class="nv">sourceDir</span><span class="k">}</span><span class="s2">/.profiles/ios-arm64-iphoneos"</span>,
        <span class="s2">"CMAKE_INSTALL_PREFIX"</span>: <span class="s2">"</span><span class="k">${</span><span class="nv">sourceDir</span><span class="k">}</span><span class="s2">/ios-release-arm64"</span>
      <span class="o">}</span>
    <span class="o">}</span>,
    <span class="o">{</span>
      <span class="s2">"name"</span>: <span class="s2">"ios-release-armv7"</span>,
      <span class="s2">"inherits"</span>: <span class="s2">"macos"</span>,
      <span class="s2">"displayName"</span>: <span class="s2">"iOS armv7 9.0+ (Release)"</span>,
      <span class="s2">"description"</span>: <span class="s2">"NetEase MSS C wrapper for iOS armv7 - Release Configuration"</span>,
      <span class="s2">"binaryDir"</span>: <span class="s2">"</span><span class="k">${</span><span class="nv">sourceDir</span><span class="k">}</span><span class="s2">/build-ios-armv7-release"</span>,
      <span class="s2">"cacheVariables"</span>: <span class="o">{</span>
        <span class="s2">"CMAKE_BUILD_TYPE"</span>: <span class="s2">"Release"</span>,
        <span class="s2">"CMAKE_SYSTEM_NAME"</span>: <span class="s2">"iOS"</span>,
        <span class="s2">"CMAKE_OSX_DEPLOYMENT_TARGET"</span>: <span class="s2">"9.0"</span>,
        <span class="s2">"CMAKE_OSX_ARCHITECTURES"</span>: <span class="s2">"armv7"</span>,
        <span class="s2">"CMAKE_OSX_SYSROOT"</span>: <span class="s2">"iphoneos"</span>,
        <span class="s2">"CONAN_PROFILE_BUILD"</span>: <span class="s2">"</span><span class="k">${</span><span class="nv">sourceDir</span><span class="k">}</span><span class="s2">/.profiles/darwin-x86_64"</span>,
        <span class="s2">"CONAN_PROFILE_HOST"</span>: <span class="s2">"</span><span class="k">${</span><span class="nv">sourceDir</span><span class="k">}</span><span class="s2">/.profiles/ios-armv7-iphoneos"</span>,
        <span class="s2">"CMAKE_INSTALL_PREFIX"</span>: <span class="s2">"</span><span class="k">${</span><span class="nv">sourceDir</span><span class="k">}</span><span class="s2">/ios-release-armv7"</span>
      <span class="o">}</span>
    <span class="o">}</span>,
    <span class="o">{</span>
      <span class="s2">"name"</span>: <span class="s2">"ios-release-x86_64"</span>,
      <span class="s2">"inherits"</span>: <span class="s2">"macos"</span>,
      <span class="s2">"displayName"</span>: <span class="s2">"iOS x86_64 9.0+ (Release)"</span>,
      <span class="s2">"description"</span>: <span class="s2">"NetEase MSS C wrapper for iOS x86_64 - Release Configuration"</span>,
      <span class="s2">"binaryDir"</span>: <span class="s2">"</span><span class="k">${</span><span class="nv">sourceDir</span><span class="k">}</span><span class="s2">/build-ios-x86_64-release"</span>,
      <span class="s2">"cacheVariables"</span>: <span class="o">{</span>
        <span class="s2">"CMAKE_BUILD_TYPE"</span>: <span class="s2">"Release"</span>,
        <span class="s2">"CMAKE_SYSTEM_NAME"</span>: <span class="s2">"iOS"</span>,
        <span class="s2">"CMAKE_OSX_DEPLOYMENT_TARGET"</span>: <span class="s2">"9.0"</span>,
        <span class="s2">"CMAKE_OSX_ARCHITECTURES"</span>: <span class="s2">"x86_64"</span>,
        <span class="s2">"CMAKE_OSX_SYSROOT"</span>: <span class="s2">"iphonesimulator"</span>,
        <span class="s2">"CONAN_PROFILE_BUILD"</span>: <span class="s2">"</span><span class="k">${</span><span class="nv">sourceDir</span><span class="k">}</span><span class="s2">/.profiles/darwin-x86_64"</span>,
        <span class="s2">"CONAN_PROFILE_HOST"</span>: <span class="s2">"</span><span class="k">${</span><span class="nv">sourceDir</span><span class="k">}</span><span class="s2">/.profiles/ios-x86_64-iphonesimulator"</span>,
        <span class="s2">"CMAKE_INSTALL_PREFIX"</span>: <span class="s2">"</span><span class="k">${</span><span class="nv">sourceDir</span><span class="k">}</span><span class="s2">/ios-release-x86_64"</span>
      <span class="o">}</span>
    <span class="o">}</span>,
    <span class="o">{</span>
      <span class="s2">"name"</span>: <span class="s2">"macos-android"</span>,
      <span class="s2">"hidden"</span>: <span class="nb">true</span>,
      <span class="s2">"condition"</span>: <span class="o">{</span>
        <span class="s2">"type"</span>: <span class="s2">"equals"</span>,
        <span class="s2">"lhs"</span>: <span class="s2">"</span><span class="k">${</span><span class="nv">hostSystemName</span><span class="k">}</span><span class="s2">"</span>,
        <span class="s2">"rhs"</span>: <span class="s2">"Darwin"</span>
      <span class="o">}</span>,
      <span class="s2">"warnings"</span>: <span class="o">{</span><span class="s2">"dev"</span>: <span class="nb">true</span>, <span class="s2">"deprecated"</span>: <span class="nb">true</span><span class="o">}</span>,
      <span class="s2">"cacheVariables"</span>: <span class="o">{</span>
        <span class="s2">"BUILD_TESTING"</span>: <span class="s2">"OFF"</span>
      <span class="o">}</span>
    <span class="o">}</span>,
    <span class="o">{</span>
      <span class="s2">"name"</span>: <span class="s2">"android-release-x86_64"</span>,
      <span class="s2">"inherits"</span>: <span class="s2">"macos-android"</span>,
      <span class="s2">"displayName"</span>: <span class="s2">"Android x86_64 abi21 (Release)"</span>,
      <span class="s2">"description"</span>: <span class="s2">"NetEase MSS C wrapper for Android x86_64 - Release Configuration"</span>,
      <span class="s2">"binaryDir"</span>: <span class="s2">"</span><span class="k">${</span><span class="nv">sourceDir</span><span class="k">}</span><span class="s2">/build-android-x86_64-release"</span>,
      <span class="s2">"cacheVariables"</span>: <span class="o">{</span>
        <span class="s2">"CMAKE_BUILD_TYPE"</span>: <span class="s2">"Release"</span>,
        <span class="s2">"CMAKE_SYSTEM_NAME"</span>: <span class="s2">"Android"</span>,
        <span class="s2">"CMAKE_SYSTEM_VERSION"</span>: <span class="s2">"21"</span>,
        <span class="s2">"CMAKE_ANDROID_STL_TYPE"</span>: <span class="s2">"c++_static"</span>,
        <span class="s2">"CMAKE_ANDROID_ARCH_ABI"</span>: <span class="s2">"x86_64"</span>,
        <span class="s2">"CMAKE_ANDROID_NDK"</span>: <span class="s2">"</span><span class="nv">$env</span><span class="s2">{HOME}/Library/Android/sdk/ndk/21.4.7075529"</span>,
        <span class="s2">"CONAN_PROFILE_BUILD"</span>: <span class="s2">"</span><span class="k">${</span><span class="nv">sourceDir</span><span class="k">}</span><span class="s2">/.profiles/darwin-x86_64"</span>,
        <span class="s2">"CONAN_PROFILE_HOST"</span>: <span class="s2">"</span><span class="k">${</span><span class="nv">sourceDir</span><span class="k">}</span><span class="s2">/.profiles/android-x86_64-abi21"</span>,
        <span class="s2">"CMAKE_INSTALL_PREFIX"</span>: <span class="s2">"</span><span class="k">${</span><span class="nv">sourceDir</span><span class="k">}</span><span class="s2">/android-release-x86_64"</span>
      <span class="o">}</span>
    <span class="o">}</span>,
    <span class="o">{</span>
      <span class="s2">"name"</span>: <span class="s2">"android-release-x86"</span>,
      <span class="s2">"inherits"</span>: <span class="s2">"macos-android"</span>,
      <span class="s2">"displayName"</span>: <span class="s2">"Android x86 abi21 (Release)"</span>,
      <span class="s2">"description"</span>: <span class="s2">"NetEase MSS C wrapper for Android x86 - Release Configuration"</span>,
      <span class="s2">"binaryDir"</span>: <span class="s2">"</span><span class="k">${</span><span class="nv">sourceDir</span><span class="k">}</span><span class="s2">/build-android-x86-release"</span>,
      <span class="s2">"cacheVariables"</span>: <span class="o">{</span>
        <span class="s2">"CMAKE_BUILD_TYPE"</span>: <span class="s2">"Release"</span>,
        <span class="s2">"CMAKE_SYSTEM_NAME"</span>: <span class="s2">"Android"</span>,
        <span class="s2">"CMAKE_SYSTEM_VERSION"</span>: <span class="s2">"21"</span>,
        <span class="s2">"CMAKE_ANDROID_STL_TYPE"</span>: <span class="s2">"c++_static"</span>,
        <span class="s2">"CMAKE_ANDROID_ARCH_ABI"</span>: <span class="s2">"x86"</span>,
        <span class="s2">"CMAKE_ANDROID_NDK"</span>: <span class="s2">"</span><span class="nv">$env</span><span class="s2">{HOME}/Library/Android/sdk/ndk/21.4.7075529"</span>,
        <span class="s2">"CONAN_PROFILE_BUILD"</span>: <span class="s2">"</span><span class="k">${</span><span class="nv">sourceDir</span><span class="k">}</span><span class="s2">/.profiles/darwin-x86_64"</span>,
        <span class="s2">"CONAN_PROFILE_HOST"</span>: <span class="s2">"</span><span class="k">${</span><span class="nv">sourceDir</span><span class="k">}</span><span class="s2">/.profiles/android-x86-abi21"</span>,
        <span class="s2">"CMAKE_INSTALL_PREFIX"</span>: <span class="s2">"</span><span class="k">${</span><span class="nv">sourceDir</span><span class="k">}</span><span class="s2">/android-release-x86"</span>
      <span class="o">}</span>
    <span class="o">}</span>,
    <span class="o">{</span>
      <span class="s2">"name"</span>: <span class="s2">"android-release-armeabi-v7a"</span>,
      <span class="s2">"inherits"</span>: <span class="s2">"macos-android"</span>,
      <span class="s2">"displayName"</span>: <span class="s2">"Android armeabi-v7a abi21 (Release)"</span>,
      <span class="s2">"description"</span>: <span class="s2">"NetEase MSS C wrapper for Android armeabi-v7a - Release Configuration"</span>,
      <span class="s2">"binaryDir"</span>: <span class="s2">"</span><span class="k">${</span><span class="nv">sourceDir</span><span class="k">}</span><span class="s2">/build-android-armeabi-v7a-release"</span>,
      <span class="s2">"cacheVariables"</span>: <span class="o">{</span>
        <span class="s2">"CMAKE_BUILD_TYPE"</span>: <span class="s2">"Release"</span>,
        <span class="s2">"CMAKE_SYSTEM_NAME"</span>: <span class="s2">"Android"</span>,
        <span class="s2">"CMAKE_SYSTEM_VERSION"</span>: <span class="s2">"21"</span>,
        <span class="s2">"CMAKE_ANDROID_STL_TYPE"</span>: <span class="s2">"c++_static"</span>,
        <span class="s2">"CMAKE_ANDROID_ARCH_ABI"</span>: <span class="s2">"armeabi-v7a"</span>,
        <span class="s2">"CMAKE_ANDROID_NDK"</span>: <span class="s2">"</span><span class="nv">$env</span><span class="s2">{HOME}/Library/Android/sdk/ndk/21.4.7075529"</span>,
        <span class="s2">"CONAN_PROFILE_BUILD"</span>: <span class="s2">"</span><span class="k">${</span><span class="nv">sourceDir</span><span class="k">}</span><span class="s2">/.profiles/darwin-x86_64"</span>,
        <span class="s2">"CONAN_PROFILE_HOST"</span>: <span class="s2">"</span><span class="k">${</span><span class="nv">sourceDir</span><span class="k">}</span><span class="s2">/.profiles/android-armeabi-v7a-abi21"</span>,
        <span class="s2">"CMAKE_INSTALL_PREFIX"</span>: <span class="s2">"</span><span class="k">${</span><span class="nv">sourceDir</span><span class="k">}</span><span class="s2">/android-release-armeabi-v7a"</span>
      <span class="o">}</span>
    <span class="o">}</span>,
    <span class="o">{</span>
      <span class="s2">"name"</span>: <span class="s2">"android-release-arm64-v8a"</span>,
      <span class="s2">"inherits"</span>: <span class="s2">"macos-android"</span>,
      <span class="s2">"displayName"</span>: <span class="s2">"Android arm64-v8a abi21 (Release)"</span>,
      <span class="s2">"description"</span>: <span class="s2">"NetEase MSS C wrapper for Android arm64-v8a - Release Configuration"</span>,
      <span class="s2">"binaryDir"</span>: <span class="s2">"</span><span class="k">${</span><span class="nv">sourceDir</span><span class="k">}</span><span class="s2">/build-android-arm64-v8a-release"</span>,
      <span class="s2">"cacheVariables"</span>: <span class="o">{</span>
        <span class="s2">"CMAKE_BUILD_TYPE"</span>: <span class="s2">"Release"</span>,
        <span class="s2">"CMAKE_SYSTEM_NAME"</span>: <span class="s2">"Android"</span>,
        <span class="s2">"CMAKE_SYSTEM_VERSION"</span>: <span class="s2">"21"</span>,
        <span class="s2">"CMAKE_ANDROID_STL_TYPE"</span>: <span class="s2">"c++_static"</span>,
        <span class="s2">"CMAKE_ANDROID_ARCH_ABI"</span>: <span class="s2">"arm64-v8a"</span>,
        <span class="s2">"CMAKE_ANDROID_NDK"</span>: <span class="s2">"</span><span class="nv">$env</span><span class="s2">{HOME}/Library/Android/sdk/ndk/21.4.7075529"</span>,
        <span class="s2">"CONAN_PROFILE_BUILD"</span>: <span class="s2">"</span><span class="k">${</span><span class="nv">sourceDir</span><span class="k">}</span><span class="s2">/.profiles/darwin-x86_64"</span>,
        <span class="s2">"CONAN_PROFILE_HOST"</span>: <span class="s2">"</span><span class="k">${</span><span class="nv">sourceDir</span><span class="k">}</span><span class="s2">/.profiles/android-arm64-v8a-abi21"</span>,
        <span class="s2">"CMAKE_INSTALL_PREFIX"</span>: <span class="s2">"</span><span class="k">${</span><span class="nv">sourceDir</span><span class="k">}</span><span class="s2">/android-release-arm64-v8a"</span>
      <span class="o">}</span>
    <span class="o">}</span>,
    <span class="o">{</span>
      <span class="s2">"name"</span>: <span class="s2">"windows"</span>,
      <span class="s2">"hidden"</span>: <span class="nb">true</span>,
      <span class="s2">"condition"</span>: <span class="o">{</span>
        <span class="s2">"type"</span>: <span class="s2">"equals"</span>,
        <span class="s2">"lhs"</span>: <span class="s2">"</span><span class="k">${</span><span class="nv">hostSystemName</span><span class="k">}</span><span class="s2">"</span>,
        <span class="s2">"rhs"</span>: <span class="s2">"Windows"</span>
      <span class="o">}</span>,
      <span class="s2">"generator"</span>: <span class="s2">"Visual Studio 15 2017"</span>,
      <span class="s2">"warnings"</span>: <span class="o">{</span><span class="s2">"dev"</span>: <span class="nb">true</span>, <span class="s2">"deprecated"</span>: <span class="nb">true</span><span class="o">}</span>,
      <span class="s2">"cacheVariables"</span>: <span class="o">{</span>
        <span class="s2">"CMAKE_INSTALL_PREFIX"</span>: <span class="s2">"</span><span class="k">${</span><span class="nv">sourceDir</span><span class="k">}</span><span class="s2">/exports"</span>,
        <span class="s2">"BUILD_TESTING"</span>: <span class="s2">"OFF"</span>
      <span class="o">}</span>
    <span class="o">}</span>,
    <span class="o">{</span>
      <span class="s2">"name"</span>: <span class="s2">"windows-debug"</span>,
      <span class="s2">"inherits"</span>: <span class="s2">"windows"</span>,
      <span class="s2">"displayName"</span>: <span class="s2">"Windows x64 (Debug)"</span>,
      <span class="s2">"description"</span>: <span class="s2">"NetEase MSS C wrapper for Windows - Debug Configuration"</span>,
      <span class="s2">"binaryDir"</span>: <span class="s2">"</span><span class="k">${</span><span class="nv">sourceDir</span><span class="k">}</span><span class="s2">/build"</span>,
      <span class="s2">"architecture"</span>: <span class="o">{</span>
        <span class="s2">"value"</span>: <span class="s2">"x64"</span>,
        <span class="s2">"strategy"</span>: <span class="s2">"set"</span>
      <span class="o">}</span>,
      <span class="s2">"cacheVariables"</span>: <span class="o">{</span>
        <span class="s2">"CMAKE_BUILD_TYPE"</span>: <span class="s2">"Debug"</span>,
        <span class="s2">"CMAKE_DEBUG_POSTFIX"</span>: <span class="s2">"d"</span>
      <span class="o">}</span>
    <span class="o">}</span>,
    <span class="o">{</span>
      <span class="s2">"name"</span>: <span class="s2">"win32-release-x64"</span>,
      <span class="s2">"inherits"</span>: <span class="s2">"windows"</span>,
      <span class="s2">"displayName"</span>: <span class="s2">"Windows x64 (Release)"</span>,
      <span class="s2">"description"</span>: <span class="s2">"NetEase MSS C wrapper for Windows - Release Configuration"</span>,
      <span class="s2">"binaryDir"</span>: <span class="s2">"</span><span class="k">${</span><span class="nv">sourceDir</span><span class="k">}</span><span class="s2">/build-win32-x64"</span>,
      <span class="s2">"architecture"</span>: <span class="o">{</span>
        <span class="s2">"value"</span>: <span class="s2">"x64"</span>,
        <span class="s2">"strategy"</span>: <span class="s2">"set"</span>
      <span class="o">}</span>,
      <span class="s2">"cacheVariables"</span>: <span class="o">{</span>
        <span class="s2">"CMAKE_BUILD_TYPE"</span>: <span class="s2">"Release"</span>,
        <span class="s2">"CMAKE_INSTALL_PREFIX"</span>: <span class="s2">"</span><span class="k">${</span><span class="nv">sourceDir</span><span class="k">}</span><span class="s2">/win32-release-x64"</span>
      <span class="o">}</span>
    <span class="o">}</span>,
    <span class="o">{</span>
      <span class="s2">"name"</span>: <span class="s2">"win32-release-ia32"</span>,
      <span class="s2">"inherits"</span>: <span class="s2">"windows"</span>,
      <span class="s2">"displayName"</span>: <span class="s2">"Windows ia32 (Release)"</span>,
      <span class="s2">"description"</span>: <span class="s2">"NetEase MSS C wrapper for Windows - Release Configuration"</span>,
      <span class="s2">"binaryDir"</span>: <span class="s2">"</span><span class="k">${</span><span class="nv">sourceDir</span><span class="k">}</span><span class="s2">/build-win32-ia32"</span>,
      <span class="s2">"architecture"</span>: <span class="o">{</span>
        <span class="s2">"value"</span>: <span class="s2">"Win32"</span>,
        <span class="s2">"strategy"</span>: <span class="s2">"set"</span>
      <span class="o">}</span>,
      <span class="s2">"cacheVariables"</span>: <span class="o">{</span>
        <span class="s2">"CMAKE_BUILD_TYPE"</span>: <span class="s2">"Release"</span>,
        <span class="s2">"CMAKE_INSTALL_PREFIX"</span>: <span class="s2">"</span><span class="k">${</span><span class="nv">sourceDir</span><span class="k">}</span><span class="s2">/win32-release-ia32"</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">]</span>,
  <span class="s2">"buildPresets"</span>: <span class="o">[</span> <span class="c"># build阶段的配置</span>
    <span class="o">{</span>
      <span class="s2">"name"</span>: <span class="s2">"darwin-debug"</span>,
      <span class="s2">"configurePreset"</span>: <span class="s2">"darwin-debug"</span>, <span class="c"># 依赖的configure阶段</span>
      <span class="s2">"displayName"</span>: <span class="s2">"Darwin Local Compilation (Debug)"</span>,
      <span class="s2">"description"</span>: <span class="s2">"NetEase MSS C wrapper for macOS - Debug Configuration"</span>,
      <span class="s2">"configuration"</span>: <span class="s2">"Debug"</span>
    <span class="o">}</span>,
    <span class="o">{</span>
      <span class="s2">"name"</span>: <span class="s2">"darwin-release-x86_64"</span>,
      <span class="s2">"configurePreset"</span>: <span class="s2">"darwin-release-x86_64"</span>,
      <span class="s2">"displayName"</span>: <span class="s2">"Darwin x86_64 Local Compilation (Release)"</span>,
      <span class="s2">"description"</span>: <span class="s2">"NetEase MSS C wrapper for macOS x86_64 - Release Configuration"</span>,
      <span class="s2">"configuration"</span>: <span class="s2">"Release"</span>,
      <span class="s2">"targets"</span>: <span class="o">[</span><span class="s2">"install"</span><span class="o">]</span>
    <span class="o">}</span>,
    <span class="o">{</span>
      <span class="s2">"name"</span>: <span class="s2">"darwin-release-arm64"</span>,
      <span class="s2">"configurePreset"</span>: <span class="s2">"darwin-release-arm64"</span>,
      <span class="s2">"displayName"</span>: <span class="s2">"Darwin x86_64 Local Compilation (Release)"</span>,
      <span class="s2">"description"</span>: <span class="s2">"NetEase MSS C wrapper for macOS arm64 - Release Configuration"</span>,
      <span class="s2">"configuration"</span>: <span class="s2">"Release"</span>,
      <span class="s2">"targets"</span>: <span class="o">[</span><span class="s2">"install"</span><span class="o">]</span>
    <span class="o">}</span>,
    <span class="o">{</span>
      <span class="s2">"name"</span>: <span class="s2">"ios-release-arm64"</span>,
      <span class="s2">"configurePreset"</span>: <span class="s2">"ios-release-arm64"</span>,
      <span class="s2">"displayName"</span>: <span class="s2">"iOS arm64 Local Compilation (Release)"</span>,
      <span class="s2">"description"</span>: <span class="s2">"NetEase MSS C wrapper for iOS arm64 - Release Configuration"</span>,
      <span class="s2">"configuration"</span>: <span class="s2">"Release"</span>,
      <span class="s2">"targets"</span>: <span class="o">[</span><span class="s2">"install"</span><span class="o">]</span>
    <span class="o">}</span>,
    <span class="o">{</span>
      <span class="s2">"name"</span>: <span class="s2">"ios-release-armv7"</span>,
      <span class="s2">"configurePreset"</span>: <span class="s2">"ios-release-armv7"</span>,
      <span class="s2">"displayName"</span>: <span class="s2">"iOS armv7 Local Compilation (Release)"</span>,
      <span class="s2">"description"</span>: <span class="s2">"NetEase MSS C wrapper for iOS armv7 - Release Configuration"</span>,
      <span class="s2">"configuration"</span>: <span class="s2">"Release"</span>,
      <span class="s2">"targets"</span>: <span class="o">[</span><span class="s2">"install"</span><span class="o">]</span>
    <span class="o">}</span>,
    <span class="o">{</span>
      <span class="s2">"name"</span>: <span class="s2">"ios-release-x86_64"</span>,
      <span class="s2">"configurePreset"</span>: <span class="s2">"ios-release-x86_64"</span>,
      <span class="s2">"displayName"</span>: <span class="s2">"iOS x86_64 Local Compilation (Release)"</span>,
      <span class="s2">"description"</span>: <span class="s2">"NetEase MSS C wrapper for iOS x86_64 - Release Configuration"</span>,
      <span class="s2">"configuration"</span>: <span class="s2">"Release"</span>,
      <span class="s2">"targets"</span>: <span class="o">[</span><span class="s2">"install"</span><span class="o">]</span>
    <span class="o">}</span>,
    <span class="o">{</span>
      <span class="s2">"name"</span>: <span class="s2">"android-release-x86_64"</span>,
      <span class="s2">"configurePreset"</span>: <span class="s2">"android-release-x86_64"</span>,
      <span class="s2">"displayName"</span>: <span class="s2">"Android x86_64 Local Compilation (Release)"</span>,
      <span class="s2">"description"</span>: <span class="s2">"NetEase MSS C wrapper for Android x86_64 - Release Configuration"</span>,
      <span class="s2">"configuration"</span>: <span class="s2">"Release"</span>,
      <span class="s2">"targets"</span>: <span class="o">[</span><span class="s2">"install"</span><span class="o">]</span>
    <span class="o">}</span>,
    <span class="o">{</span>
      <span class="s2">"name"</span>: <span class="s2">"android-release-x86_64-strip"</span>,
      <span class="s2">"configurePreset"</span>: <span class="s2">"android-release-x86_64"</span>,
      <span class="s2">"displayName"</span>: <span class="s2">"Android x86_64 Local Compilation (Release)"</span>,
      <span class="s2">"description"</span>: <span class="s2">"NetEase MSS C wrapper for Android x86_64 - Release Configuration"</span>,
      <span class="s2">"configuration"</span>: <span class="s2">"Release"</span>,
      <span class="s2">"targets"</span>: <span class="o">[</span><span class="s2">"install/strip"</span><span class="o">]</span>
    <span class="o">}</span>,
    <span class="o">{</span>
      <span class="s2">"name"</span>: <span class="s2">"android-release-x86"</span>,
      <span class="s2">"configurePreset"</span>: <span class="s2">"android-release-x86"</span>,
      <span class="s2">"displayName"</span>: <span class="s2">"Android x86 Local Compilation (Release)"</span>,
      <span class="s2">"description"</span>: <span class="s2">"NetEase MSS C wrapper for Android x86 - Release Configuration"</span>,
      <span class="s2">"configuration"</span>: <span class="s2">"Release"</span>,
      <span class="s2">"targets"</span>: <span class="o">[</span><span class="s2">"install"</span><span class="o">]</span>
    <span class="o">}</span>,
    <span class="o">{</span>
      <span class="s2">"name"</span>: <span class="s2">"android-release-x86-strip"</span>,
      <span class="s2">"configurePreset"</span>: <span class="s2">"android-release-x86"</span>,
      <span class="s2">"displayName"</span>: <span class="s2">"Android x86 Local Compilation (Release)"</span>,
      <span class="s2">"description"</span>: <span class="s2">"NetEase MSS C wrapper for Android x86 - Release Configuration"</span>,
      <span class="s2">"configuration"</span>: <span class="s2">"Release"</span>,
      <span class="s2">"targets"</span>: <span class="o">[</span><span class="s2">"install/strip"</span><span class="o">]</span>
    <span class="o">}</span>,
    <span class="o">{</span>
      <span class="s2">"name"</span>: <span class="s2">"android-release-armeabi-v7a"</span>,
      <span class="s2">"configurePreset"</span>: <span class="s2">"android-release-armeabi-v7a"</span>,
      <span class="s2">"displayName"</span>: <span class="s2">"Android armeabi-v7a Local Compilation (Release)"</span>,
      <span class="s2">"description"</span>: <span class="s2">"NetEase MSS C wrapper for Android armeabi-v7a - Release Configuration"</span>,
      <span class="s2">"configuration"</span>: <span class="s2">"Release"</span>,
      <span class="s2">"targets"</span>: <span class="o">[</span><span class="s2">"install"</span><span class="o">]</span>
    <span class="o">}</span>,
    <span class="o">{</span>
      <span class="s2">"name"</span>: <span class="s2">"android-release-armeabi-v7a-strip"</span>,
      <span class="s2">"configurePreset"</span>: <span class="s2">"android-release-armeabi-v7a"</span>,
      <span class="s2">"displayName"</span>: <span class="s2">"Android armeabi-v7a Local Compilation (Release)"</span>,
      <span class="s2">"description"</span>: <span class="s2">"NetEase MSS C wrapper for Android armeabi-v7a - Release Configuration"</span>,
      <span class="s2">"configuration"</span>: <span class="s2">"Release"</span>,
      <span class="s2">"targets"</span>: <span class="o">[</span><span class="s2">"install/strip"</span><span class="o">]</span>
    <span class="o">}</span>,
    <span class="o">{</span>
      <span class="s2">"name"</span>: <span class="s2">"android-release-arm64-v8a"</span>,
      <span class="s2">"configurePreset"</span>: <span class="s2">"android-release-arm64-v8a"</span>,
      <span class="s2">"displayName"</span>: <span class="s2">"Android arm64-v8a Local Compilation (Release)"</span>,
      <span class="s2">"description"</span>: <span class="s2">"NetEase MSS C wrapper for Android arm64-v8a - Release Configuration"</span>,
      <span class="s2">"configuration"</span>: <span class="s2">"Release"</span>,
      <span class="s2">"targets"</span>: <span class="o">[</span><span class="s2">"install"</span><span class="o">]</span>
    <span class="o">}</span>,
    <span class="o">{</span>
      <span class="s2">"name"</span>: <span class="s2">"windows-debug"</span>,
      <span class="s2">"configurePreset"</span>: <span class="s2">"windows-debug"</span>,
      <span class="s2">"displayName"</span>: <span class="s2">"Windows Local Compilation (Debug)"</span>,
      <span class="s2">"description"</span>: <span class="s2">"NetEase MSS C wrapper for Windows - Debug Configuration"</span>,
      <span class="s2">"configuration"</span>: <span class="s2">"Debug"</span>
    <span class="o">}</span>,
    <span class="o">{</span>
      <span class="s2">"name"</span>: <span class="s2">"win32-release-x64"</span>,
      <span class="s2">"configurePreset"</span>: <span class="s2">"win32-release-x64"</span>,
      <span class="s2">"displayName"</span>: <span class="s2">"Windows x64 Local Compilation (Release)"</span>,
      <span class="s2">"description"</span>: <span class="s2">"NetEase MSS C wrapper for Windows x64 - Release Configuration"</span>,
      <span class="s2">"configuration"</span>: <span class="s2">"Release"</span>,
      <span class="s2">"targets"</span>: <span class="o">[</span><span class="s2">"install"</span><span class="o">]</span>
    <span class="o">}</span>,
    <span class="o">{</span>
      <span class="s2">"name"</span>: <span class="s2">"win32-release-ia32"</span>,
      <span class="s2">"configurePreset"</span>: <span class="s2">"win32-release-ia32"</span>,
      <span class="s2">"displayName"</span>: <span class="s2">"Windows ia32 Local Compilation (Release)"</span>,
      <span class="s2">"description"</span>: <span class="s2">"NetEase MSS C wrapper for Windows ia32 - Release Configuration"</span>,
      <span class="s2">"configuration"</span>: <span class="s2">"Release"</span>,
      <span class="s2">"targets"</span>: <span class="o">[</span><span class="s2">"install"</span><span class="o">]</span>
    <span class="o">}</span>
  <span class="o">]</span>,
  <span class="s2">"testPresets"</span>: <span class="o">[</span> <span class="c"># test阶段的配置</span>
    <span class="o">{</span>
      <span class="s2">"name"</span>: <span class="s2">"darwin-debug"</span>,
      <span class="s2">"configurePreset"</span>: <span class="s2">"darwin-debug"</span>,
      <span class="s2">"output"</span>: <span class="o">{</span><span class="s2">"outputOnFailure"</span>: <span class="nb">true</span><span class="o">}</span>,
      <span class="s2">"execution"</span>: <span class="o">{</span><span class="s2">"noTestsAction"</span>: <span class="s2">"error"</span>, <span class="s2">"stopOnFailure"</span>: <span class="nb">true</span><span class="o">}</span>
    <span class="o">}</span>,
    <span class="o">{</span>
      <span class="s2">"name"</span>: <span class="s2">"darwin-release-arm64"</span>,
      <span class="s2">"configurePreset"</span>: <span class="s2">"darwin-release-arm64"</span>,
      <span class="s2">"output"</span>: <span class="o">{</span><span class="s2">"outputOnFailure"</span>: <span class="nb">true</span><span class="o">}</span>,
      <span class="s2">"execution"</span>: <span class="o">{</span><span class="s2">"noTestsAction"</span>: <span class="s2">"error"</span>, <span class="s2">"stopOnFailure"</span>: <span class="nb">true</span><span class="o">}</span>
    <span class="o">}</span>
  <span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div> <h3 id="cmake-的-generator-相关知识">CMake 的 Generator 相关知识</h3> <ul> <li>cmake 会通过 cmakelist.txt 文件，生成适用于不同项目类型的 makefile 文件，然后 makefile 文件被不同的编译器使用进行编译，考虑到 C/C++ 的开发环境之多，有非常多的种类的项目开发环境，但是 cmake 基本上都考虑到了，这里做一个小的汇总。 <ul> <li>Visual Studio 6: 生成 Visual Studio 6 工程文件。</li> <li>Visual Studio 7: 生成 Visual Studio .NET 2002 工程文件。</li> <li>Visual Studio 10: 生成 Visual Studio 10(2010) 工程文件。</li> <li>Visual Studio 10 Win64 会生成 x64 平台的工程;Visual Studio 10 IA64 是 Itanium 平台。</li> <li>Visual Studio 11: 生成 Visual Studio 11(2012) 工程文件。</li> <li>Visual Studio 11 Win64 会生成 x64 平台的工程;Visual Studio 11 ARM 是 ARM 平台。</li> <li>Visual Studio 7 .NET 2003: 生成 Visual Studio 7 .NET 2003 工程文件。</li> <li>Visual Studio 8 2005: 生成 Visual Studio 8 2005 工程文件。</li> <li>Visual Studio 8 2005 Win64 会生成 x64 平台的工程。</li> <li>Visual Studio 9 2008: 生成 Visual Studio 9 2008 工程文件。</li> <li>Visual Studio 9 2008 Win64 会生成 x64 平台的工程;Visual Studio 9 2008 IA64 是 Itanium 平台。</li> <li>Borland Makefiles: 生成 Borland makefile。</li> <li>NMake Makefiles: 生成 NMake makefile。</li> <li>NMake Makefiles JOM: 生成 JOM makefile。</li> <li>Watcom WMake: 生成 Watcom WMake makefiles。</li> <li>MSYS Makefiles: 生成 MSYS makefile。 生成的 makefile 用 /bin/sh 作为它的 shell。在运行 CMake 的机器上需要安装 msys</li> <li>MinGW Makefiles: 生成供 mingw32-make 使用的 make file。 生成的 makefile 使用 cmd.exe 作为它的 shell。生成它们不需要 msys 或者 unix shell。</li> <li>Unix Makefiles: 生成标准的 UNIX makefile。 在构建树上生成分层的 UNIX makefile。任何标准的 UNIX 风格的 make 程序都可以通过默认的 make 目标构建工程。生成的 makefile 也提供了 install 目标。</li> <li>Ninja：生成.ninja 工程</li> <li>Xcode：生成 Xcode 工程</li> <li>CodeBlocks - MinGW Makefiles：生成 CodeBlocks 工程。</li> <li>在顶层目录以及每层子目录下为 CodeBlocks 生成工程文件，生成的 CMakeList.txt 的特点是都包含一个 PROJECT()调用。除此之外还会在构建树上生成一套层次性的 makefile。通过默认的 make 目标，正确的 make 程序可以构建这个工程。makefile 还提供了 install 目标。</li> <li>CodeBlocks - NMake Makefiles：生成 CodeBlocks 工程。 在顶层目录以及每层子目录下为 CodeBlocks 生成工程文件，生成的 CMakeList.txt 的特点是都包含一个 PROJECT()调用。除此之外还会在构建树上生成一套层次性的 makefile。通过默认的 make 目标，正确的 make 程序可以构建这个工程。makefile 还提供了 install 目标。</li> <li>CodeBlocks - Ninja：生成 CodeBlocks 工程。</li> <li>CodeBlocks - Unix Makefiles：生成 CodeBlocks 工程。 在顶层目录以及每层子目录下为 CodeBlocks 生成工程文件，生成的 CMakeList.txt 的特点是都包含一个 PROJECT()调用。除此之外还会在构建树上生成一套层次性的 makefile。通过默认的 make 目标，正确的 make 程序可以构建这个工程。makefile 还提供了 install 目标。</li> <li>Eclipse CDT4 - MinGW Makefiles: 生成 Eclipse CDT 4.0 工程文件。 在顶层目录下为 Eclipse 生成工程文件。在运行源码外构建时，一个连接到顶层源码路径的资源文件会被创建。除此之外还会在构建树上生成一套层次性的 makefile。通过默认的 make 目标，正确的 make 程序可以构建这个工程。makefile 还提供了 install 目标。</li> <li>Eclipse CDT4 - NMake Makefiles: 生成 Eclipse CDT 4.0 工程文件。 在顶层目录下为 Eclipse 生成工程文件。在运行源码外构建时，一个连接到顶层源码路径的资源文件会被创建。除此之外还会在构建树上生成一套层次性的 makefile。通过默认的 make 目标，正确的 make 程序可以构建这个工程。makefile 还提供了 install 目标。</li> <li>Eclipse CDT4 - NMake Makefiles：生成 Eclipse CDT 4.0 工程文件。</li> <li>Eclipse CDT4 - Ninja：生成 Eclipse CDT 4.0 工程文件。</li> <li>Eclipse CDT4 - Unix Makefiles: 生成 Eclipse CDT 4.0 工程文件。 在顶层目录下为 Eclipse 生成工程文件。在运行源码外构建时，一个连接到顶层源码路径的资源文件会被创建。除此之外还会在构建树上生成一套层次性的 makefile。通过默认的 make 目标，正确的 make 程序可以构建这个工程。makefile 还提供了 install 目标。</li> <li>KDevelop3: 生成 KDevelop 3 工程文件。</li> <li>KDevelop3 - Unix Makefiles: 生成 KDevelop 3 工程文件。</li> <li>Sublime Text 2 - MinGW Makefiles: 生成 Sublime Text 2 工程文件。</li> <li>Sublime Text 2 - NMake Makefiles: 生成 Sublime Text 2 工程文件。</li> <li>Sublime Text 2 - Ninja: 生成 Sublime Text 2 工程文件。</li> <li>Sublime Text 2 - Unix Makefiles: 生成 Sublime Text 2 工程文件。</li> </ul> </li> </ul> <h2 id="makefile">Makefile</h2>]]></content><author><name></name></author><category term="技术杂记"/><category term="技术杂记"/><summary type="html"><![CDATA[CMake和Makefile相关学习]]></summary></entry><entry><title type="html">Linchang Xiao’s CV</title><link href="https://xlcbingo1999.github.io/blog/2023/xiaolinchang-cv/" rel="alternate" type="text/html" title="Linchang Xiao’s CV"/><published>2023-12-26T17:39:00+00:00</published><updated>2023-12-26T17:39:00+00:00</updated><id>https://xlcbingo1999.github.io/blog/2023/xiaolinchang-cv</id><content type="html" xml:base="https://xlcbingo1999.github.io/blog/2023/xiaolinchang-cv/"><![CDATA[<p>Redirecting to Linchang Xiao’s CV.</p>]]></content><author><name></name></author><category term="CV"/><category term="个人信息"/><summary type="html"><![CDATA[Linchang Xiao's CV]]></summary></entry><entry><title type="html">体系结构相关技术</title><link href="https://xlcbingo1999.github.io/blog/2023/Arch/" rel="alternate" type="text/html" title="体系结构相关技术"/><published>2023-11-20T17:39:00+00:00</published><updated>2023-11-20T17:39:00+00:00</updated><id>https://xlcbingo1999.github.io/blog/2023/Arch</id><content type="html" xml:base="https://xlcbingo1999.github.io/blog/2023/Arch/"><![CDATA[<h2 id="服务器查看物理cpu和逻辑cpu的情况">服务器查看物理cpu和逻辑cpu的情况</h2> <ul> <li>参考文献：<a href="https://blog.csdn.net/maizousidemao/article/details/103595846">https://blog.csdn.net/maizousidemao/article/details/103595846</a></li> </ul> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cat /proc/cpuinfo| grep "physical id"| sort| uniq| wc -l

cat /proc/cpuinfo| grep "cpu cores"| uniq

cat /proc/cpuinfo| grep "processor"| wc -l

grep 'processor' /proc/cpuinfo | sort -u | wc -l
</code></pre></div></div>]]></content><author><name></name></author><category term="技术杂记"/><category term="技术杂记"/><summary type="html"><![CDATA[体系结构相关技术]]></summary></entry><entry><title type="html">博弈论</title><link href="https://xlcbingo1999.github.io/blog/2023/Game-Theory/" rel="alternate" type="text/html" title="博弈论"/><published>2023-08-10T17:39:00+00:00</published><updated>2023-08-10T17:39:00+00:00</updated><id>https://xlcbingo1999.github.io/blog/2023/Game-Theory</id><content type="html" xml:base="https://xlcbingo1999.github.io/blog/2023/Game-Theory/"><![CDATA[<h2 id="基础概念">基础概念</h2> <p>Game theory翻译过来就是博弈论，其实是研究多个玩家在互相交互中取胜的方法。例如在耶鲁大学的博弈论公开课中，有一个游戏是让全班同学从0到100中选一个数，其中如果选择的数最接近所有数的平均值的三分之一则这个玩家获胜。首先大家应该不会选择比33大的数，因为其他人都选择100也不能赢不了，那么如果大家都选择比33小，自己就应该选择比11小的数，考虑到其他人也是这样想的，那么自己应该选择比11小很多的数，如果我知道别人也知道自己选择比11小很多的数的话，那应该选择更小的数。那么这个游戏的理想值是0，也就是纳什均衡点，就是当对方也是深晦游戏规则并且知道你也很懂游戏规则时做出的最优决定，当然第一次游戏大家都不是完美的决策者（或者不知道对方是不是完美的决策者），因此不一定会选择纳什均衡点，但多次游戏后结果就是最终取胜的就是非常接近0的选择。</p> <h2 id="纳什均衡点">纳什均衡点</h2> <p>所有人已经选择了对自己而言的最优解并且自己单方面做其他选择也无法再提高的点。也就是说，如果玩家都是高手，能达到或者逼近纳什均衡的策略就是最优策略，如果对手不是高手不会选择最优策略，那么纳什均衡点不一定保证每局都赢，但长远来看极大概率会赢这样的新手。</p> <h2 id="combinatorial-game">Combinatorial Game</h2> <ul> <li>满足以下环境条件可以称为Combinatorial Game <ul> <li>Zero-sum</li> <li>Perfect information</li> <li>Deterministic</li> <li>Discrete</li> <li>Sequential</li> </ul> </li> </ul> <h2 id="minmax策略">Minmax策略</h2> <ul> <li>目标是找到逼近纳什均衡的搜索策略</li> <li>从树的叶子结点开始看，如果是本方回合就选择max的，如果是对方回合就是min的，实际上这也是假设对方是聪明的也会使用minmax算法，这样在博弈论里面就达到一个纳什均衡点。</li> </ul> <h2 id="蒙特卡洛树搜索">蒙特卡洛树搜索</h2> <ul> <li>论文：A Survey of Monte Carlo Tree Search Methods http://pubs.doc.ic.ac.uk/survey-mcts-methods/survey-mcts-methods.pdf</li> <li>可以参考的源码：MCTS的完整实现代码在 tobegit3hub/ml_implementation</li> <li>基于树结构，权衡探索和利用，在搜索空间巨大的时候仍有效的搜索算法。目标是找到逼近纳什均衡的搜索策略。</li> <li>探索和利用策略： <ul> <li>得分不仅是由这个子节点最终赢的概率来，而且与这个子节点玩的次数成负相关，也就是说这个子节点如果平均得分高就约有可能选中（因为认为它比其他节点更值得利用），同时如果子节点选中次数较多则下次不太会选中（因为其他节点选择次数少更值得探索），因此MCTS根据配置探索和利用不同的权重，可以实现比随机或者其他策略更有启发式的方法。</li> <li>UCT（Upper Confidence bounds for Trees）使用的UCB算法：\(argmax_{v' \in Child(v)} \frac{Q(v')}{N(v')} + c \sqrt{\frac{2 \ln{N(v)}}{N(v')}}\)，其中v’表示当前树节点，v表示父节点，Q表示这个树节点的累计quality值，N表示这个树节点的visit次数，C是一个常量参数（可以控制exploitation和exploration权重）。这个公式的意思时，对每一个节点求一个值用于后面的选择，这个值有两部分组成，左边是这个节点的平均收益值（越高表示这个节点期望收益好，越值得选择，用于exploitation），右边的变量是这个父节点的总访问次数除以子节点的访问次数（如果子节点访问次数越少则值越大，越值得选择，用户exploration），因此使用这个公式是可以兼顾探索和利用的。c常量我们可以使用\(1/\sqrt{2}\)，这是Kocsis、Szepesvari提出的经验值</li> </ul> </li> <li>必要假设 <ul> <li>（博弈论领域假设）Zero-sum：零和博弈，所有玩家的收益之和为0，一定能分出输赢。</li> <li>（博弈论领域假设）Perfect information / Fully information：对称信息（完全信息）。 游戏的所有信息和状态都是所有玩家可以观察到的，因此双方的游戏策略只需要关注共同的状态即可。不能像打牌一样隐藏自己的手牌</li> <li>（博弈论领域假设）Determinism：确定性策略，每一个操作都没有随机因素</li> <li>（博弈论领域假设）Sequential：顺序执行，所有的操作都是顺序执行的</li> <li>（博弈论领域假设）Discrete：离散动作，没有一个动作是连续值</li> <li>（优化领域假设）Black box optimization：黑盒优化，类似多臂老虎机，不能通过求导或者凸优化方法找到最优解，否则使用MCTS也是没有意义。【机器学习就是典型的优化过程，但我们用的机器学习算法如LR、SVM、DNN都不是黑盒，而是根据数学公式推导通过对函数求导等方式进行的优化。如果我们能把问题描述成一个函数或者凸优化问题，那么我们通过数学上的求导就可以找到最优解，这类问题并不需要用到MCTS等搜索算法，但实际上很多问题例如围棋就无法找到一个描述输赢的函数曲线，这样就无法通过纯数学的方法解决。】【这类问题统称为黑盒优化问题，我们不能假设知道这个场景内部的函数或者模型结构，只能通过给定模型输入得到模型输出结果来优化。例如多臂老虎机（Multi-arm Bandit）问题，我们有多台老虎机可以投币，但不知道每一台输赢的概率，只能通过多次投币来测试，根据观察的结果预估每台机器的收益分布，最终选择认为收益最大的，这种方法一般会比随机方法效果好。】【黑盒优化的算法也有很多，例如进化算法、贝叶斯优化、MCTS也算是，而这些算法都需要解决如何权衡探索和利用（Exploration and Exploitation）的问题。】</li> </ul> </li> <li>流程：通过不断的模拟得到大部分节点的UCB值，然后下次模拟的时候根据UCB值有策略得选择值得利用和值得探索的节点继续模拟，在搜索空间巨大并且计算能力有限的情况下，这种启发式搜索能更集中地、更大概率找到一些更好的节点。 <ul> <li>Selection：在树中找到一个最好的值得探索的节点，一般策略是先选择未被探索的子节点，如果都探索过就选择UCB值最大的子节点。</li> <li>Expansion：在前面选中的子节点中走一步创建一个新的子节点，一般策略是随机执行一个操作并且这个操作不能与前面的子节点重复。</li> <li>Simulation：在前面新Expansion出来的节点开始模拟游戏，直到到达游戏结束状态，这样可以收到到这个expansion出来的节点的得分是多少。</li> <li>Backpropagation：把前面expansion出来的节点得分反馈到前面所有父节点中，更新这些节点的quality value和visit times，方便后面计算UCB值。</li> <li>源代码：其中TREE_POLICY就是实现了Selection和和Expansion两个阶段，DEFAULT_POLICY实现了Simulation阶段，BACKUP实现了Backpropagation阶段。</li> </ul> </li> <li>AlphaGo算法对MCTS算法的优化 <ul> <li>利用policy network的输出替换UCB的父节点访问次数，同样使用子节点访问次数作为分母保证exploration</li> <li>Q值改为快速走子网络得到的所有叶子节点的均值，神经网络改成ResNet</li> <li>首先，AlphaGo每个节点可选action太多了，selection阶段不能像前面先遍历完所有子节点再expansion，这里是用改进的UCB算法来找到最优的需要expansion子节点，算法基本类似也是有控制exploration/exploitation的常量C并且与该子节点visit times成反比。</li> <li>其次，进行expansion时不会像前面这样直接random选择任意的action，而是这里也考虑到exploration/exploitation，一般前30步根据visit times成正比来选择，这样可以尽可能得先探索（根节点加入了狄利克雷分布保证所有点都经过），后面主要是根据visit times来走了。</li> <li>第三，新版AlphaGo Zero去掉了基于handcraft规则的rollout policy，也就是快速走子网络，以前是必须有快速走子直到完成比赛才能得到反馈，现在是直接基于神经网络计算预估的winer value概率值，然后平均得到每个子节点的state-action value也就是Q值。</li> <li>第四，AlphaGo在MCTS基础上收集最终的比赛结果作为label，MCTS作为policy evalution和policy iteration来实现增强学习。</li> </ul> </li> </ul> <h2 id="counterfactual-regret">Counterfactual Regret</h2> <ul> <li>适用于非信息对称游戏（Imperfect information / Partial information），目标是找到逼近纳什均衡的搜索策略</li> <li>德州扑克AI的常见算法</li> </ul>]]></content><author><name></name></author><category term="理论类笔记"/><category term="理论类笔记"/><summary type="html"><![CDATA[Game Theory]]></summary></entry><entry><title type="html">FFmpeg 相关技术</title><link href="https://xlcbingo1999.github.io/blog/2023/FFmpeg/" rel="alternate" type="text/html" title="FFmpeg 相关技术"/><published>2023-06-10T17:39:00+00:00</published><updated>2023-06-10T17:39:00+00:00</updated><id>https://xlcbingo1999.github.io/blog/2023/FFmpeg</id><content type="html" xml:base="https://xlcbingo1999.github.io/blog/2023/FFmpeg/"><![CDATA[<h2 id="ffmpeg-相关技术">FFmpeg 相关技术</h2> <ul> <li>要使用 ffmpeg 将视频分解为帧，并控制生成的帧数，您可以使用 -vf （Video Filter）选项来设置帧率。例如，如果要将一个 10 秒的视频分解为只包含 200 帧的图像序列，可以使用以下命令： <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ffmpeg -i input_video.mp4 -vf "fps=20" image-%03d.png
</code></pre></div> </div> </li> </ul> <p>这个命令的各个部分的含义如下：</p> <ul> <li>-i input_video.mp4: 这是输入文件的参数，input_video.mp4 应该替换为您要处理的视频文件的文件名。</li> <li>-vf “fps=20”: 这是视频过滤器选项，它告诉 ffmpeg 将帧率设置为 20 帧每秒（或者根据您的需求设置不同的帧率，以便得到所需数量的帧）。</li> <li>image-%03d.png: 这是输出图像文件的名称模板。%03d 表示帧序号，它将被替换为三位数字，例如 001、002、003，以便为生成的图像文件命名。 运行这个命令将把输入视频分解为指定帧率的图像序列，以满足您需要的帧数。在上面的示例中，帧率设置为 20 帧每秒，因此生成 10 秒视频的图像序列将包含 200 帧。</li> </ul>]]></content><author><name></name></author><category term="技术杂记"/><category term="技术杂记"/><summary type="html"><![CDATA[FFmpeg 相关技术]]></summary></entry><entry><title type="html">Online algorithm Efficient Optimization under Uncertainty</title><link href="https://xlcbingo1999.github.io/blog/2023/online-algorithms/" rel="alternate" type="text/html" title="Online algorithm Efficient Optimization under Uncertainty"/><published>2023-04-06T17:39:00+00:00</published><updated>2023-04-06T17:39:00+00:00</updated><id>https://xlcbingo1999.github.io/blog/2023/online-algorithms</id><content type="html" xml:base="https://xlcbingo1999.github.io/blog/2023/online-algorithms/"><![CDATA[<p>Redirecting to online algorithms.</p>]]></content><author><name></name></author><category term="Slide"/><category term="理论类笔记"/><summary type="html"><![CDATA[Introduction of Online algorithm]]></summary></entry><entry><title type="html">C++/Go算法学习</title><link href="https://xlcbingo1999.github.io/blog/2023/cpp-go-learning/" rel="alternate" type="text/html" title="C++/Go算法学习"/><published>2023-03-30T17:39:00+00:00</published><updated>2023-03-30T17:39:00+00:00</updated><id>https://xlcbingo1999.github.io/blog/2023/cpp-go-learning</id><content type="html" xml:base="https://xlcbingo1999.github.io/blog/2023/cpp-go-learning/"><![CDATA[<h2 id="c-基础">C++ 基础</h2> <h3 id="class-中的变量权限">class 中的变量权限</h3> <ul> <li>类的一个特征就是<strong>封装</strong>，public 和 private 作用就是实现这一目的。类的另一个特征就是<strong>继承</strong>，protected 的作用就是实现这一目的 <ul> <li>public：用户代码（类外）可以访问 public 成员而不能访问 private 成员</li> <li>protected：protected 成员可以被派生类对象访问，不能被用户代码（类外）访问</li> <li>private：private 成员只能由类成员（类内）和友元访问。</li> </ul> </li> </ul> <h3 id="inline">inline</h3> <h3 id="c-中的函数调用">C++ 中的函数调用</h3> <ul> <li>当程序执行函数调用指令时，CPU 将存储该函数调用后指令的内存地址，将函数的参数复制到堆栈上，最后将控制权转移到指定的函数。然后，CPU 执行函数代码，将函数返回值存储在预定义的内存位置/寄存器中，并将控制权返回给调用函数。</li> <li> <p>时间消耗分析</p> <ul> <li>调用者函数到被调用者的切换时间</li> <li>函数执行时间</li> </ul> </li> </ul> <h2 id="cmake">CMake</h2> <h3 id="cmake-通常的-build-和编译位置">CMake 通常的 build 和编译位置</h3> <ul> <li>参考文献：<a href="https://blog.csdn.net/shaoyou223/article/details/84764633">https://blog.csdn.net/shaoyou223/article/details/84764633</a></li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mkdir</span> <span class="n">build</span>
<span class="n">cd</span> <span class="n">build</span>
<span class="n">cmake</span> <span class="p">..</span>
<span class="n">make</span>
</code></pre></div></div> <h3 id="ubuntu-安装-cmake">Ubuntu 安装 CMake</h3> <ul> <li>参考文献：<a href="https://askubuntu.com/questions/355565/how-do-i-install-the-latest-version-of-cmake-from-the-command-line">https://askubuntu.com/questions/355565/how-do-i-install-the-latest-version-of-cmake-from-the-command-line</a></li> <li>需要安装新版的 CMake 的时候就需要用这个文章里提到的方法</li> </ul> <h3 id="cmakelists-的编写规则">CMakelists 的编写规则</h3> <ul> <li>号称是全网最全的规则：<a href="https://zhuanlan.zhihu.com/p/534439206">https://zhuanlan.zhihu.com/p/534439206</a></li> </ul> <h3 id="fetchcontent-依赖库">FetchContent 依赖库</h3> <ul> <li>参考文献：<a href="https://juejin.cn/post/7102762548423819272">https://juejin.cn/post/7102762548423819272</a></li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp"># FetchContent 模块用于获取外部依赖库, 在构建生成文件的过程中被调用
</span><span class="n">include</span><span class="p">(</span><span class="n">FetchContent</span><span class="p">)</span>
<span class="cp"># FetchContent_Declare 描述如何下载依赖库
</span><span class="n">FetchContent_Declare</span><span class="p">(</span>
    <span class="n">pybind11</span>
    <span class="n">GIT_REPOSITORY</span> <span class="n">https</span><span class="o">:</span><span class="c1">//github.com/pybind/pybind11.git</span>
    <span class="n">GIT_TAG</span>        <span class="n">v2</span><span class="mf">.6.2</span>
    <span class="n">GIT_SHALLOW</span>    <span class="n">TRUE</span>
<span class="p">)</span>
<span class="cp"># FetchContent_MakeAvaliable 下载依赖库, 并使其可用
</span><span class="n">FetchContent_MakeAvailable</span><span class="p">(</span><span class="n">pybind11</span><span class="p">)</span>
</code></pre></div></div> <h3 id="cmake-的多版本共存">CMake 的多版本共存</h3> <ul> <li>请不要直接删除 cmake，可能会导致一些文件被删除</li> <li>多版本共存 CMake 参考文献：<a href="https://zhuanlan.zhihu.com/p/442561052">https://zhuanlan.zhihu.com/p/442561052</a></li> </ul> <h2 id="makefile">Makefile</h2> <h2 id="pybind">Pybind</h2> <ul> <li>快速实现 C/C++ 和 Python 的互通 参考文献：<a href="https://www.jianshu.com/p/0b4b49dd706a">https://www.jianshu.com/p/0b4b49dd706a</a></li> <li>比较复杂的教程，可以实现使用 python 调用 C++ 写的有关 numpy 的算子【来自论文 ELSED: Enhanced Line SEgment Drawing】：<a href="https://www.guyuehome.com/38198">https://www.guyuehome.com/38198</a></li> </ul> <h2 id="c-虚函数表">C++ 虚函数表</h2> <ul> <li>参考文献：<a href="https://www.cnblogs.com/Mered1th/p/10924545.html">https://www.cnblogs.com/Mered1th/p/10924545.html</a></li> <li> <p>单继承</p> <ul> <li>虚表中派生类覆盖的虚函数的地址被放在了基类相应的函数原来的位置</li> <li>派生类没有覆盖的虚函数就延用基类的。同时，虚函数按照其声明顺序放于表中，父类的虚函数在子类的虚函数前面。</li> </ul> </li> <li> <p>多继承</p> <ul> <li>每个基类都有自己的虚函数表</li> <li>派生类的虚函数地址存依照声明顺序放在第一个基类的虚表最后</li> </ul> </li> </ul> <h2 id="字符串">字符串</h2> <h3 id="字符串截取下标段">字符串截取下标段</h3> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">string</span> <span class="k">month</span> <span class="o">=</span> <span class="n">time_s</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="n">string</span> <span class="k">day</span> <span class="o">=</span> <span class="n">time_s</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
</code></pre></div></div> <h3 id="stoi-和-to_string">stoi 和 to_string</h3> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">int</span> <span class="n">month_n</span> <span class="o">=</span> <span class="n">stoi</span><span class="p">(</span><span class="k">month</span><span class="p">);</span>
<span class="nb">int</span> <span class="n">day_n</span> <span class="o">=</span> <span class="n">stoi</span><span class="p">(</span><span class="k">day</span><span class="p">);</span>

<span class="n">string</span> <span class="k">month</span> <span class="o">=</span> <span class="n">to_string</span><span class="p">(</span><span class="n">month_n</span><span class="p">);</span>
</code></pre></div></div> <h2 id="数组相关问题">数组相关问题</h2> <h3 id="一维数组的排序">一维数组的排序</h3> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">int</span> <span class="n">time_arr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">arriveAlice_n</span><span class="p">,</span> <span class="n">leaveAlice_n</span><span class="p">,</span> <span class="n">arriveBob_n</span><span class="p">,</span> <span class="n">leaveBob_n</span><span class="p">};</span>
<span class="n">sort</span><span class="p">(</span><span class="n">time_arr</span><span class="p">,</span> <span class="n">time_arr</span><span class="o">+</span><span class="mi">4</span><span class="p">);</span>
</code></pre></div></div> <h3 id="前缀和刷题框架">前缀和刷题框架</h3> <ul> <li>一维前缀和</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">NumArray</span> <span class="p">{</span>
    <span class="c1">// 前缀和数组</span>
    <span class="k">private</span> <span class="kt">int</span><span class="p">[]</span> <span class="n">preSum</span><span class="p">;</span>

    <span class="cm">/* 输入一个数组，构造前缀和 */</span>
    <span class="k">public</span> <span class="n">NumArray</span><span class="p">(</span><span class="kt">int</span><span class="p">[]</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// preSum[0] = 0，便于计算累加和</span>
        <span class="c1">// 这里是多增加了一个item, 主要是避免条件判断</span>
        <span class="n">preSum</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">nums</span><span class="p">.</span><span class="n">length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
        <span class="c1">// 计算 nums 的累加和</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">preSum</span><span class="p">.</span><span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">preSum</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">preSum</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="cm">/* 查询闭区间 [left, right] 的累加和 */</span>
    <span class="c1">// 这个函数调用次数很多, 应该尽量避免条件判断和遍历</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="nf">sumRange</span><span class="p">(</span><span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span> 
        <span class="k">return</span> <span class="n">preSum</span><span class="p">[</span><span class="n">right</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">preSum</span><span class="p">[</span><span class="n">left</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <ul> <li>二维前缀和</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">NumMatrix</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">NumMatrix</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">matrix</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">new_vec</span> <span class="o">=</span> <span class="p">{};</span>
        <span class="k">this</span><span class="o">-&gt;</span><span class="n">presum</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">new_vec</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="o">-&gt;</span><span class="n">presum</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="p">}</span>
        
        
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">matrix</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">new_vec</span> <span class="o">=</span> <span class="p">{};</span>
            <span class="k">this</span><span class="o">-&gt;</span><span class="n">presum</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">new_vec</span><span class="p">);</span>
            <span class="k">this</span><span class="o">-&gt;</span><span class="n">presum</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// 很重要的计算方式</span>
                <span class="k">this</span><span class="o">-&gt;</span><span class="n">presum</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span>
                    <span class="k">this</span><span class="o">-&gt;</span><span class="n">presum</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">presum</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">presum</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="p">);</span>
                <span class="c1">// cout &lt;&lt; "presum[" &lt;&lt; i &lt;&lt; "][" &lt;&lt; j &lt;&lt; "]: " &lt;&lt; this-&gt;presum[i][j] &lt;&lt; endl;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="kt">int</span> <span class="nf">sumRegion</span><span class="p">(</span><span class="kt">int</span> <span class="n">row1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">col1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">row2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">col2</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// cout &lt;&lt; "this-&gt;presum[row2+1][col2+1]: " &lt;&lt; this-&gt;presum[row2+1][col2+1] &lt;&lt; "; this-&gt;presum[row2+1][col1+1]: " &lt;&lt; this-&gt;presum[row2+1][col1+1]</span>
        <span class="c1">//     &lt;&lt; "; this-&gt;presum[row1+1][col2+1]: " &lt;&lt; this-&gt;presum[row1+1][col2+1] &lt;&lt; "; this-&gt;presum[row1+1][col1+1]: " &lt;&lt; this-&gt;presum[row1+1][col1+1] &lt;&lt; endl; </span>
        <span class="c1">// 很重要的计算方式</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">presum</span><span class="p">[</span><span class="n">row2</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">col2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">presum</span><span class="p">[</span><span class="n">row2</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">col1</span><span class="p">]</span> <span class="o">-</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">presum</span><span class="p">[</span><span class="n">row1</span><span class="p">][</span><span class="n">col2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">presum</span><span class="p">[</span><span class="n">row1</span><span class="p">][</span><span class="n">col1</span><span class="p">];</span>
    <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">presum</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="前缀和-vector-实现1">前缀和-vector 实现（1）</h3> <ul> <li>这是一个常见的算法，可以在只遍历一次的情况下，计算多个区间的统计信息。</li> <li> <p>方案</p> <ul> <li>设置一个前缀和数组 arr，位置 i+1 存储的是第 0 个元素到第 i 个元素的求和（或者其他统计信息）</li> <li>最后计算方案：arr[r+1] - arr[l]</li> </ul> </li> <li>Leetcode 2559</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">bool</span> <span class="n">isYuan</span><span class="p">(</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">word</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">bool</span> <span class="n">result</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">last_index</span> <span class="o">=</span> <span class="n">word</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">word</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">'a'</span> <span class="o">&amp;&amp;</span> <span class="n">word</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">'e'</span> <span class="o">&amp;&amp;</span> <span class="n">word</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">'i'</span> <span class="o">&amp;&amp;</span> <span class="n">word</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">'o'</span> <span class="o">&amp;&amp;</span> <span class="n">word</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">'u'</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">result</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">word</span><span class="p">[</span><span class="n">last_index</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">'a'</span> <span class="o">&amp;&amp;</span> <span class="n">word</span><span class="p">[</span><span class="n">last_index</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">'e'</span> <span class="o">&amp;&amp;</span> <span class="n">word</span><span class="p">[</span><span class="n">last_index</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">'i'</span> <span class="o">&amp;&amp;</span> <span class="n">word</span><span class="p">[</span><span class="n">last_index</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">'o'</span> <span class="o">&amp;&amp;</span> <span class="n">word</span><span class="p">[</span><span class="n">last_index</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">'u'</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">result</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vowelStrings</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">words</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">queries</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">num_v</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
        <span class="kt">int</span> <span class="n">len_num_v</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">word</span><span class="o">:</span> <span class="n">words</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">isYuan</span><span class="p">(</span><span class="n">word</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">num_v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">num_v</span><span class="p">[</span><span class="n">len_num_v</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">num_v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">num_v</span><span class="p">[</span><span class="n">len_num_v</span><span class="o">-</span><span class="mi">1</span><span class="p">]);</span>
            <span class="p">}</span>
            <span class="n">len_num_v</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="p">{};</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">pair</span><span class="o">:</span> <span class="n">queries</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">num_v</span><span class="p">[</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">num_v</span><span class="p">[</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]]);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="前缀和-stack-实现2">前缀和-stack 实现（2）</h3> <ul> <li>leetcode：<a href="https://leetcode.cn/problems/remove-zero-sum-consecutive-nodes-from-linked-list/submissions/">https://leetcode.cn/problems/remove-zero-sum-consecutive-nodes-from-linked-list/submissions/</a></li> <li>方案：用 stack 可以实现一个在线维护更新的前缀和，可以通过 pop 操作将中间的一些情况给删除掉</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">struct</span> <span class="nc">ListNode</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
    <span class="n">ListNode</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
    <span class="n">ListNode</span><span class="p">()</span> <span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">next</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">ListNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">next</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">ListNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">ListNode</span> <span class="o">*</span><span class="n">next</span><span class="p">)</span> <span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">next</span><span class="p">(</span><span class="n">next</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>

    <span class="kt">void</span> <span class="n">print_list</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">result</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="nf">removeZeroSumSublists</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ListNode</span><span class="o">*</span> <span class="n">current_h</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="n">ListNode</span><span class="o">*</span> <span class="n">head_extend</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="o">-</span><span class="mi">999999</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>

        <span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">sum_front</span><span class="p">;</span>
        <span class="n">sum_front</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">ListNode</span><span class="o">*&gt;</span> <span class="n">sum_2_node</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">current_h</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"in current_h: "</span> <span class="o">&lt;&lt;</span> <span class="n">current_h</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">old_sum_front</span> <span class="o">=</span> <span class="n">sum_front</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
            <span class="kt">int</span> <span class="n">current_sum_front</span> <span class="o">=</span> <span class="n">old_sum_front</span> <span class="o">+</span> <span class="n">current_h</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
            <span class="n">ListNode</span><span class="o">*</span> <span class="n">same_sum_front_node</span> <span class="o">=</span> <span class="n">sum_2_node</span><span class="p">[</span><span class="n">current_sum_front</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">current_h</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">same_sum_front_node</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">same_sum_front_node</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">current_h</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="n">head_extend</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">current_h</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"current_sum_front: "</span> <span class="o">&lt;&lt;</span> <span class="n">current_sum_front</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
                
                <span class="k">if</span> <span class="p">(</span><span class="n">current_sum_front</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 全部删除</span>
                    <span class="n">head_extend</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">current_h</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
                    <span class="k">while</span> <span class="p">(</span><span class="n">sum_front</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                        <span class="kt">int</span> <span class="n">sum_f</span> <span class="o">=</span> <span class="n">sum_front</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
                        <span class="n">sum_2_node</span><span class="p">[</span><span class="n">sum_f</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
                        <span class="n">sum_front</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
                    <span class="p">}</span>
                <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">same_sum_front_node</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 已经存在</span>
                    <span class="n">same_sum_front_node</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">current_h</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
                    <span class="kt">int</span> <span class="n">sum_f</span> <span class="o">=</span> <span class="n">sum_front</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
                    <span class="k">while</span> <span class="p">(</span><span class="n">sum_f</span> <span class="o">!=</span> <span class="n">current_sum_front</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">sum_2_node</span><span class="p">[</span><span class="n">sum_f</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
                        <span class="n">sum_front</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
                        <span class="n">sum_f</span> <span class="o">=</span> <span class="n">sum_front</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
                    <span class="p">}</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">current_sum_front</span> <span class="o">&lt;&lt;</span> <span class="s">" push to sum_front"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
                    <span class="n">sum_front</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">current_sum_front</span><span class="p">);</span>
                    <span class="n">sum_2_node</span><span class="p">[</span><span class="n">current_sum_front</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_h</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="n">ListNode</span><span class="o">*</span> <span class="n">print_head_extend</span> <span class="o">=</span> <span class="n">head_extend</span><span class="p">;</span>
            <span class="k">this</span><span class="o">-&gt;</span><span class="n">print_list</span><span class="p">(</span><span class="n">print_head_extend</span><span class="p">);</span>

            <span class="n">current_h</span> <span class="o">=</span> <span class="n">current_h</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
 
        <span class="k">return</span> <span class="n">head_extend</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">);</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">);</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    
    <span class="n">Solution</span><span class="o">*</span> <span class="n">sol</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Solution</span><span class="p">();</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">result</span> <span class="o">=</span> <span class="n">sol</span><span class="o">-&gt;</span><span class="n">removeZeroSumSublists</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
    
    <span class="k">while</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="vector">vector</h2> <h3 id="二维-vector-排序算法">二维 vector 排序算法</h3> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vector&lt;vector&lt;int&gt;&gt; points;
sort(points.begin(), ppints.end(), [](const vector&lt;int&gt; &amp;a, const vector&lt;int&gt; &amp;b) {
    return a[0] &lt; b[0];
});
</code></pre></div></div> <h3 id="快速创建二维-vector-并初始化为-0">快速创建二维 vector 并初始化为 0</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">res</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">col</span><span class="p">));</span>
</code></pre></div></div> <h3 id="交换-i-和-j-的未知">交换 i 和 j 的未知</h3> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>std::swap(v[i], v[j]);
</code></pre></div></div> <h2 id="哈希表">哈希表</h2> <h3 id="哈希表迭代器">哈希表迭代器</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">select_it</span> <span class="o">=</span> <span class="n">select_map</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
<span class="k">while</span><span class="p">(</span><span class="n">select_it</span> <span class="o">!=</span> <span class="n">select_map</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// cout &lt;&lt; "pair select_it.key = " &lt;&lt; select_it-&gt;first &lt;&lt; " pair select_it.value = " &lt;&lt; select_it-&gt;second &lt;&lt; endl;</span>
    <span class="n">res</span><span class="p">[</span><span class="n">select_it</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">]</span> <span class="o">=</span> <span class="n">select_it</span><span class="o">-&gt;</span><span class="n">second</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="o">++</span><span class="n">select_it</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
</code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">//</span> <span class="n">for函数内进行迭代</span>
<span class="nf">for </span><span class="p">(</span><span class="n">auto</span> <span class="nb">iter</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">hashTable</span><span class="p">.</span><span class="nf">begin</span><span class="p">();</span> <span class="nb">iter</span> <span class="o">!=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">hashTable</span><span class="p">.</span><span class="nf">end</span><span class="p">();</span> <span class="o">++</span><span class="nb">iter</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">if </span><span class="p">(</span><span class="nb">iter</span><span class="o">-&gt;</span><span class="n">second</span> <span class="o">&gt;</span> <span class="n">max_result</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">max_result</span> <span class="o">=</span> <span class="nb">iter</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="哈希表复杂-key自定义-hashfunc-和-equalfunc">哈希表复杂 key——自定义 Hashfunc 和 Equalfunc</h3> <ul> <li>Hashfunc 结构体需要重写()操作，主要是对复杂的 key 利用 hasher 进行哈希，注意要指定 seed</li> <li>Equalfunc 结构体需要重写()操作，这个比较简单，确定两个 key 相同即可。</li> <li>创建：<code class="language-plaintext highlighter-rouge">unordered_map&lt;vector&lt;int&gt;, int, Hashfunc, Equalfunc&gt; hashTable</code></li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">Hashfunc</span> <span class="p">{</span>
    <span class="kt">size_t</span> <span class="k">operator</span><span class="p">()</span> <span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">hash</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">hasher</span><span class="p">;</span>
        <span class="kt">size_t</span> <span class="n">seed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">:</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">seed</span> <span class="o">^=</span> <span class="n">hasher</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="mh">0x9e3779b9</span> <span class="o">+</span> <span class="p">(</span><span class="n">seed</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">seed</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">seed</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">Equalfunc</span> <span class="p">{</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="p">()</span> <span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="n">b</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">Hashfunc</span><span class="p">,</span> <span class="n">Equalfunc</span><span class="o">&gt;</span> <span class="n">hashTable</span><span class="p">;</span>
</code></pre></div></div> <p>###</p> <h2 id="集合">集合</h2> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">neighs</span><span class="p">;</span>
<span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;::</span><span class="n">iterator</span> <span class="n">n_left_it</span> <span class="o">=</span> <span class="n">neighs</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">n_left_it</span> <span class="o">==</span> <span class="n">neighs</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">r</span> <span class="o">=</span> <span class="p">{</span><span class="n">right</span><span class="p">};</span>
    <span class="n">neighs</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span>
    <span class="c1">// cout &lt;&lt; "add left first" &lt;&lt; left &lt;&lt; " ";</span>
    <span class="c1">// print_vec(r);</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">n_left_it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">right</span><span class="p">);</span>
    <span class="c1">// cout &lt;&lt; "add left not first" &lt;&lt; left &lt;&lt; " ";</span>
    <span class="c1">// print_vec(r);</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="链表">链表</h2> <h3 id="核心思想-qia">核心思想 qia</h3> <ul> <li>链表是一种兼具递归和迭代性质的数据结构</li> <li> <p>递归的核心解法</p> <ul> <li>回溯算法：后序遍历的重要性</li> <li>例子：反转链表</li> </ul> </li> <li> <p>迭代的核心解法</p> <ul> <li>三指针法： pre、cur、next [始终一步一步地将 cur-&gt;next 设置为 pre，然后将 pre 设置为 cur，将 cur 设置为 next]</li> <li>例子：k 个一组翻转；判断回文链表</li> </ul> </li> </ul> <h3 id="反转链表">反转链表</h3> <ul> <li>Leetcode 92：<a href="https://leetcode.cn/problems/reverse-linked-list-ii/submissions/">https://leetcode.cn/problems/reverse-linked-list-ii/submissions/</a></li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">backtrack</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 模板: 反转前n个节点的链表!</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="o">-&gt;</span><span class="n">wait_next</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">head</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">ListNode</span><span class="o">*</span> <span class="n">back</span> <span class="o">=</span> <span class="n">backtrack</span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>

        <span class="c1">// cout &lt;&lt; "head: " &lt;&lt; head-&gt;val &lt;&lt; " ; back: " &lt;&lt; back-&gt;val &lt;&lt; endl;</span>
        <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">wait_next</span><span class="p">;</span> <span class="c1">// 之后会断掉, 目的是让第一个节点可以直接和最后相连</span>
        <span class="k">return</span> <span class="n">back</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="nf">reverseBetween</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">,</span> <span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ListNode</span><span class="o">*</span> <span class="n">dummy_head</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="o">-</span><span class="mi">100</span><span class="p">);</span> <span class="c1">// 技巧: 增加一个节点</span>
        <span class="n">dummy_head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="n">ListNode</span><span class="o">*</span> <span class="n">need_next</span> <span class="o">=</span> <span class="n">dummy_head</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">need_next</span> <span class="o">=</span> <span class="n">need_next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// cout &lt;&lt; "check need_next: " &lt;&lt; need_next-&gt;val &lt;&lt; endl;</span>
        

        <span class="n">ListNode</span><span class="o">*</span> <span class="n">new_head</span> <span class="o">=</span> <span class="n">backtrack</span><span class="p">(</span><span class="n">need_next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> 
        <span class="n">need_next</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">new_head</span><span class="p">;</span>

        
        <span class="k">return</span> <span class="n">dummy_head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">wait_next</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="k-个一组反转链表">k 个一组反转链表</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">reverse_a_b</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="n">ListNode</span><span class="o">*</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 迭代方案</span>
        <span class="n">ListNode</span><span class="o">*</span> <span class="n">pre</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
        <span class="n">ListNode</span><span class="o">*</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
        <span class="n">ListNode</span><span class="o">*</span> <span class="n">nex</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// [a, b)</span>
            <span class="n">nex</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">pre</span><span class="p">;</span>
            <span class="n">pre</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">nex</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">pre</span><span class="p">;</span> <span class="c1">// 将头返回</span>
    <span class="p">}</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="nf">reverseKGroup</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 递归方案</span>
        <span class="n">ListNode</span><span class="o">*</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">cur</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 不够就返回head</span>
                <span class="k">return</span> <span class="n">head</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        
        <span class="n">ListNode</span><span class="o">*</span> <span class="n">new_head</span> <span class="o">=</span> <span class="n">reverse_a_b</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">cur</span><span class="p">);</span>
        <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">reverseKGroup</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span> <span class="c1">// 很简洁的写法</span>
        <span class="k">return</span> <span class="n">new_head</span><span class="p">;</span>   
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <h2 id="二叉树">二叉树</h2> <h3 id="核心思想">核心思想</h3> <ul> <li>二叉树的前序遍历、中序遍历、后序遍历 其实本质上等同于 链表和数组的递归遍历思路</li> </ul> <div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">/</span><span class="o">*</span> <span class="err">迭代遍历数组</span> <span class="o">*</span><span class="p">/</span>
<span class="n">void</span> <span class="n">traverse</span><span class="p">(</span><span class="n">int</span><span class="p">[]</span> <span class="n">arr</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="nb">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

    <span class="p">}</span>
<span class="p">}</span>

<span class="p">/</span><span class="o">*</span> <span class="err">递归遍历数组</span> <span class="o">*</span><span class="p">/</span>
<span class="n">void</span> <span class="n">traverse</span><span class="p">(</span><span class="n">int</span><span class="p">[]</span> <span class="n">arr</span><span class="p">,</span> <span class="n">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">arr</span><span class="o">.</span><span class="nb">length</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="p">//</span> <span class="err">前序位置</span>
    <span class="n">traverse</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">//</span> <span class="err">后序位置</span>
<span class="p">}</span>

<span class="p">/</span><span class="o">*</span> <span class="err">迭代遍历单链表</span> <span class="o">*</span><span class="p">/</span>
<span class="n">void</span> <span class="n">traverse</span><span class="p">(</span><span class="n">ListNode</span> <span class="nb">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">ListNode</span> <span class="n">p</span> <span class="o">=</span> <span class="nb">head</span><span class="p">;</span> <span class="n">p</span> <span class="err">!</span><span class="o">=</span> <span class="nb">null</span><span class="p">;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>

    <span class="p">}</span>
<span class="p">}</span>

<span class="p">/</span><span class="o">*</span> <span class="err">递归遍历单链表</span> <span class="o">*</span><span class="p">/</span>
<span class="n">void</span> <span class="n">traverse</span><span class="p">(</span><span class="n">ListNode</span> <span class="nb">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">head</span> <span class="o">==</span> <span class="nb">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="p">//</span> <span class="err">前序位置</span>
    <span class="n">traverse</span><span class="p">(</span><span class="nb">head</span><span class="o">.</span><span class="n">next</span><span class="p">);</span>
    <span class="p">//</span> <span class="err">后序位置</span>
<span class="p">}</span>

<span class="p">/</span><span class="o">*</span> <span class="err">递归遍历二叉树</span> <span class="o">*</span><span class="p">/</span>
<span class="n">void</span> <span class="n">traverse</span><span class="p">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="p">//</span> <span class="err">前序位置</span>
    <span class="n">traverse</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">);</span>
    <span class="p">//</span> <span class="err">中序位置</span>
    <span class="n">traverse</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">);</span>
    <span class="p">//</span> <span class="err">后序位置</span>
<span class="p">}</span>
</code></pre></div></div> <ul> <li><strong>针对</strong><strong>链表</strong><strong>：</strong>所谓前序位置，就是刚进入一个节点（元素）的时候，后序位置就是即将离开一个节点（元素）的时候，那么进一步，你把代码写在不同位置，代码执行的时机也不同：</li> <li> <p><strong>针对二叉树：</strong>前中后序是遍历二叉树过程中处理每一个节点的三个特殊时间点，绝不仅仅是三个顺序不同的 List：【<strong>你可以发现每个节点都有「唯一」属于自己的前中后序位置</strong>，所以我说前中后序遍历是遍历二叉树过程中处理<strong>每一个节点</strong>的三个特殊时间点。】【二叉树的所有问题，就是让你在前中后序位置注入巧妙的代码逻辑，去达到自己的目的，你只需要单独思考每一个节点应该做什么，其他的不用你管，抛给二叉树遍历框架，递归会在所有节点上做相同的操作。】</p> <ul> <li><strong>前序位置</strong>的代码在刚刚进入一个二叉树节点的时候执行；【很多题都是在前序位置写代码，实际上是因为我们习惯把那些对前中后序位置不敏感的代码写在前序位置罢了。】【前序位置的代码只能从函数参数中获取父节点传递来的数据！】</li> <li><strong>中序位置</strong>的代码在一个二叉树节点左子树都遍历完，即将开始遍历右子树的时候执行。【中序位置主要用在 BST 场景中，你完全可以把 BST 的中序遍历认为是遍历有序数组。】</li> <li><strong>后序位置</strong>的代码在将要离开一个二叉树节点的时候执行；【主要的代码逻辑集中在后序位置：因为这个思路正确的核心在于，你确实可以通过子树的最大深度推导出原树的深度，所以当然要首先利用递归函数的定义算出左右子树的最大深度，然后推出原树的最大深度，主要逻辑自然放在后序位置。】【后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据。】【一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了。】</li> </ul> </li> </ul> <h3 id="递归解题思路">递归解题思路</h3> <ul> <li>二叉树题目的递归解法可以分两类思路，第一类是遍历一遍二叉树得出答案，第二类是通过分解问题（分解成子树）计算出答案，这两类思路分别对应着 <a href="https://labuladong.gitee.io/algo/di-ling-zh-bfe1b/hui-su-sua-c26da/">回溯算法核心框架</a> 和 <a href="https://labuladong.gitee.io/algo/di-ling-zh-bfe1b/dong-tai-g-1e688/">动态规划核心框架</a>。 <ul> <li>在 <a href="https://labuladong.gitee.io/algo/di-ling-zh-bfe1b/hui-su-sua-c26da/">回溯算法核心框架</a> 中给出的函数签名一般也是没有返回值的 <code class="language-plaintext highlighter-rouge">void backtrack(...)</code>【一般还会涉及到做选择和撤销选择】</li> <li>在 <a href="https://labuladong.gitee.io/algo/di-ling-zh-bfe1b/dong-tai-g-1e688/">动态规划核心框架</a> 中给出的函数签名是带有返回值的 <code class="language-plaintext highlighter-rouge">dp</code> 函数。</li> </ul> </li> </ul> <h3 id="动态规划--dfs--回溯算法">动态规划 / DFS / 回溯算法</h3> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/SuX8bPFrvojMzVx7HpXcbAg0nwf-480.webp 480w, /assets/img/feishu_docs_static/SuX8bPFrvojMzVx7HpXcbAg0nwf-800.webp 800w, /assets/img/feishu_docs_static/SuX8bPFrvojMzVx7HpXcbAg0nwf-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/SuX8bPFrvojMzVx7HpXcbAg0nwf.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <ul> <li>动态规划 <ul> <li> <p>分解问题的思路，关注点在 <strong>子树</strong>！</p> </li> <li> <p>例子：</p> <ul> <li>Leetcode 100：<a href="https://leetcode.cn/problems/same-tree/description/?show=1">https://leetcode.cn/problems/same-tree/description/?show=1</a> <ul> <li>前序遍历即可，注意参数需要传两个指针，这样可以一起进行遍历</li> </ul> </li> <li>Leetcode 101：<a href="https://leetcode.cn/problems/symmetric-tree/description/?show=1">https://leetcode.cn/problems/symmetric-tree/description/?show=1</a> <ul> <li>非常好的一道题目，还是 DP 的思想，让每个子树的两层满足部分情况即可!</li> <li>请多看题解：<a href="https://leetcode.cn/problems/symmetric-tree/solutions/46560/dong-hua-yan-shi-101-dui-cheng-er-cha-shu-by-user7/?show=1">https://leetcode.cn/problems/symmetric-tree/solutions/46560/dong-hua-yan-shi-101-dui-cheng-er-cha-shu-by-user7/?show=1</a></li> </ul> </li> <li>Leetcode 1008：<a href="https://leetcode.cn/problems/construct-binary-search-tree-from-preorder-traversal/submissions/?show=1">https://leetcode.cn/problems/construct-binary-search-tree-from-preorder-traversal/submissions/?show=1</a> <ul> <li>非常好的一道题目，从前序遍历的 vector 中恢复，因为本质上前序遍历就是找到一左一右，因此可以快速二分。二分后每次让子树去生成左右节点，因此这是一道 DP 的题目！</li> </ul> </li> </ul> </li> </ul> </li> <li>DFS <ul> <li>遍历的思路， 关注点在 <strong>节点</strong>！【似乎不关心走一条边多少次，关注的是节点访问的情况】</li> <li>做选择和撤销选择的逻辑都在 for 循环外面</li> </ul> </li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/HWtQbusLIoaAfoxD5lcchhyfnMc-480.webp 480w, /assets/img/feishu_docs_static/HWtQbusLIoaAfoxD5lcchhyfnMc-800.webp 800w, /assets/img/feishu_docs_static/HWtQbusLIoaAfoxD5lcchhyfnMc-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/HWtQbusLIoaAfoxD5lcchhyfnMc.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/WrM0bWjgSoHhQKx6I7Ic5usWnQf-480.webp 480w, /assets/img/feishu_docs_static/WrM0bWjgSoHhQKx6I7Ic5usWnQf-800.webp 800w, /assets/img/feishu_docs_static/WrM0bWjgSoHhQKx6I7Ic5usWnQf-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/WrM0bWjgSoHhQKx6I7Ic5usWnQf.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <ul> <li> <p>回溯算法</p> <ul> <li> <p>遍历的思路，关注点在 <strong>树枝</strong>！【一般来说，走过的路还要走回来，所以说关注点在树枝】</p> </li> <li> <p>做选择和撤销选择的逻辑都在 for 循环里面【因为需要拿到树枝的两个端点】</p> </li> </ul> </li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/TJJabIayQoWdnxxffXUcKbTKnrX-480.webp 480w, /assets/img/feishu_docs_static/TJJabIayQoWdnxxffXUcKbTKnrX-800.webp 800w, /assets/img/feishu_docs_static/TJJabIayQoWdnxxffXUcKbTKnrX-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/TJJabIayQoWdnxxffXUcKbTKnrX.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/B0EobRET3oolkDxjpoicCbfln5s-480.webp 480w, /assets/img/feishu_docs_static/B0EobRET3oolkDxjpoicCbfln5s-800.webp 800w, /assets/img/feishu_docs_static/B0EobRET3oolkDxjpoicCbfln5s-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/B0EobRET3oolkDxjpoicCbfln5s.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <h3 id="二叉树的深度-后序框架分解问题框架--其他---leetcode-543">二叉树的深度 后序框架[分解问题框架] + 其他 - Leetcode 543</h3> <div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
    <span class="n">int</span> <span class="n">transver</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="n">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        
        <span class="n">int</span> <span class="n">left_length</span> <span class="o">=</span> <span class="n">transver</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
        <span class="n">int</span> <span class="n">right_length</span> <span class="o">=</span> <span class="n">transver</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
        

        <span class="n">int</span> <span class="n">result_length</span> <span class="o">=</span> <span class="n">left_length</span> <span class="o">+</span> <span class="n">right_length</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">result_length</span> <span class="o">&gt;</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">max_length</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">this</span><span class="o">-&gt;</span><span class="n">max_length</span> <span class="o">=</span> <span class="n">result_length</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="n">left_length</span><span class="p">,</span> <span class="n">right_length</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">int</span> <span class="n">diameterOfBinaryTree</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">int</span> <span class="n">temp_result</span> <span class="o">=</span> <span class="n">transver</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">max_length</span><span class="p">;</span>
    <span class="p">}</span>
<span class="n">private</span><span class="p">:</span>
    <span class="n">int</span> <span class="n">max_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="完美二叉树的三叉树化可以用于对同层的不同子树进行连接">完美二叉树的三叉树化：可以用于对同层的不同子树进行连接</h3> <ul> <li>Leetcode 116 <ul> <li>参考文献：<a href="https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-66994/dong-ge-da-cbce8/">https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-66994/dong-ge-da-cbce8/</a></li> </ul> </li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 注意：cpp 代码由 chatGPT🤖 根据我的 java 代码翻译，旨在帮助不同背景的读者理解算法逻辑。</span>
<span class="c1">// 本代码不保证正确性，仅供参考。如有疑惑，可以参照我写的 java 代码对比查看。</span>

<span class="c1">// 主函数</span>
<span class="n">Node</span><span class="o">*</span> <span class="nf">connect</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="c1">// 遍历「三叉树」，连接相邻节点</span>
    <span class="n">traverse</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 三叉树遍历框架</span>
<span class="kt">void</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">node1</span><span class="p">,</span> <span class="n">Node</span><span class="o">*</span> <span class="n">node2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node1</span> <span class="o">==</span> <span class="nb">nullptr</span> <span class="o">||</span> <span class="n">node2</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="cm">/**** 前序位置 ****/</span>
    <span class="c1">// 将传入的两个节点穿起来</span>
    <span class="n">node1</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">node2</span><span class="p">;</span>
    
    <span class="c1">// 连接相同父节点的两个子节点</span>
    <span class="n">traverse</span><span class="p">(</span><span class="n">node1</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">node1</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
    <span class="n">traverse</span><span class="p">(</span><span class="n">node2</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">node2</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
    <span class="c1">// 连接跨越父节点的两个子节点</span>
    <span class="n">traverse</span><span class="p">(</span><span class="n">node1</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">node2</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="dfs">DFS</h3> <ul> <li>Leetcode 1457</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
Definition for a binary tree node.
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};
 */</span>

<span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">struct</span> <span class="nc">TreeNode</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">left</span><span class="p">;</span>
    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">right</span><span class="p">;</span>
    <span class="n">TreeNode</span><span class="p">()</span> <span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">left</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">),</span> <span class="n">right</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">TreeNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">left</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">),</span> <span class="n">right</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">TreeNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">TreeNode</span> <span class="o">*</span><span class="n">left</span><span class="p">,</span> <span class="n">TreeNode</span> <span class="o">*</span><span class="n">right</span><span class="p">)</span> <span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">left</span><span class="p">(</span><span class="n">left</span><span class="p">),</span> <span class="n">right</span><span class="p">(</span><span class="n">right</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">bool</span> <span class="n">checkHuiwen</span><span class="p">(</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">umap</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">bool</span> <span class="n">has_one_single</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">umap</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">iter</span> <span class="o">!=</span> <span class="n">umap</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">iter</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">second</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">has_one_single</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">has_one_single</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">second</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="n">has_one_single</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="nf">preTransver</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">result</span><span class="p">,</span> <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">umap</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"check root-&gt;val [add one]: "</span> <span class="o">&lt;&lt;</span>  <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="n">umap</span><span class="p">[</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">checkHuiwen</span><span class="p">(</span><span class="n">umap</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"is hui wen"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
                
                <span class="k">return</span> <span class="n">result</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"not is hui wen"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
                <span class="c1">// umap[root-&gt;val] -= 1;</span>
                <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">preTransver</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">umap</span><span class="p">);</span>
            <span class="n">umap</span><span class="p">[</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[sub one]: "</span> <span class="o">&lt;&lt;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">preTransver</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">umap</span><span class="p">);</span>
            <span class="n">umap</span><span class="p">[</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[sub one]: "</span> <span class="o">&lt;&lt;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
        
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>

    <span class="p">}</span>
    <span class="kt">int</span> <span class="nf">pseudoPalindromicPaths</span> <span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">umap</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">preTransver</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">umap</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
    <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

    <span class="n">Solution</span> <span class="o">*</span><span class="n">sol</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Solution</span><span class="p">();</span>

    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">sol</span><span class="o">-&gt;</span><span class="n">pseudoPalindromicPaths</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="bfs-可以用分层-next-链表去替代-queue">BFS (可以用分层 next 链表去替代 queue)</h3> <ul> <li>Leetcode 116/117：<a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/">填充每个节点的下一个右侧节点指针</a></li> <li>经典 BFS：严重依赖于 queue！</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Node</span><span class="o">*</span> <span class="nf">connect</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">queue</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">*&gt;</span> <span class="n">q</span><span class="p">;</span>
    <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">level</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">next_level</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">Node</span> <span class="o">*</span><span class="n">current_pointer</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
        <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">current_pointer</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">current_pointer</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">current_pointer</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
            <span class="n">next_level</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">current_pointer</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">current_pointer</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
            <span class="n">next_level</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"set current_pointer: "</span> <span class="o">&lt;&lt;</span> <span class="n">current_pointer</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="s">" to next: "</span> <span class="o">&lt;&lt;</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
            <span class="n">current_pointer</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
            <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>

            <span class="n">current_pointer</span> <span class="o">=</span> <span class="n">current_pointer</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">current_pointer</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">current_pointer</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
                <span class="n">next_level</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">current_pointer</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">current_pointer</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
                <span class="n">next_level</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"next_level: "</span> <span class="o">&lt;&lt;</span> <span class="n">next_level</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="n">level</span> <span class="o">=</span> <span class="n">next_level</span><span class="p">;</span>
        <span class="n">next_level</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <ul> <li>利用链表模拟</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Node</span><span class="o">*</span> <span class="nf">connect</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">Node</span> <span class="o">*</span><span class="n">cur</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Node</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">Node</span> <span class="o">*</span><span class="n">tail</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(;</span> <span class="n">cur</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// cout &lt;&lt; "set tail: " &lt;&lt; tail-&gt;val &lt;&lt; " next: " &lt;&lt; cur-&gt;left-&gt;val &lt;&lt; endl;</span>
                <span class="n">tail</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
                <span class="n">tail</span> <span class="o">=</span> <span class="n">tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// cout &lt;&lt; "set tail: " &lt;&lt; tail-&gt;val &lt;&lt; " next: " &lt;&lt; cur-&gt;right-&gt;val &lt;&lt; endl;</span>
                <span class="n">tail</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
                <span class="n">tail</span> <span class="o">=</span> <span class="n">tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="前序遍历-总是先判断根节点再处理子节点">前序遍历 (总是先判断根节点再处理子节点)</h3> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 前序遍历, 总是先走到最左端点再回来
int front_transve(TreeNode* root, int up, int down, int result) {
    if (root == nullptr) {
        return up - down;
    }
    
    up = max(up, root-&gt;val);
    down = min(down, root-&gt;val);
    

    int left_result = front_transve(root-&gt;left, up, down, result);
    int right_result = front_transve(root-&gt;right, up, down, result);
    result = max(max(left_result, right_result), up-down);

    return result;
}
</code></pre></div></div> <h3 id="后序遍历-总是先判断两个子节点再处理根节点">后序遍历 (总是先判断两个子节点再处理根节点)</h3> <ul> <li>一些二叉树搜索操作很常见</li> <li>题型：根据某些条件删除二叉树的部分节点、根据某些条件拆分二叉树、根据子节点的统计信息处理根节点</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 1110. 删点成林</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">backTransver</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="n">TreeNode</span><span class="o">*</span> <span class="n">parent</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">left</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;&amp;</span> <span class="n">result</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">to_delete</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">backTransver</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">to_delete</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">backTransver</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">to_delete</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">find</span><span class="p">(</span><span class="n">to_delete</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">to_delete</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="o">!=</span> <span class="n">to_delete</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">parent</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">parent</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="n">parent</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">delNodes</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">to_delete</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="p">{};</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">!=</span> <span class="nb">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">find</span><span class="p">(</span><span class="n">to_delete</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">to_delete</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="o">==</span> <span class="n">to_delete</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">backTransver</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">to_delete</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <h2 id="回溯算法">回溯算法</h2> <h3 id="选择-递归-撤销选择的思路">选择-递归-撤销选择的思路</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">def</span> <span class="n">backtrack</span><span class="p">(</span><span class="err">路径</span><span class="p">,</span> <span class="err">选择列表</span><span class="p">)</span><span class="o">:</span>
    <span class="k">if</span> <span class="err">满足结束条件</span><span class="o">:</span>
        <span class="n">result</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="err">路径</span><span class="p">)</span>
        <span class="k">return</span>
    
    <span class="k">for</span> <span class="err">选择</span> <span class="n">in</span> <span class="err">选择列表</span><span class="o">:</span>
        <span class="err">做选择</span>
        <span class="n">backtrack</span><span class="p">(</span><span class="err">路径</span><span class="p">,</span> <span class="err">选择列表</span><span class="p">)</span>
        <span class="err">撤销选择</span>
</code></pre></div></div> <h3 id="和-dfs-的区别">和 DFS 的区别</h3> <ul> <li>回溯算法：关心的是边，选择和撤销发生在 for 循环内部</li> <li>DFS：关心的节点，选择和撤销发生在 for 循环外部</li> </ul> <h3 id="回溯算法的分类">回溯算法的分类</h3> <h4 id="子集-元素没有重复元素不可以重复选">子集 [元素没有重复、元素不可以重复选]</h4> <ul> <li>剪枝法</li> </ul> <div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">void</span> <span class="n">backtrack</span><span class="p">(</span><span class="n">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">int</span> <span class="n">k</span><span class="p">,</span> <span class="n">int</span> <span class="nb">start</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="nb">path</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;&amp;</span> <span class="nb">result</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">//</span> <span class="err">每个</span><span class="nb">path</span><span class="err">都要被采用</span>
    <span class="nb">result</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="nb">path</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="nb">start</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">//</span> <span class="err">选择</span>
        <span class="nb">path</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        
        <span class="n">backtrack</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">path</span><span class="p">,</span> <span class="nb">result</span><span class="p">);</span>

        <span class="p">//</span> <span class="err">撤销选择</span>
        <span class="nb">path</span><span class="o">.</span><span class="n">pop_back</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="组合-元素没有重复元素不可以重复选">组合 [元素没有重复、元素不可以重复选]</h4> <ul> <li>剪枝法</li> </ul> <div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">void</span> <span class="n">backtrack</span><span class="p">(</span><span class="n">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">int</span> <span class="n">k</span><span class="p">,</span> <span class="n">int</span> <span class="nb">start</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="nb">path</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;&amp;</span> <span class="nb">result</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">path</span><span class="o">.</span><span class="nb">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">result</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="nb">path</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nb">path</span><span class="o">.</span><span class="nb">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="nb">start</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">//</span> <span class="err">选择</span>
        <span class="nb">path</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        
        <span class="n">backtrack</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">path</span><span class="p">,</span> <span class="nb">result</span><span class="p">);</span>

        <span class="p">//</span> <span class="err">撤销选择</span>
        <span class="nb">path</span><span class="o">.</span><span class="n">pop_back</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="排列-元素没有重复元素不可以重复选">排列 [元素没有重复、元素不可以重复选]</h4> <ul> <li>需要 flag 数组标记【注意，如果是类似 N 皇后那种只用两种状态无法表征的情况，则需要使用 int 类型的数组】</li> </ul> <div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">void</span> <span class="n">backtrack</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="n">bool</span><span class="o">*</span> <span class="n">used_flag</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="nb">path</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;&amp;</span> <span class="nb">result</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">path</span><span class="o">.</span><span class="nb">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">nums</span><span class="o">.</span><span class="nb">size</span><span class="p">())</span> <span class="p">{</span>
        <span class="nb">result</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="nb">path</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="nb">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">used_flag</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="p">//</span> <span class="err">做决定</span>
        <span class="nb">path</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">used_flag</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        
        <span class="n">backtrack</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">used_flag</span><span class="p">,</span> <span class="nb">path</span><span class="p">,</span> <span class="nb">result</span><span class="p">);</span>
        <span class="p">//</span> <span class="err">撤销决定</span>
        <span class="nb">path</span><span class="o">.</span><span class="n">pop_back</span><span class="p">();</span>
        <span class="n">used_flag</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="子集--组合-元素有重复元素不可以重复选">子集 / 组合 [元素有重复、元素不可以重复选]</h4> <ul> <li>for 循环的时候，遇到相同的就不走了！所以判断条件是那样子</li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/Oi3Ob0dmbo1xaAxAb6jc9YUlnMh-480.webp 480w, /assets/img/feishu_docs_static/Oi3Ob0dmbo1xaAxAb6jc9YUlnMh-800.webp 800w, /assets/img/feishu_docs_static/Oi3Ob0dmbo1xaAxAb6jc9YUlnMh-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/Oi3Ob0dmbo1xaAxAb6jc9YUlnMh.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
    <span class="n">void</span> <span class="n">backtrack</span><span class="p">(</span><span class="n">int</span> <span class="nb">start</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="nb">path</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;&amp;</span> <span class="nb">result</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">result</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="nb">path</span><span class="p">);</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="nb">start</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="nb">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="nb">start</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span> 
                <span class="p">//</span> <span class="err">不能是第一个，因为不能和</span><span class="nb">start</span><span class="o">-</span><span class="mi">1</span><span class="err">比较</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="nb">path</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            
            <span class="n">backtrack</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">nums</span><span class="p">,</span> <span class="nb">path</span><span class="p">,</span> <span class="nb">result</span><span class="p">);</span>

            <span class="nb">path</span><span class="o">.</span><span class="n">pop_back</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;</span> <span class="n">subsetsWithDup</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">sort</span><span class="p">(</span><span class="n">nums</span><span class="o">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">nums</span><span class="o">.</span><span class="k">end</span><span class="p">());</span>
        <span class="n">int</span> <span class="nb">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="nb">path</span> <span class="o">=</span> <span class="p">{};</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;</span> <span class="nb">result</span> <span class="o">=</span> <span class="p">{};</span>
        <span class="p">//</span> <span class="err">排序后正常剪枝?</span>
        <span class="n">backtrack</span><span class="p">(</span><span class="nb">start</span><span class="p">,</span> <span class="n">nums</span><span class="p">,</span> <span class="nb">path</span><span class="p">,</span> <span class="nb">result</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">result</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <h4 id="排列-元素有重复元素不可以重复选">排列 [元素有重复、元素不可以重复选]</h4> <ul> <li>将重复元素剔除掉，同时还要保证顺序不乱？ <ul> <li>顺序不乱的要求：前一个元素需要用过才会进入？</li> </ul> </li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/CE0Vb5BBvo7F23xg8A1ccbaonFd-480.webp 480w, /assets/img/feishu_docs_static/CE0Vb5BBvo7F23xg8A1ccbaonFd-800.webp 800w, /assets/img/feishu_docs_static/CE0Vb5BBvo7F23xg8A1ccbaonFd-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/CE0Vb5BBvo7F23xg8A1ccbaonFd.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
    <span class="n">void</span> <span class="n">backtrack</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;&amp;</span> <span class="nb">result</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="nb">path</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">bool</span><span class="o">&gt;&amp;</span> <span class="n">used_flag</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">path</span><span class="o">.</span><span class="nb">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">nums</span><span class="o">.</span><span class="nb">size</span><span class="p">())</span> <span class="p">{</span>
            <span class="nb">result</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="nb">path</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="nb">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="err">!</span><span class="n">used_flag</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">used_flag</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="p">//</span> <span class="n">jueding</span> 
            <span class="nb">path</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="n">used_flag</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            
            <span class="n">backtrack</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="nb">result</span><span class="p">,</span> <span class="nb">path</span><span class="p">,</span> <span class="n">used_flag</span><span class="p">);</span>
            <span class="p">//</span> <span class="n">chexiao</span> <span class="n">jueding</span>
            <span class="nb">path</span><span class="o">.</span><span class="n">pop_back</span><span class="p">();</span>
            <span class="n">used_flag</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;</span> <span class="n">permuteUnique</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">sort</span><span class="p">(</span><span class="n">nums</span><span class="o">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">nums</span><span class="o">.</span><span class="k">end</span><span class="p">());</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;</span> <span class="nb">result</span> <span class="o">=</span> <span class="p">{};</span> 
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="nb">path</span> <span class="o">=</span> <span class="p">{};</span> 
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">bool</span><span class="o">&gt;</span> <span class="n">used_flag</span> <span class="o">=</span> <span class="p">{};</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="nb">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">used_flag</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">backtrack</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="nb">result</span><span class="p">,</span> <span class="nb">path</span><span class="p">,</span> <span class="n">used_flag</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">result</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <h4 id="组合-元素没有重复元素可以被重复选">组合 [元素没有重复、元素可以被重复选]</h4> <ul> <li>进入递归的时候，传入 i 可以重复选这个项目！</li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/H3mpbbECgoiUDIxMEIscEJqDnIJ-480.webp 480w, /assets/img/feishu_docs_static/H3mpbbECgoiUDIxMEIscEJqDnIJ-800.webp 800w, /assets/img/feishu_docs_static/H3mpbbECgoiUDIxMEIscEJqDnIJ-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/H3mpbbECgoiUDIxMEIscEJqDnIJ.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
    <span class="n">void</span> <span class="n">backtrack</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">candidates</span><span class="p">,</span> <span class="n">int</span> <span class="n">target</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;&amp;</span> <span class="nb">result</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="nb">path</span><span class="p">,</span> <span class="n">int</span> <span class="n">path_sum</span><span class="p">,</span> <span class="n">int</span> <span class="nb">start</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">path_sum</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">path_sum</span> <span class="o">==</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
            <span class="nb">result</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="nb">path</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="nb">start</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">candidates</span><span class="o">.</span><span class="nb">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="nb">path</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">candidates</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="n">path_sum</span> <span class="o">+=</span> <span class="n">candidates</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

            <span class="n">backtrack</span><span class="p">(</span><span class="n">candidates</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="nb">result</span><span class="p">,</span> <span class="nb">path</span><span class="p">,</span> <span class="n">path_sum</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span> <span class="p">//</span> <span class="err">下次还从</span><span class="n">i</span><span class="err">的位置开始还能接着选</span>

            <span class="nb">path</span><span class="o">.</span><span class="n">pop_back</span><span class="p">();</span>
            <span class="n">path_sum</span> <span class="o">-=</span> <span class="n">candidates</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
        
    <span class="p">}</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;</span> <span class="n">combinationSum</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">candidates</span><span class="p">,</span> <span class="n">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">sort</span><span class="p">(</span><span class="n">candidates</span><span class="o">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">candidates</span><span class="o">.</span><span class="k">end</span><span class="p">(),</span> <span class="n">greater</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span><span class="p">());</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;</span> <span class="nb">result</span> <span class="o">=</span> <span class="p">{};</span> 
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="nb">path</span> <span class="o">=</span> <span class="p">{};</span> 
        <span class="n">int</span> <span class="n">path_sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">int</span> <span class="nb">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">backtrack</span><span class="p">(</span><span class="n">candidates</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="nb">result</span><span class="p">,</span> <span class="nb">path</span><span class="p">,</span> <span class="n">path_sum</span><span class="p">,</span> <span class="nb">start</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">result</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="例子-leetcode-51-n-皇后">例子: Leetcode 51 N 皇后</h3> <ul> <li>注意：状态可能 bool 状态无法完全表达，因为 2 元状态机可能撤销的时候会被覆盖！</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">transve</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;&amp;</span> <span class="n">result</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">path</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">flag</span><span class="p">,</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">new_line</span><span class="p">,</span> <span class="kt">int</span> <span class="n">row_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// cout &lt;&lt; "whta?" &lt;&lt; endl;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">row_id</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="n">row_id</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">// 选择</span>
            
            <span class="n">new_line</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'Q'</span><span class="p">;</span>
            <span class="c1">// cout &lt;&lt; "check new_line: " &lt;&lt; new_line &lt;&lt; endl;</span>
            <span class="n">path</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">new_line</span><span class="p">);</span>
            <span class="n">new_line</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'.'</span><span class="p">;</span>
            
            <span class="c1">// i列, (row_id++, i++)</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">row_id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">flag</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">row_id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">,</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">flag</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">row_id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">,</span> <span class="o">--</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">flag</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">transve</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">flag</span><span class="p">,</span> <span class="n">new_line</span><span class="p">,</span> <span class="n">row_id</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>

            <span class="c1">// 撤销选择</span>
            <span class="n">path</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">row_id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">flag</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">row_id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">,</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">flag</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">row_id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">,</span> <span class="o">--</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">flag</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">solveNQueens</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// cout &lt;&lt; "what?" &lt;&lt; endl;</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="p">{};</span> 
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">path</span> <span class="o">=</span> <span class="p">{};</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">flag</span> <span class="o">=</span> <span class="p">{};</span>
        <span class="kt">char</span> <span class="n">ch</span> <span class="o">=</span> <span class="sc">'.'</span><span class="p">;</span>
        <span class="n">string</span> <span class="nf">new_line</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">ch</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">line</span> <span class="o">=</span> <span class="p">{};</span>
            <span class="n">flag</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">line</span><span class="p">);</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">flag</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span> 
        <span class="kt">int</span> <span class="n">row_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        
        <span class="n">transve</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">flag</span><span class="p">,</span> <span class="n">new_line</span><span class="p">,</span> <span class="n">row_id</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="例子-leetcode-78-返回全排列组合">例子: Leetcode 78 返回全排列组合</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">backtrack</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">path</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">result</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">path</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

            <span class="n">backtrack</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// 剪枝树, 避免重复计算</span>

            <span class="n">path</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">subsets</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">path</span> <span class="o">=</span> <span class="p">{};</span> 
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="p">{};</span>
        <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="n">backtrack</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <h2 id="遍历-for">遍历 for</h2> <h3 id="auto-智能指针">auto 智能指针</h3> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for (const auto x: arr) {
    cout &lt;&lt; x &lt;&lt; endl;
}
</code></pre></div></div> <h2 id="tuple">Tuple</h2> <ul> <li>一个避免使用 struct 的简易数据结构，可以用 std::tuple 进行初始化，并用 std::tie 进行解包</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;tuple&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 感觉是一个不错的东西, 可以避免使用struct构造, 方便!</span>
    <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">t3</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="s">"3"</span><span class="p">};</span> <span class="c1">// 初始化</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">j</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">k</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">tie</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">=</span> <span class="n">t3</span><span class="p">;</span> <span class="c1">// 解包</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"i: "</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">"; j: "</span> <span class="o">&lt;&lt;</span> <span class="n">j</span> <span class="o">&lt;&lt;</span> <span class="s">"; k: "</span> <span class="o">&lt;&lt;</span> <span class="n">k</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="c-的-deque">C++ 的 deque</h2> <ul> <li>双端队列，使用两个双端队列可以用在滑动窗口中以非常低的成本来快速维护窗口中局部的 Max 和 Min</li> <li>方法：用一个 Max queue 保存最大值和比最大值小一些的量，直到窗口滑到一个比最大值还大的量，则抛弃之前的保存值；Min queue 也是同理。</li> <li><a href="https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/solution/gai-zhuang-ban-hua-dong-chuang-kou-liang-271k/">https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/solution/gai-zhuang-ban-hua-dong-chuang-kou-liang-271k/</a></li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">longestSubarray</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">limit</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">deque</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">min_heap</span><span class="p">;</span>
        <span class="n">deque</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">max_heap</span><span class="p">;</span>
        

        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">max_heap</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">max_heap</span><span class="p">.</span><span class="n">front</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">r</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">max_heap</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span> <span class="c1">// 只有当右边新来的item比维护的最大值大的时候, 需要删除所有内容</span>
            <span class="p">}</span>
            <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">min_heap</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">min_heap</span><span class="p">.</span><span class="n">front</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">r</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">min_heap</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span> <span class="c1">// 只有当右边新来的item比维护的最小值小的时候，需要删除所有内容</span>
            <span class="p">}</span>

            <span class="c1">// 两个deque合并在一起就是当前窗口的内容，其中最大值的位置会有两个值</span>

            <span class="n">max_heap</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">r</span><span class="p">]);</span>
            <span class="n">min_heap</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">r</span><span class="p">]);</span>

            <span class="n">r</span><span class="o">++</span><span class="p">;</span>
            
            <span class="k">while</span> <span class="p">(</span><span class="n">max_heap</span><span class="p">.</span><span class="n">front</span><span class="p">()</span> <span class="o">-</span> <span class="n">min_heap</span><span class="p">.</span><span class="n">front</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">limit</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 判断条件! 可以自定义</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">max_heap</span><span class="p">.</span><span class="n">front</span><span class="p">()</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">l</span><span class="p">])</span> <span class="p">{</span>
                    <span class="n">max_heap</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span>
                <span class="p">}</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">min_heap</span><span class="p">.</span><span class="n">front</span><span class="p">()</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">l</span><span class="p">])</span> <span class="p">{</span>
                    <span class="n">min_heap</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span>
                <span class="p">}</span>
                <span class="n">l</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">res</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">r</span><span class="o">-</span><span class="n">l</span><span class="p">);</span>
        <span class="p">}</span>
        
        <span class="c1">// cout &lt;&lt; "min_heap: " &lt;&lt; min_heap.top() &lt;&lt; endl;</span>
        <span class="c1">// cout &lt;&lt; "max_heap: " &lt;&lt; max_heap.top() &lt;&lt; endl;</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <h2 id="c11-整个专题">C++11 整个专题</h2> <h3 id="lambda">lambda</h3> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/RDU2bwI42oqB4yxeX0pcJgfCnJg-480.webp 480w, /assets/img/feishu_docs_static/RDU2bwI42oqB4yxeX0pcJgfCnJg-800.webp 800w, /assets/img/feishu_docs_static/RDU2bwI42oqB4yxeX0pcJgfCnJg-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/RDU2bwI42oqB4yxeX0pcJgfCnJg.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <ul> <li>这是一个比较大的坑，在 C++11 引入 lambda 函数，后续在 C++14 引入了泛型。</li> <li>function&lt; 返回值类型(参数类型)&gt; = <a href="%E5%8F%82%E6%95%B0">&amp;</a> -&gt; 返回值类型 {} <ol> <li>capture 子句（在 C++ 规范中也称为 Lambda 引导。）</li> <li>参数列表（可选）。 （也称为 Lambda 声明符）</li> <li>mutable 规范（可选）。</li> <li>exception-specification（可选）。</li> <li>trailing-return-type（可选）。</li> <li>Lambda 体。</li> </ol> </li> <li> <p>[] 中的内容表示不同的 capture 子句：Lambda 可在其主体中引入新的变量（用 C++14），它还可以访问（或“捕获”）周边范围内的变量。 Lambda 以 capture 子句开头。 它指定捕获哪些变量，以及捕获是通过值还是通过引用进行的。</p> <ul> <li>有与号 (<code class="language-plaintext highlighter-rouge">&amp;</code>) 前缀的变量通过引用进行访问，没有该前缀的变量通过值进行访问。</li> <li>空 capture 子句 <code class="language-plaintext highlighter-rouge">[ ]</code> 指示 lambda 表达式的主体不访问封闭范围中的变量。</li> <li>可以使用默认捕获模式来指示如何捕获 Lambda 体中引用的任何外部变量：<code class="language-plaintext highlighter-rouge">[&amp;]</code> 表示通过引用捕获引用的所有变量，而 <code class="language-plaintext highlighter-rouge">[=]</code> 表示通过值捕获它们。</li> <li>可以使用默认捕获模式，然后为特定变量显式指定相反的模式。 例如，如果 lambda 体通过引用访问外部变量 <code class="language-plaintext highlighter-rouge">total</code> 并通过值访问外部变量 <code class="language-plaintext highlighter-rouge">factor</code>，则以下 capture 子句等效：</li> </ul> </li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="o">&amp;</span><span class="n">total</span><span class="p">,</span> <span class="n">factor</span><span class="p">]</span>
<span class="p">[</span><span class="n">factor</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">total</span><span class="p">]</span>
<span class="p">[</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">factor</span><span class="p">]</span>
<span class="p">[</span><span class="o">=</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">total</span><span class="p">]</span>
</code></pre></div></div> <p>-</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">Node</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">time</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">*&gt;</span> <span class="n">childs</span><span class="p">;</span>

    <span class="n">Node</span><span class="p">(</span><span class="kt">int</span> <span class="n">time</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="o">-&gt;</span><span class="n">time</span> <span class="o">=</span> <span class="n">time</span><span class="p">;</span>
        <span class="k">this</span><span class="o">-&gt;</span><span class="n">childs</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">add_child</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">child</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// cout &lt;&lt; "add " &lt;&lt; child-&gt;id &lt;&lt; " into " &lt;&lt; this-&gt;id &lt;&lt; endl;</span>
        <span class="k">this</span><span class="o">-&gt;</span><span class="n">childs</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">numOfMinutes</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">headID</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">manager</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">informTime</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// build tree</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">*&gt;</span> <span class="n">id_tree_vec</span> <span class="o">=</span> <span class="p">{};</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">id</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">id</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Node</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">(</span><span class="n">informTime</span><span class="p">[</span><span class="n">id</span><span class="p">]);</span>
            <span class="n">id_tree_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
        <span class="p">}</span>
        
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">id</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">id</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">manager_id</span> <span class="o">=</span> <span class="n">manager</span><span class="p">[</span><span class="n">id</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">manager_id</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">id_tree_vec</span><span class="p">[</span><span class="n">manager_id</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">add_child</span><span class="p">(</span><span class="n">id_tree_vec</span><span class="p">[</span><span class="n">id</span><span class="p">]);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">rec</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">Node</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">childs</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>
            
            <span class="kt">int</span> <span class="n">max_child_result</span> <span class="o">=</span> <span class="o">-</span><span class="mi">9999999</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">c</span><span class="o">:</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">childs</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">max_child_result</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">max_child_result</span><span class="p">,</span> <span class="n">rec</span><span class="p">(</span><span class="n">c</span><span class="p">));</span>
            <span class="p">}</span>
            <span class="c1">// cout &lt;&lt; "in " &lt;&lt; root-&gt;id &lt;&lt; " max_child_result: " &lt;&lt; max_child_result &lt;&lt; endl;</span>
            <span class="k">return</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">time</span> <span class="o">+</span> <span class="n">max_child_result</span><span class="p">;</span>
        <span class="p">};</span>
        <span class="c1">// cout &lt;&lt; "finished!" &lt;&lt; id_tree_vec[headID]-&gt;id &lt;&lt; endl;</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">rec</span><span class="p">(</span><span class="n">id_tree_vec</span><span class="p">[</span><span class="n">headID</span><span class="p">]);</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <h2 id="动态规划">动态规划</h2> <h3 id="leetcode-1039切分三角形">Leetcode 1039：切分三角形</h3> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="p">:</span>
    <span class="nb">int</span> <span class="n">minScoreTriangulation</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;&amp;</span> <span class="k">values</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">int</span> <span class="k">size</span> <span class="o">=</span> <span class="k">values</span><span class="p">.</span><span class="k">size</span><span class="p">();</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;&gt;</span> <span class="n">dp</span><span class="p">(</span><span class="k">size</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span><span class="p">(</span><span class="k">size</span><span class="p">));</span>
        <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">step</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">step</span> <span class="o">&lt;</span> <span class="k">size</span><span class="p">;</span> <span class="o">++</span><span class="n">step</span><span class="p">)</span> <span class="p">{</span>
            <span class="o">//</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="nv">"[step: "</span> <span class="o">&lt;&lt;</span> <span class="n">step</span> <span class="o">&lt;&lt;</span> <span class="nv">"]"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">size</span> <span class="o">-</span> <span class="n">step</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
                <span class="o">//</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="nv">"enter: i["</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
 
                <span class="nb">int</span> <span class="k">temp</span> <span class="o">=</span> <span class="mi">9999999</span><span class="p">;</span>
                <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">i</span> <span class="o">+</span> <span class="n">step</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">step</span> <span class="o">&lt;</span> <span class="k">size</span><span class="p">)</span> <span class="p">{</span>
                        <span class="k">temp</span> <span class="o">=</span> <span class="k">min</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="o">+</span><span class="n">step</span><span class="p">]</span> <span class="o">+</span> <span class="k">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="k">values</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="k">values</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">step</span><span class="p">],</span> <span class="k">temp</span><span class="p">);</span>
                        <span class="o">//</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="nv">"dp[i][k]: "</span> <span class="o">&lt;&lt;</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
                        <span class="o">//</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="nv">"dp[k][i+step]: "</span> <span class="o">&lt;&lt;</span>  <span class="n">dp</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="o">+</span><span class="n">step</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
                        <span class="o">//</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="nv">"values[i] * values[k] * values[i+step]:"</span> <span class="o">&lt;&lt;</span> <span class="k">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="k">values</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="k">values</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">step</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
                        <span class="o">//</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="nv">"jisuan: "</span> <span class="o">&lt;&lt;</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="o">+</span><span class="n">step</span><span class="p">]</span> <span class="o">+</span> <span class="k">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="k">values</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="k">values</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">step</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
                        <span class="o">//</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="nv">"[i: "</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="nv">"; k: "</span> <span class="o">&lt;&lt;</span> <span class="n">k</span> <span class="o">&lt;&lt;</span> <span class="nv">"; i+step: "</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">+</span> <span class="n">step</span> <span class="o">&lt;&lt;</span> <span class="nv">"]: "</span> <span class="o">&lt;&lt;</span> <span class="k">temp</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>
                <span class="o">//</span> <span class="n">printf</span><span class="p">(</span><span class="nv">"set: dp[%d][%d]: %d</span><span class="se">\n</span><span class="nv">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="n">step</span><span class="p">,</span> <span class="k">temp</span><span class="p">);</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="o">+</span><span class="n">step</span><span class="p">]</span> <span class="o">=</span>  <span class="k">temp</span><span class="p">;</span>
                
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="k">size</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="leetcode-2304-网格中的最小路径代价">Leetcode 2304： 网格中的最小路径代价</h3> <ul> <li>暴力 DP：</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">minPathCost</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">grid</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">moveCost</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">dp</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">row_num</span> <span class="o">=</span> <span class="n">grid</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="kt">int</span> <span class="n">col_num</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">row_num</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">line_result</span> <span class="o">=</span> <span class="p">{};</span>
            <span class="n">dp</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">line_result</span><span class="p">);</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">col_num</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">col_num</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
        <span class="p">}</span>

        <span class="kt">int</span> <span class="n">MAX_NUM</span> <span class="o">=</span> <span class="mi">1410065404</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">row_num</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">col_num</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
                <span class="kt">int</span> <span class="n">min_dp</span> <span class="o">=</span> <span class="n">MAX_NUM</span><span class="p">;</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="n">col_num</span><span class="p">;</span> <span class="o">++</span><span class="n">m</span><span class="p">)</span> <span class="p">{</span>
                    <span class="c1">// cout &lt;&lt; "forward is (i - 1): " &lt;&lt; i - 1 &lt;&lt; " m: " &lt;&lt; m &lt;&lt; " moveCost[grid[i-1][m]][j]: " &lt;&lt; moveCost[grid[i-1][m]][j] &lt;&lt; endl;</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">m</span><span class="p">]</span> <span class="o">+</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">moveCost</span><span class="p">[</span><span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">m</span><span class="p">]][</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_dp</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">min_dp</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">m</span><span class="p">]</span> <span class="o">+</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">moveCost</span><span class="p">[</span><span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">m</span><span class="p">]][</span><span class="n">j</span><span class="p">];</span>
                    <span class="p">}</span>
                    
                <span class="p">}</span>

                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_dp</span><span class="p">;</span>
                <span class="c1">// cout &lt;&lt; "to i: " &lt;&lt; i &lt;&lt; " j: " &lt;&lt; j &lt;&lt; " dp value: " &lt;&lt; dp[i][j] &lt;&lt; endl;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">MAX_NUM</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">col_num</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">row_num</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">result</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">row_num</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <ul> <li>优化：原地修改【直接从下到上！！！】</li> </ul> <h2 id="bfs">BFS</h2> <ul> <li>Leetcode 2451</li> <li>BFS 很适合确定层数！</li> </ul> <h2 id="贪心算法">贪心算法</h2> <h3 id="leetcode-1053-更换顺序字典序最小序列">Leetcode 1053 更换顺序字典序最小序列</h3> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/EniqbAu5noCw84xQmyUcbqUjnTc-480.webp 480w, /assets/img/feishu_docs_static/EniqbAu5noCw84xQmyUcbqUjnTc-800.webp 800w, /assets/img/feishu_docs_static/EniqbAu5noCw84xQmyUcbqUjnTc-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/EniqbAu5noCw84xQmyUcbqUjnTc.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">prevPermOpt1</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">arr</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">arr</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">swap</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">arr</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">last_one_up</span> <span class="o">=</span> <span class="mi">99999</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">last_index</span> <span class="o">=</span> <span class="n">arr</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">last_index</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="p">[</span><span class="n">last_index</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">last_one_up</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">last_one_up</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">last_index</span><span class="p">];</span>
                <span class="n">last_index</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">last_index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">arr</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">last_one_up</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">last_index</span><span class="p">];</span>
            <span class="p">}</span>
            <span class="kt">int</span> <span class="n">second_index</span> <span class="o">=</span> <span class="n">arr</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">second_index</span> <span class="o">&gt;</span> <span class="n">last_index</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="p">[</span><span class="n">second_index</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">last_one_up</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// cout &lt;&lt; "arr[second_index]: " &lt;&lt; arr[second_index] &lt;&lt; "; last_one_up: " &lt;&lt; last_one_up &lt;&lt; endl; </span>
                <span class="o">--</span><span class="n">second_index</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="kt">int</span> <span class="n">second_one_up</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">second_index</span><span class="p">];</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">second_index</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">last_index</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="p">[</span><span class="n">second_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">second_one_up</span><span class="p">)</span> <span class="p">{</span>
                <span class="o">--</span><span class="n">second_index</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="c1">// cout &lt;&lt; "last_index: " &lt;&lt; last_index &lt;&lt; "; second_index: " &lt;&lt; second_index &lt;&lt; endl; </span>
            <span class="n">swap</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">last_index</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">second_index</span><span class="p">]);</span>
            <span class="k">return</span> <span class="n">arr</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="kt">int</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">b</span><span class="o">=</span><span class="mi">3</span><span class="p">;</span>
    <span class="n">cont</span><span class="o">&lt;&lt;</span><span class="s">"KFC V me 50"</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="leetcode-1042-着色问题">Leetcode 1042 着色问题</h3> <ul> <li><a href="https://leetcode.cn/problems/flower-planting-with-no-adjacent/submissions/">1042. 不邻接植花 - 力扣（LeetCode）</a></li> <li>这个贪心用的非常直接，而且算法还是比较暴力且考验各种数据结构的熟练程度，是一个不错的代码</li> </ul> <h3 id="leetcode-2517-最大最小优化问题">Leetcode 2517 最大最小优化问题</h3> <ul> <li><a href="https://leetcode.cn/problems/maximum-tastiness-of-candy-basket/">https://leetcode.cn/problems/maximum-tastiness-of-candy-basket/</a></li> <li>这就是一个非常经典的最大最小优化问题</li> </ul> <h3 id="leetcode-2611-两方离线资源分配问题">Leetcode 2611 两方离线资源分配问题</h3> <ul> <li>这个题很简单，但是自己想却想不出来……</li> <li>思路就是计算所有资源分配给 1 和分配给 2 的 utility 差值，然后从高到低排序即可！但是如果搜索算法的效率就会很低，但是贪心直接就得到了最优解！</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">cmp</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span> 
    <span class="k">return</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>

<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">miceAndCheese</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">reward1</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">reward2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
        
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">reward1</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">reward1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">reward1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">reward2</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>

        <span class="n">sort</span><span class="p">(</span><span class="n">reward1</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">reward1</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">cmp</span><span class="p">);</span>
        

        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="p">(</span><span class="n">reward1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">reward2</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">reward1</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="n">reward2</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <h2 id="单调栈">单调栈</h2> <h3 id="leetcode-1019-获取链表的下一个更大的值">Leetcode 1019 获取链表的下一个更大的值</h3> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">package</span> <span class="n">main</span>

<span class="n">import</span> <span class="p">(</span>
    <span class="nv">"fmt"</span>
    <span class="nv">"sync"</span>
<span class="p">)</span>

<span class="k">type</span> <span class="n">ListNode</span> <span class="n">struct</span> <span class="p">{</span>
    <span class="n">Val</span>  <span class="nb">int</span>
    <span class="k">Next</span> <span class="o">*</span><span class="n">ListNode</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Item</span> <span class="n">struct</span> <span class="p">{</span>
    <span class="n">OriginIndex</span> <span class="nb">int</span>
    <span class="n">Val</span>         <span class="nb">int</span>
<span class="p">}</span>
<span class="k">type</span> <span class="n">ItemStack</span> <span class="n">struct</span> <span class="p">{</span>
    <span class="n">items</span> <span class="p">[]</span><span class="n">Item</span>
    <span class="k">lock</span>  <span class="n">sync</span><span class="p">.</span><span class="n">RWMutex</span>
<span class="p">}</span>

<span class="n">func</span> <span class="n">NewStack</span><span class="p">()</span> <span class="o">*</span><span class="n">ItemStack</span> <span class="p">{</span>
    <span class="n">s</span> <span class="p">:</span><span class="o">=</span> <span class="o">&amp;</span><span class="n">ItemStack</span><span class="p">{}</span>  <span class="o">//</span> <span class="err">初始化</span><span class="n">Stack</span>
    <span class="n">s</span><span class="p">.</span><span class="n">items</span> <span class="o">=</span> <span class="p">[]</span><span class="n">Item</span><span class="p">{}</span> <span class="o">//</span> <span class="err">初始化数组</span>
    <span class="k">return</span> <span class="n">s</span>
<span class="p">}</span>

<span class="n">func</span> <span class="p">(</span><span class="n">s</span> <span class="o">*</span><span class="n">ItemStack</span><span class="p">)</span> <span class="n">Print</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">fmt</span><span class="p">.</span><span class="n">Println</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">items</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">func</span> <span class="p">(</span><span class="n">s</span> <span class="o">*</span><span class="n">ItemStack</span><span class="p">)</span> <span class="n">Push</span><span class="p">(</span><span class="n">t</span> <span class="n">Item</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">s</span><span class="p">.</span><span class="k">lock</span><span class="p">.</span><span class="k">Lock</span><span class="p">()</span>
    <span class="n">defer</span> <span class="n">s</span><span class="p">.</span><span class="k">lock</span><span class="p">.</span><span class="n">Unlock</span><span class="p">()</span>
    <span class="o">//</span> <span class="n">fmt</span><span class="p">.</span><span class="n">Println</span><span class="p">(</span><span class="nv">"push t: "</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
    <span class="n">s</span><span class="p">.</span><span class="n">items</span> <span class="o">=</span> <span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">items</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">func</span> <span class="p">(</span><span class="n">s</span> <span class="o">*</span><span class="n">ItemStack</span><span class="p">)</span> <span class="n">Pop</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">s</span><span class="p">.</span><span class="k">lock</span><span class="p">.</span><span class="k">Lock</span><span class="p">()</span>
    <span class="n">defer</span> <span class="n">s</span><span class="p">.</span><span class="k">lock</span><span class="p">.</span><span class="n">Unlock</span><span class="p">()</span>
    <span class="n">if</span> <span class="n">len</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">items</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="k">index</span> <span class="p">:</span><span class="o">=</span> <span class="n">len</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">items</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="o">//</span> <span class="n">item</span> <span class="p">:</span><span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">items</span><span class="p">[</span><span class="k">index</span><span class="p">]</span>
    <span class="o">//</span> <span class="n">fmt</span><span class="p">.</span><span class="n">Println</span><span class="p">(</span><span class="nv">"pop t: "</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
    <span class="n">s</span><span class="p">.</span><span class="n">items</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">items</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="k">index</span><span class="p">]</span>
    <span class="o">//</span> <span class="n">fmt</span><span class="p">.</span><span class="n">Println</span><span class="p">(</span><span class="nv">"success pop !"</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">func</span> <span class="p">(</span><span class="n">s</span> <span class="o">*</span><span class="n">ItemStack</span><span class="p">)</span> <span class="n">Top</span><span class="p">()</span> <span class="o">*</span><span class="n">Item</span> <span class="p">{</span>
    <span class="n">s</span><span class="p">.</span><span class="k">lock</span><span class="p">.</span><span class="k">Lock</span><span class="p">()</span>
    <span class="n">defer</span> <span class="n">s</span><span class="p">.</span><span class="k">lock</span><span class="p">.</span><span class="n">Unlock</span><span class="p">()</span>

    <span class="o">//</span> <span class="n">fmt</span><span class="p">.</span><span class="n">Println</span><span class="p">(</span><span class="nv">"get index"</span><span class="p">)</span>
    <span class="n">if</span> <span class="n">len</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">items</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">nil</span>
    <span class="p">}</span>
    <span class="k">index</span> <span class="p">:</span><span class="o">=</span> <span class="n">len</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">items</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="n">item</span> <span class="p">:</span><span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">items</span><span class="p">[</span><span class="k">index</span><span class="p">]</span>
    <span class="o">//</span> <span class="n">fmt</span><span class="p">.</span><span class="n">Println</span><span class="p">(</span><span class="nv">"success top !"</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="n">item</span>
<span class="p">}</span>

<span class="n">func</span> <span class="p">(</span><span class="n">s</span> <span class="o">*</span><span class="n">ItemStack</span><span class="p">)</span> <span class="n">Len</span><span class="p">()</span> <span class="nb">int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">len</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">items</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">func</span> <span class="n">transver</span><span class="p">(</span><span class="n">head</span> <span class="o">*</span><span class="n">ListNode</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">head</span> <span class="o">!=</span> <span class="n">nil</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="p">.</span><span class="n">Println</span><span class="p">(</span><span class="n">head</span><span class="p">.</span><span class="n">Val</span><span class="p">)</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="p">.</span><span class="k">Next</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">func</span> <span class="n">nextLargerNodes</span><span class="p">(</span><span class="n">head</span> <span class="o">*</span><span class="n">ListNode</span><span class="p">)</span> <span class="p">[]</span><span class="nb">int</span> <span class="p">{</span>
    <span class="n">stack</span> <span class="p">:</span><span class="o">=</span> <span class="n">NewStack</span><span class="p">()</span>

    <span class="n">var</span> <span class="k">index</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">var</span> <span class="n">res</span> <span class="p">[]</span><span class="nb">int</span>
    <span class="k">for</span> <span class="n">head</span> <span class="o">!=</span> <span class="n">nil</span> <span class="p">{</span>
        <span class="n">if</span> <span class="n">stack</span><span class="p">.</span><span class="n">Len</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="n">var</span> <span class="n">item</span> <span class="n">Item</span>
            <span class="n">item</span><span class="p">.</span><span class="n">OriginIndex</span> <span class="o">=</span> <span class="k">index</span>
            <span class="n">item</span><span class="p">.</span><span class="n">Val</span> <span class="o">=</span> <span class="n">head</span><span class="p">.</span><span class="n">Val</span>
            <span class="n">stack</span><span class="p">.</span><span class="n">Push</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
            <span class="o">//</span> <span class="n">fmt</span><span class="p">.</span><span class="n">Println</span><span class="p">(</span><span class="nv">"current stack: "</span><span class="p">,</span> <span class="n">stack</span><span class="p">.</span><span class="n">items</span><span class="p">)</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">top_item</span> <span class="p">:</span><span class="o">=</span> <span class="n">stack</span><span class="p">.</span><span class="n">Top</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">top_item</span> <span class="o">!=</span> <span class="n">nil</span> <span class="o">&amp;&amp;</span> <span class="n">head</span><span class="p">.</span><span class="n">Val</span> <span class="o">&gt;</span> <span class="n">top_item</span><span class="p">.</span><span class="n">Val</span> <span class="p">{</span>
                <span class="o">//</span> <span class="n">fmt</span><span class="p">.</span><span class="n">Println</span><span class="p">(</span><span class="nv">"pop_item: "</span><span class="p">,</span> <span class="n">top_item</span><span class="p">.</span><span class="n">Val</span><span class="p">,</span> <span class="nv">" head.Val: "</span><span class="p">,</span> <span class="n">head</span><span class="p">.</span><span class="n">Val</span><span class="p">)</span>
                <span class="n">stack</span><span class="p">.</span><span class="n">Pop</span><span class="p">()</span>
                <span class="n">res</span><span class="p">[</span><span class="n">top_item</span><span class="p">.</span><span class="n">OriginIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">head</span><span class="p">.</span><span class="n">Val</span>
                <span class="n">top_item</span> <span class="o">=</span> <span class="n">stack</span><span class="p">.</span><span class="n">Top</span><span class="p">()</span>
                <span class="o">//</span> <span class="n">fmt</span><span class="p">.</span><span class="n">Println</span><span class="p">(</span><span class="nv">"next top_item: "</span><span class="p">,</span> <span class="n">top_item</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="n">var</span> <span class="n">item</span> <span class="n">Item</span>
            <span class="n">item</span><span class="p">.</span><span class="n">OriginIndex</span> <span class="o">=</span> <span class="k">index</span>
            <span class="n">item</span><span class="p">.</span><span class="n">Val</span> <span class="o">=</span> <span class="n">head</span><span class="p">.</span><span class="n">Val</span>
            <span class="n">stack</span><span class="p">.</span><span class="n">Push</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
            <span class="o">//</span> <span class="n">fmt</span><span class="p">.</span><span class="n">Println</span><span class="p">(</span><span class="nv">"current stack: "</span><span class="p">,</span> <span class="n">stack</span><span class="p">.</span><span class="n">items</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">append</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">index</span> <span class="o">=</span> <span class="k">index</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="p">.</span><span class="k">Next</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">res</span>
<span class="p">}</span>

<span class="n">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">var</span> <span class="n">head</span> <span class="o">=</span> <span class="k">new</span><span class="p">(</span><span class="n">ListNode</span><span class="p">)</span>
    <span class="n">head</span><span class="p">.</span><span class="n">Val</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="n">var</span> <span class="k">second</span> <span class="o">=</span> <span class="k">new</span><span class="p">(</span><span class="n">ListNode</span><span class="p">)</span>
    <span class="k">second</span><span class="p">.</span><span class="n">Val</span> <span class="o">=</span> <span class="mi">7</span>
    <span class="n">head</span><span class="p">.</span><span class="k">Next</span> <span class="o">=</span> <span class="k">second</span>

    <span class="n">var</span> <span class="n">third</span> <span class="o">=</span> <span class="k">new</span><span class="p">(</span><span class="n">ListNode</span><span class="p">)</span>
    <span class="n">third</span><span class="p">.</span><span class="n">Val</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="k">second</span><span class="p">.</span><span class="k">Next</span> <span class="o">=</span> <span class="n">third</span>

    <span class="n">var</span> <span class="n">fourth</span> <span class="o">=</span> <span class="k">new</span><span class="p">(</span><span class="n">ListNode</span><span class="p">)</span>
    <span class="n">fourth</span><span class="p">.</span><span class="n">Val</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="n">third</span><span class="p">.</span><span class="k">Next</span> <span class="o">=</span> <span class="n">fourth</span>

    <span class="n">var</span> <span class="n">fifth</span> <span class="o">=</span> <span class="k">new</span><span class="p">(</span><span class="n">ListNode</span><span class="p">)</span>
    <span class="n">fifth</span><span class="p">.</span><span class="n">Val</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="n">fourth</span><span class="p">.</span><span class="k">Next</span> <span class="o">=</span> <span class="n">fifth</span>

    <span class="k">result</span> <span class="p">:</span><span class="o">=</span> <span class="n">nextLargerNodes</span><span class="p">(</span><span class="n">head</span><span class="p">)</span>
    <span class="n">fmt</span><span class="p">.</span><span class="n">Println</span><span class="p">(</span><span class="k">result</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="请复习leetcode-907-子数组的最小值之和">【请复习】Leetcode 907 子数组的最小值之和</h3> <ul> <li>参考文献：<a href="https://lfool.github.io/LFool-Notes/algorithm/%E5%8D%95%E8%B0%83%E6%A0%88-%E6%8B%93%E5%B1%95%E5%BA%94%E7%94%A8.html">https://lfool.github.io/LFool-Notes/algorithm/%E5%8D%95%E8%B0%83%E6%A0%88-%E6%8B%93%E5%B1%95%E5%BA%94%E7%94%A8.html</a></li> </ul> <h2 id="数论">数论</h2> <h3 id="负二进制模拟">负二进制模拟</h3> <ul> <li>这是一个在 KTV 写的题，当时没有写出来，现在回想一下还是比较简单的。</li> <li> <p>第一步，先要将十进制数进行二进制分解</p> <ul> <li>27 =&gt; 16 + 8 + 2 + 1</li> </ul> </li> <li> <p>第二步，将这些数中无法在二进制中取得负数的值转化一下</p> <ul> <li>8 = 16 + (-8)</li> <li>2 = 4 + (-2)</li> </ul> </li> <li> <p>第三步，从低位到高位将转化后的二进制数组写出来，slice 中第一位表示负二进制数，第二位表示出现的次数</p> <ul> <li>[(1, 1), (-2, 1), (4, 1), (-8, 1), (16, 2)]</li> </ul> </li> <li> <p>第四步，对出现大于等于 2 和小于等于-1 的情况进行处理</p> <ul> <li>大于等于 2：当前位减去 2，高一位减去 1</li> <li>小于等于-1：当前位加上 2，高一位加上 1</li> </ul> </li> <li>第五步，一个 while 循环，直到最高位置出现的数量为 0 或 1 结束即可！</li> </ul> <h2 id="双指针">双指针</h2> <ul> <li> <p>链表中的双指针：</p> <ul> <li>中间相差 k 可以获取从前后开始的第 k 个节点 - <a href="https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/</a></li> <li>快指针走 2 步，慢指针走 1 步：可以在不知道 n 的情况下获得中点的位置！ - <a href="https://leetcode.cn/problems/middle-of-the-linked-list/">https://leetcode.cn/problems/middle-of-the-linked-list/</a></li> <li>快指针走 2 步，慢指针走 1 步：可以判断一个链表是否成环！【因为只要有环，肯定会让快慢指针重合的，没有环肯定就直接走了！】</li> <li>同速指针：找到两个链表的相交 node！！【同时应该考虑链表的长度~】</li> </ul> </li> <li> <p>数组中的双指针</p> <ul> <li>左右窗口双指针：用于左右压缩空间</li> <li>快慢双指针：一般是一个指针比较快，另一个指针比较慢，一般是用于原地覆盖 nums！！</li> </ul> </li> </ul> <h3 id="lcr-140-链表的倒数第-k-个-node---快慢指针">LCR. 140 链表的倒数第 k 个 node - 快慢指针</h3> <ul> <li>快慢指针，快指针比慢指针多走 k 步，最后快指针到 null 的时候，倒数第 k 个就慢指针的位置。</li> </ul> <div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">trainingPlan</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="nb">head</span><span class="p">,</span> <span class="n">int</span> <span class="n">cnt</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ListNode</span><span class="o">*</span> <span class="n">fast</span> <span class="o">=</span> <span class="nb">head</span><span class="p">;</span>
        <span class="n">ListNode</span><span class="o">*</span> <span class="n">slow</span> <span class="o">=</span> <span class="nb">head</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cnt</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">fast</span> <span class="err">!</span><span class="o">=</span> <span class="n">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">slow</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="leetcode-1410-字符串匹配和替换">Leetcode 1410 字符串匹配和替换</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">string</span> <span class="n">entityParser</span><span class="p">(</span><span class="n">string</span> <span class="n">text</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;</span> <span class="n">umap</span><span class="p">;</span>
        
        <span class="n">umap</span><span class="p">[</span><span class="s">"&amp;quot;"</span><span class="p">]</span> <span class="o">=</span> <span class="s">"</span><span class="se">\"</span><span class="s">"</span><span class="p">;</span>
        <span class="n">umap</span><span class="p">[</span><span class="s">"&amp;apos;"</span><span class="p">]</span> <span class="o">=</span> <span class="s">"</span><span class="se">\'</span><span class="s">"</span><span class="p">;</span>
        <span class="n">umap</span><span class="p">[</span><span class="s">"&amp;amp;"</span><span class="p">]</span> <span class="o">=</span> <span class="s">"&amp;"</span><span class="p">;</span>
        <span class="n">umap</span><span class="p">[</span><span class="s">"&amp;gt;"</span><span class="p">]</span> <span class="o">=</span> <span class="s">"&gt;"</span><span class="p">;</span>
        <span class="n">umap</span><span class="p">[</span><span class="s">"&amp;lt;"</span><span class="p">]</span> <span class="o">=</span> <span class="s">"&lt;"</span><span class="p">;</span>
        <span class="n">umap</span><span class="p">[</span><span class="s">"&amp;frasl;"</span><span class="p">]</span> <span class="o">=</span> <span class="s">"/"</span><span class="p">;</span>

        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">left_fix</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">right_fix</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">to_copy_str_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">string</span> <span class="n">result</span> <span class="o">=</span> <span class="s">""</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">text</span><span class="p">.</span><span class="n">length</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">text</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'&amp;'</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
                <span class="n">left_fix</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                <span class="c1">// cout &lt;&lt; "left: " &lt;&lt; left &lt;&lt; endl; </span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">text</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">';'</span> <span class="o">&amp;&amp;</span> <span class="n">left_fix</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
                <span class="n">right_fix</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                <span class="c1">// cout &lt;&lt; "right: " &lt;&lt; right &lt;&lt; endl; </span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">left_fix</span> <span class="o">&amp;&amp;</span> <span class="n">right_fix</span> <span class="o">&amp;&amp;</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">text</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">text</span><span class="p">.</span><span class="n">length</span><span class="p">())</span> <span class="p">{</span>
                <span class="n">string</span> <span class="n">need_judge_substr</span> <span class="o">=</span> <span class="n">text</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

                <span class="c1">// cout &lt;&lt; "need_judge_substr: " &lt;&lt; need_judge_substr &lt;&lt; endl; </span>
                <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">umap</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">need_judge_substr</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">iter</span> <span class="o">!=</span> <span class="n">umap</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
                    <span class="kt">int</span> <span class="n">to_copy_len</span> <span class="o">=</span> <span class="n">left</span> <span class="o">-</span> <span class="n">to_copy_str_index</span><span class="p">;</span>
                    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">q</span> <span class="o">=</span> <span class="n">to_copy_str_index</span><span class="p">;</span> <span class="n">q</span> <span class="o">&lt;</span> <span class="n">to_copy_str_index</span> <span class="o">+</span> <span class="n">to_copy_len</span><span class="p">;</span> <span class="o">++</span><span class="n">q</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">result</span> <span class="o">+=</span> <span class="n">text</span><span class="p">[</span><span class="n">q</span><span class="p">];</span>
                    <span class="p">}</span>
                    <span class="n">result</span> <span class="o">+=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
                    
                    <span class="n">to_copy_str_index</span> <span class="o">=</span> <span class="n">right</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
                    <span class="n">left_fix</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
                    <span class="n">right_fix</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="n">left_fix</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
                    <span class="n">right_fix</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">to_copy_str_index</span> <span class="o">&lt;</span> <span class="n">text</span><span class="p">.</span><span class="n">length</span><span class="p">())</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">to_copy_len</span> <span class="o">=</span> <span class="n">text</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">-</span> <span class="n">to_copy_str_index</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">q</span> <span class="o">=</span> <span class="n">to_copy_str_index</span><span class="p">;</span> <span class="n">q</span> <span class="o">&lt;</span> <span class="n">to_copy_str_index</span> <span class="o">+</span> <span class="n">to_copy_len</span><span class="p">;</span> <span class="o">++</span><span class="n">q</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="n">text</span><span class="p">[</span><span class="n">q</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="leetcode-142-环形链表-ii">Leetcode 142 环形链表 II</h3> <ul> <li>这道题真的是双指针的代表性题目 <ul> <li>先变速指针：相遇之后，快指针走 2k 步，慢指针走 k 步。其中 k 肯定是环的倍数！</li> <li>后同速指针：那么从 head 到相遇点是 k，整个环也是 k，因此可以从数学上获得入环的起点！</li> </ul> </li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/PdICb8ez0odjTsxOYcXcZCV1n7e-480.webp 480w, /assets/img/feishu_docs_static/PdICb8ez0odjTsxOYcXcZCV1n7e-800.webp 800w, /assets/img/feishu_docs_static/PdICb8ez0odjTsxOYcXcZCV1n7e-1400.webp 1400w, " sizes="95vw" type="image/webp"/> <img src="/assets/img/feishu_docs_static/PdICb8ez0odjTsxOYcXcZCV1n7e.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <h3 id="leetcode--5-最长回文子串">Leetcode 5 最长回文子串</h3> <ul> <li>尽量记住，子串一般使用双指针！</li> <li>这道题的思路应该是从中间开始向左右指针，这样复杂度每个都可以压倒 O(n)，总共需要外层训练 O(n)次，复杂度是 O(n^2)</li> </ul> <div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="n">test</span><span class="p">(</span><span class="nb">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">,</span> <span class="n">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">int</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="nb">size</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">i</span><span class="o">--</span><span class="p">;</span>
            <span class="n">j</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">int</span> <span class="n">len</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>
        <span class="n">res</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">res</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
        <span class="p">//</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s2">"push: "</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="s2">" "</span> <span class="o">&lt;&lt;</span> <span class="n">len</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nb">string</span> <span class="n">longestPalindrome</span><span class="p">(</span><span class="nb">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">int</span> <span class="n">max_len</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">};</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="nb">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="n">sub_str_0</span> <span class="o">=</span> <span class="n">test</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
            <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="n">sub_str_1</span> <span class="o">=</span> <span class="n">test</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">sub_str_0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">max_len</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sub_str_0</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
                <span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sub_str_0</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
                <span class="n">max_len</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">sub_str_1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">max_len</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sub_str_1</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
                <span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sub_str_1</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
                <span class="n">max_len</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">substr</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <h2 id="滑动窗口">滑动窗口</h2> <h3 id="请复习滑动窗口的模板">【请复习】滑动窗口的模板</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* 滑动窗口算法框架 */</span>
<span class="kt">void</span> <span class="nf">slidingWindow</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 用合适的数据结构记录窗口中的数据</span>
    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">window</span><span class="p">;</span>
    
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">right</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
        <span class="c1">// c 是将移入窗口的字符</span>
        <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">right</span><span class="p">];</span>
        <span class="n">window</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="c1">// 增大窗口</span>
        <span class="n">right</span><span class="o">++</span><span class="p">;</span>
        <span class="c1">// 进行窗口内数据的一系列更新</span>
        <span class="p">...</span>

        <span class="cm">/*** debug 输出的位置 ***/</span>
        <span class="c1">// 注意在最终的解法代码中不要 print</span>
        <span class="c1">// 因为 IO 操作很耗时，可能导致超时</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"window: [%d, %d)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
        <span class="cm">/********************/</span>
        
        <span class="c1">// 判断左侧窗口是否要收缩</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">window</span> <span class="n">needs</span> <span class="n">shrink</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// d 是将移出窗口的字符</span>
            <span class="kt">char</span> <span class="n">d</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">left</span><span class="p">];</span>
            <span class="n">window</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="c1">// 缩小窗口</span>
            <span class="n">left</span><span class="o">++</span><span class="p">;</span>
            <span class="c1">// 进行窗口内数据的一系列更新</span>
            <span class="p">...</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="leetcode-3">Leetcode 3</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">lengthOfLongestSubstring</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">mp</span><span class="p">;</span>
    
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">max_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">right</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">right</span><span class="p">];</span>
        <span class="n">mp</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
        <span class="n">right</span><span class="o">++</span><span class="p">;</span>
        <span class="c1">// cout &lt;&lt; "left: " &lt;&lt; left &lt;&lt; " right: " &lt;&lt; right &lt;&lt; " : ";</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">mp</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">char</span> <span class="n">left_c</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">left</span><span class="p">];</span>
            <span class="n">mp</span><span class="p">[</span><span class="n">left_c</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
            <span class="n">left</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span> 
        <span class="n">max_len</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">max_len</span><span class="p">,</span> <span class="n">right</span><span class="o">-</span><span class="n">left</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">max_len</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="位操作">位操作</h2> <h3 id="判断一个-list-中元素出现偶数还是奇数32-位以内">判断一个 list 中元素出现偶数还是奇数（32 位以内）</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">}</span>
<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">res</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">result</span> <span class="o">^=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="c1">// 异或操作, 出现一次的位会被设置为1</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="lowbit-操作">lowbit 操作</h3> <ul> <li> <p>快速找到一个数中二进制的最高位置的 1 以及<strong>后面所有 0</strong>的组合</p> <ul> <li>原码 = 101010101000000</li> <li>补码 = 010101011000000</li> <li>原码&amp;补码 = 000000001000000 = 1000000</li> </ul> </li> <li> <p>求二进制中 1 的个数</p> <ul> <li>每次都通过 lowbit()获取最高位置的 1 及后续 0 串，然后不断减</li> </ul> </li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">lowbit</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">n</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">-</span><span class="n">n</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">n</span> <span class="o">-=</span> <span class="n">lowbit</span><span class="p">(</span><span class="n">n</span><span class="p">);</span> <span class="c1">//每次减掉最后一个1及其后面所有0的部分</span>
        <span class="n">res</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">res</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <ul> <li>判断是否最多只有一个字符出现奇数次的操作，也就是判断一个二进制数字是为全为 0 或仅有一位 1，可配合 lowbit 来做，若 cnt 与 lowbit(cnt) = cnt &amp; -cnt 相等，说明满足要求。 <ul> <li>考虑到对 lowbit(x) = x &amp; -x 不熟悉的同学，这里再做简单介绍：lowbit(x) 表示 x 的二进制表示<strong>最低位的 1 所在的位置对应的值</strong>，即仅保留从最低位起的第一个 1，其余位均以 0 填充：</li> <li>x = 6，其二进制表示为 110 ，那么 lowbit(6)=(010)=2</li> <li>x = 12，其二进制表示为 1100，那么 lowbit(12)=(100)=4</li> </ul> </li> </ul> <h3 id="伪回文路径判断条件">伪回文路径判断条件</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">mask</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
</code></pre></div></div> <ul> <li>Leetcode 1457</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
Definition for a binary tree node.
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};
 */</span>

<span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">struct</span> <span class="nc">TreeNode</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">left</span><span class="p">;</span>
    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">right</span><span class="p">;</span>
    <span class="n">TreeNode</span><span class="p">()</span> <span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">left</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">),</span> <span class="n">right</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">TreeNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">left</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">),</span> <span class="n">right</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">TreeNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">TreeNode</span> <span class="o">*</span><span class="n">left</span><span class="p">,</span> <span class="n">TreeNode</span> <span class="o">*</span><span class="n">right</span><span class="p">)</span> <span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">left</span><span class="p">(</span><span class="n">left</span><span class="p">),</span> <span class="n">right</span><span class="p">(</span><span class="n">right</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>

    <span class="kt">int</span> <span class="n">preTransver</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">result</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cnt</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"check root-&gt;val [add one]: "</span> <span class="o">&lt;&lt;</span>  <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="c1">// umap[root-&gt;val] += 1;</span>
        <span class="n">cnt</span> <span class="o">^=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"cnt: "</span> <span class="o">&lt;&lt;</span> <span class="n">cnt</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="n">cnt</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"is hui wen"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
                
                <span class="k">return</span> <span class="n">result</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"not is hui wen"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
                <span class="c1">// umap[root-&gt;val] -= 1;</span>
                <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">preTransver</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">cnt</span><span class="p">);</span>
            <span class="c1">// umap[root-&gt;left-&gt;val] -= 1;</span>
            <span class="c1">// cout &lt;&lt; "[sub one]: " &lt;&lt; root-&gt;left-&gt;val &lt;&lt; endl;</span>
        <span class="p">}</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">preTransver</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">cnt</span><span class="p">);</span>
            <span class="c1">// umap[root-&gt;right-&gt;val] -= 1;</span>
            <span class="c1">// cout &lt;&lt; "[sub one]: " &lt;&lt; root-&gt;right-&gt;val &lt;&lt; endl;</span>
        <span class="p">}</span>
        
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>

    <span class="p">}</span>
    <span class="kt">int</span> <span class="nf">pseudoPalindromicPaths</span> <span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">preTransver</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">cnt</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
    <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

    <span class="n">Solution</span> <span class="o">*</span><span class="n">sol</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Solution</span><span class="p">();</span>

    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">sol</span><span class="o">-&gt;</span><span class="n">pseudoPalindromicPaths</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="技术杂记"/><category term="技术杂记"/><summary type="html"><![CDATA[C++/Go算法学习 - 整个文档偏算法]]></summary></entry><entry><title type="html">Approximation algorithm</title><link href="https://xlcbingo1999.github.io/blog/2022/approximation-algorithms/" rel="alternate" type="text/html" title="Approximation algorithm"/><published>2022-10-27T17:39:00+00:00</published><updated>2022-10-27T17:39:00+00:00</updated><id>https://xlcbingo1999.github.io/blog/2022/approximation-algorithms</id><content type="html" xml:base="https://xlcbingo1999.github.io/blog/2022/approximation-algorithms/"><![CDATA[<p>Redirecting to online algorithms.</p>]]></content><author><name></name></author><category term="Slide"/><category term="理论类笔记"/><summary type="html"><![CDATA[Introduction of Approximation algorithm]]></summary></entry><entry><title type="html">集合相似性</title><link href="https://xlcbingo1999.github.io/blog/2022/Metric/" rel="alternate" type="text/html" title="集合相似性"/><published>2022-09-09T17:39:00+00:00</published><updated>2022-09-09T17:39:00+00:00</updated><id>https://xlcbingo1999.github.io/blog/2022/Metric</id><content type="html" xml:base="https://xlcbingo1999.github.io/blog/2022/Metric/"><![CDATA[<ul> <li>集合相似性度量方式： <ul> <li>参考文献（日本）：<a href="https://www.cnblogs.com/bristlegrass/p/11546432.html">https://www.cnblogs.com/bristlegrass/p/11546432.html</a></li> <li>参考文献（日本）：<a href="https://mieruca-ai.com/ai/jaccard_dice_simpson">https://mieruca-ai.com/ai/jaccard_dice_simpson</a></li> </ul> </li> <li>向量相似性度量方式： <ul> <li>欧式距离</li> <li>曼哈顿距离</li> <li>切比雪夫距离</li> <li>⻢哈拉诺⽐斯距离【马氏距离（Mahalanobis Distance）是由马哈拉诺比斯（P. C. Mahalanobis）提出的，表示数据的协方差距离。它是一种有效的计算两个未知样本集的相似度的方法。与欧氏距离不同的是它考虑到各种特性之间的联系（例如：一条关于身高的信息会带来一条关于体重的信息，因为两者是有关联的）并且是尺度无关的（scale-invariant），即独立于测量尺度。】 <a href="https://blog.csdn.net/fu_jian_ping/article/details/111877248">https://blog.csdn.net/fu_jian_ping/article/details/111877248</a></li> <li>SMC（用于bool向量）</li> </ul> </li> <li>信息量 <ul> <li>概率越小，包含的信息越多</li> <li>将概率换成频率后，可以衡量一个数据表的信息量</li> </ul> </li> </ul>]]></content><author><name></name></author><category term="技术杂记"/><category term="技术杂记"/><summary type="html"><![CDATA[集合相似性]]></summary></entry></feed>