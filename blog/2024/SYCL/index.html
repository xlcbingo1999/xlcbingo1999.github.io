<!DOCTYPE html> <html lang="cn"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>SYCL+OneAPI+DPC++软件栈 | Linchang Xiao</title> <meta name="author" content="Linchang Xiao"> <meta name="description" content="SYCL+OneAPI+DPC++软件栈"> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?19f3075a2d19613090fe9e16b564e1fe" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/icon.jpg?7b7b29ac9f6063e03543e5148578c7f5"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://xlcbingo1999.github.io/blog/2024/SYCL/"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?e74e74bf055e5729d44a7d031a5ca6a5" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?6185d15ea1982787ad7f435576553d64"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/">Linchang Xiao</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about</a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">blog</a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv</a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fa-solid fa-moon"></i> <i class="fa-solid fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">SYCL+OneAPI+DPC++软件栈</h1> <p class="post-meta">May 7, 2024</p> <p class="post-tags"> <a href="/blog/2024"> <i class="fa-solid fa-calendar fa-sm"></i> 2024 </a>   ·   <a href="/blog/tag/%E7%B3%BB%E7%BB%9F-%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97"> <i class="fa-solid fa-hashtag fa-sm"></i> 系统-高性能计算</a>     ·   <a href="/blog/category/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E6%BA%90%E7%A0%81"> <i class="fa-solid fa-tag fa-sm"></i> 开源项目源码</a>   </p> </header> <article class="post-content"> <div id="markdown-content"> <blockquote> <p>更好的排版请阅读: https://we5lw6jk7r.feishu.cn/wiki/GjQkwE6SciH2nhk3nERcwiC4nCq?from=from_copylink</p> </blockquote> <h1 id="sycloneapidpc-软件栈">SYCL+OneAPI+DPC++ 软件栈</h1> <h2 id="教程">教程</h2> <ul> <li>可视化的实例界面：<a href="https://tech.io/playgrounds/48226/introduction-to-sycl/sycl-kernel-programming---the-single_task-api" rel="external nofollow noopener" target="_blank">https://tech.io/playgrounds/48226/introduction-to-sycl/sycl-kernel-programming—the-single_task-api</a> </li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/GRU0bCQw6o7rzRx2KcBcVspsnah-480.webp 480w, /assets/img/feishu_docs_static/GRU0bCQw6o7rzRx2KcBcVspsnah-800.webp 800w, /assets/img/feishu_docs_static/GRU0bCQw6o7rzRx2KcBcVspsnah-1400.webp 1400w, " sizes="95vw" type="image/webp"></source> <img src="/assets/img/feishu_docs_static/GRU0bCQw6o7rzRx2KcBcVspsnah.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/GUoObQspRobJvYx3S7RcWa8Bnsd-480.webp 480w, /assets/img/feishu_docs_static/GUoObQspRobJvYx3S7RcWa8Bnsd-800.webp 800w, /assets/img/feishu_docs_static/GUoObQspRobJvYx3S7RcWa8Bnsd-1400.webp 1400w, " sizes="95vw" type="image/webp"></source> <img src="/assets/img/feishu_docs_static/GUoObQspRobJvYx3S7RcWa8Bnsd.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <ul> <li>书籍：<a href="https://link.springer.com/book/10.1007/978-1-4842-5574-2" rel="external nofollow noopener" target="_blank">https://link.springer.com/book/10.1007/978-1-4842-5574-2</a> </li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/Kg2sbznoJowPqnxPX0fc4Vaxn2d-480.webp 480w, /assets/img/feishu_docs_static/Kg2sbznoJowPqnxPX0fc4Vaxn2d-800.webp 800w, /assets/img/feishu_docs_static/Kg2sbznoJowPqnxPX0fc4Vaxn2d-1400.webp 1400w, " sizes="95vw" type="image/webp"></source> <img src="/assets/img/feishu_docs_static/Kg2sbznoJowPqnxPX0fc4Vaxn2d.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <ul> <li> <p>slide：</p> <ul> <li><a href="https://0cch.com/uploads/2022/09/c++2022.pdf" rel="external nofollow noopener" target="_blank">https://0cch.com/uploads/2022/09/c++2022.pdf</a></li> <li><a href="https://0cch.com/uploads/2022/11/sycl_coding_practice_and_compilation_design_analysis.pdf" rel="external nofollow noopener" target="_blank">https://0cch.com/uploads/2022/11/sycl_coding_practice_and_compilation_design_analysis.pdf</a></li> </ul> </li> <li> <p>Getting Started with oneAPI DPC++</p> <ul> <li><a href="https://intel.github.io/llvm-docs/GetStartedGuide.html" rel="external nofollow noopener" target="_blank">https://intel.github.io/llvm-docs/GetStartedGuide.html</a></li> </ul> </li> </ul> <h2 id="背景">背景</h2> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/MMizbJ36poSppcxrqhNcMNW0nTf-480.webp 480w, /assets/img/feishu_docs_static/MMizbJ36poSppcxrqhNcMNW0nTf-800.webp 800w, /assets/img/feishu_docs_static/MMizbJ36poSppcxrqhNcMNW0nTf-1400.webp 1400w, " sizes="95vw" type="image/webp"></source> <img src="/assets/img/feishu_docs_static/MMizbJ36poSppcxrqhNcMNW0nTf.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <ul> <li>Intel i7 6700K，但是我们必须意识到其 GPU 的运算能力并不弱。从面积上来 看，GPU 芯片的“占地面积”几乎和 CPU 平分秋色。也就是说，如果我们编写的程序只用到了 CPU 部分， 那么是相当不划算的，因为大量“面积”的计算能力是没有用到的。</li> <li>挑战：相同架构、指令集和语言的程序还比较容易写出来。那么不同架构，不同指令集，不同工具栏，不同语言的程序写起来就相当费劲了，这也是我们写异构程序时面临的重大挑战。</li> </ul> <h3 id="intel-oneapi">Intel oneAPI</h3> <ul> <li>oneAPI 就像操作系统的硬件抽象层，他让程序员不需要了解底层硬件有哪些，分别是什么。作为程序员，我们只需要知道我们的业务逻辑是什么，任务是什么，然后调用框架或者 oneAPI 接口即可。至于怎么和硬件交互，怎么把计算任务给到特定的加速器就不需要程序员关心了。当然了，既然 oneAPI 已经把硬件接管了，那么关于兼容性和移植性这些问题，也都是由 oneAPI 来处理的。</li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/Yf2ObkXMdoXCwgxQ0VXchkTOnPg-480.webp 480w, /assets/img/feishu_docs_static/Yf2ObkXMdoXCwgxQ0VXchkTOnPg-800.webp 800w, /assets/img/feishu_docs_static/Yf2ObkXMdoXCwgxQ0VXchkTOnPg-1400.webp 1400w, " sizes="95vw" type="image/webp"></source> <img src="/assets/img/feishu_docs_static/Yf2ObkXMdoXCwgxQ0VXchkTOnPg.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/XgvmbMt0NoMtL8x7eGycZMobnWd-480.webp 480w, /assets/img/feishu_docs_static/XgvmbMt0NoMtL8x7eGycZMobnWd-800.webp 800w, /assets/img/feishu_docs_static/XgvmbMt0NoMtL8x7eGycZMobnWd-1400.webp 1400w, " sizes="95vw" type="image/webp"></source> <img src="/assets/img/feishu_docs_static/XgvmbMt0NoMtL8x7eGycZMobnWd.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <h2 id="sycl更多的是一个规范">SYCL（更多的是一个规范）</h2> <h3 id="介绍">介绍</h3> <ul> <li> <p><strong>SYCL 是一种用于编程异构系统的开放式行业标准。SYCL 的设计允许编写标准的 C++ 源代码，使其可以在异构设备或主机上运行。【一次编写，到处运行】</strong></p> <ul> <li>SYCL 基于并行 API 或 OpenCL 等标准的基本概念、可移植性和效率，同时增加了单源 C++ 的易用性和灵活性。</li> <li>使用 SYCL 的开发人员能够使用他们习惯的许多技术（如继承和模板）编写标准的现代 C++ 代码。同时，开发人员可以通过 SYCL 库的功能访问底层实现（如 OpenCL）的全部功能，必要时还可以通过 API 与直接使用底层实现编写的代码进行互操作。</li> </ul> </li> <li> <p><strong>SYCL 以几种方式扩展了 OpenCL 模型等标准中的概念，超越了 C++ 特性的一般用途 【使用方式和 C++ 对齐】</strong></p> <ul> <li> <strong>支持使用 C++ 编写内核函数</strong>： 在异构设备上执行并行内核既方便又灵活。常见的并行模式使用简单语法进行优先排序，通过一系列 C++ 类型，程序员可以在需要时表达额外的需求，如同步</li> <li> <strong>RAII 风格</strong>： 当使用缓冲区和访问器时，SYCL 中的数据访问与数据存储分离。通过依赖 C++ 风格的资源获取即初始化（RAII）习惯用法来捕获设备代码块之间的数据依赖关系，运行时库可以跟踪数据移动并提供正确的行为，而无需手动管理内核实例之间的事件依赖关系，也无需程序员显式移动数据。这种方法使数据并行任务图（可能已经是执行模型的一部分）能够由 SYCL 程序员轻松安全地构建；</li> <li> <strong>内存访问方案 1：统一共享内存（USM）</strong>：统一共享内存（USM）为显式数据分配和移动提供了一种机制。这种方法允许在异构设备上使用基于指针的算法和数据结构，并允许跨主机和设备增加代码的重用；</li> </ul> </li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/VF7VbPvD0o8BEpxbzGicoGkZnvf-480.webp 480w, /assets/img/feishu_docs_static/VF7VbPvD0o8BEpxbzGicoGkZnvf-800.webp 800w, /assets/img/feishu_docs_static/VF7VbPvD0o8BEpxbzGicoGkZnvf-1400.webp 1400w, " sizes="95vw" type="image/webp"></source> <img src="/assets/img/feishu_docs_static/VF7VbPvD0o8BEpxbzGicoGkZnvf.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <ul> <li> <strong>内存方案方案 2：缓冲器和访问器</strong>。将数据对象，这里是 vector，作为参数传给 buffer 的构造函数，用于构造 buffer 对象，然后在命令组范围内使用 buffer 构造 accessor，最后才能在 内核函数中使用 accessor 去访问 vector 的数据。值得注意的是，buffer 必须使用一个<strong>作用域</strong>包括起来， 因为 buffer 只有在析构的时候才会将加速设备的数据转移到主机内存中。</li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/YoDzb4xD0owKGixhnOMcGwTNnxg-480.webp 480w, /assets/img/feishu_docs_static/YoDzb4xD0owKGixhnOMcGwTNnxg-800.webp 800w, /assets/img/feishu_docs_static/YoDzb4xD0owKGixhnOMcGwTNnxg-1400.webp 1400w, " sizes="95vw" type="image/webp"></source> <img src="/assets/img/feishu_docs_static/YoDzb4xD0owKGixhnOMcGwTNnxg.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <ul> <li> <strong>并行语法</strong>：分层并行语法提供了一种以易于理解的现代 C++ 形式表达数据并行性的方法，类似于 OpenCL 设备或 OpenMP 目标设备执行模型。它更清晰地分层并行循环和同步点，以避免代码碎片，并更有效地映射到 CPU 风格的架构。</li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/SuWsbqZv5oquTWxX4ivcKGWanzg-480.webp 480w, /assets/img/feishu_docs_static/SuWsbqZv5oquTWxX4ivcKGWanzg-800.webp 800w, /assets/img/feishu_docs_static/SuWsbqZv5oquTWxX4ivcKGWanzg-1400.webp 1400w, " sizes="95vw" type="image/webp"></source> <img src="/assets/img/feishu_docs_static/SuWsbqZv5oquTWxX4ivcKGWanzg.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <h3 id="实例">实例</h3> <ul> <li> <p>一个执行向量加法的内核，在主程序种使用 SYCL 队列和缓冲区将数据传输到 GPU 设备上运行</p> <ul> <li>我们首先为要操作的数据设置主机存储。我们的目标是计算 c = a + b，其中变量是向量。</li> </ul> </li> <li>Host Code</li> <li>Device Code</li> <li>Queue：队列 queue 用于提交命令组(command group)到 SYCL 运行时执行，它是一种将工作(work)提交到设备的机制。一个队列可以映射(map)到一个设备，多个队列(multiple queue)可以映射到同一设备。queue 的成员函数 parallel_for 可以将命令提交到队列，不过这只是一种简化写法，更加完整的写法是调用 submit 函数，submit 函数将提交一个命令组 lambda 表达式，在表达式中命令组对象的成员函数再调用 parallel_for 函数，将内核函数提交给队列。</li> <li>Selector：队列可以将命令提交给设备，但是具体提交给什么设备应该是可以指定的。所以 SYCL 提供了几种方法指定设备，一种是直接指定设备类别，比如 default_selector、cpu_selector、gpu_selector 等，这种选择器都是 SYCL 标准中预设好的。不过这种选择设备的方式也有局限性，因为如果同一类型存在多种不同的设备，上述方式就没有选择。</li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/JAVHbG7DYoEyYjxUvyKc1Rcdnwd-480.webp 480w, /assets/img/feishu_docs_static/JAVHbG7DYoEyYjxUvyKc1Rcdnwd-800.webp 800w, /assets/img/feishu_docs_static/JAVHbG7DYoEyYjxUvyKc1Rcdnwd-1400.webp 1400w, " sizes="95vw" type="image/webp"></source> <img src="/assets/img/feishu_docs_static/JAVHbG7DYoEyYjxUvyKc1Rcdnwd.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <ul> <li>自定义：这个函数中，可以通过参数 device 来获取设备信息，比如类型和名称，然后通过这些信息选择目标设备。比如这里的代码示例，就是选择一个 Intel 的 GPU 设备并返回 100，数值越大优先级越高</li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/KO52bk1pwoYtNoxhCl5cUXtqnXg-480.webp 480w, /assets/img/feishu_docs_static/KO52bk1pwoYtNoxhCl5cUXtqnXg-800.webp 800w, /assets/img/feishu_docs_static/KO52bk1pwoYtNoxhCl5cUXtqnXg-1400.webp 1400w, " sizes="95vw" type="image/webp"></source> <img src="/assets/img/feishu_docs_static/KO52bk1pwoYtNoxhCl5cUXtqnXg.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span><span class="n">include</span> <span class="o">&lt;</span><span class="n">iostream</span><span class="o">&gt;</span>
<span class="o">#</span><span class="n">include</span> <span class="o">&lt;</span><span class="n">CL</span><span class="o">/</span><span class="n">sycl</span><span class="p">.</span><span class="n">hpp</span><span class="o">&gt;</span>

<span class="k">class</span> <span class="n">vector_addition</span><span class="p">;</span>

<span class="nb">int</span> <span class="n">main</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">char</span><span class="o">**</span><span class="p">)</span> <span class="p">{</span>
   <span class="o">//</span> <span class="k">Host</span> <span class="k">Storage</span>
   <span class="o">//</span> <span class="err">我们首先为要操作的数据设置主机存储。我们的目标是计算</span> <span class="k">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="err">，其中变量是向量。</span>
   <span class="n">cl</span><span class="p">::</span><span class="n">sycl</span><span class="p">::</span><span class="n">float4</span> <span class="n">a</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">.</span><span class="mi">0</span> <span class="p">};</span>
   <span class="n">cl</span><span class="p">::</span><span class="n">sycl</span><span class="p">::</span><span class="n">float4</span> <span class="n">b</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">4</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span> <span class="p">};</span>
   <span class="n">cl</span><span class="p">::</span><span class="n">sycl</span><span class="p">::</span><span class="n">float4</span> <span class="k">c</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span> <span class="p">};</span>

   <span class="o">//</span> <span class="err">在</span> <span class="n">SYCL</span> <span class="err">中，有不同的方法来配置和选择我们想要使用的设备。</span> 
   <span class="o">//</span> <span class="n">SYCL</span> <span class="err">提供了一个默认选择器，尝试选择系统中最合适的设备。</span>
   <span class="o">//</span> <span class="err">可以使用自定义选择器，但由于我们只有一台设备，所以我们使用默认选择器。</span>
   <span class="n">cl</span><span class="p">::</span><span class="n">sycl</span><span class="p">::</span><span class="n">default_selector</span> <span class="n">device_selector</span><span class="p">;</span>

   <span class="o">//</span> <span class="err">为了发送要在目标设备上计划和执行的任务，我们需要使用</span> <span class="n">SYCL</span> <span class="err">队列。</span>
   <span class="o">//</span> <span class="err">我们对其进行设置并向其传递我们的选择器，以便它知道在运行任务时选择什么设备。</span>
   <span class="n">cl</span><span class="p">::</span><span class="n">sycl</span><span class="p">::</span><span class="n">queue</span> <span class="n">queue</span><span class="p">(</span><span class="n">device_selector</span><span class="p">);</span>
   <span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="nv">"Running on "</span>
             <span class="o">&lt;&lt;</span> <span class="n">queue</span><span class="p">.</span><span class="n">get_device</span><span class="p">().</span><span class="n">get_info</span><span class="o">&lt;</span><span class="n">cl</span><span class="p">::</span><span class="n">sycl</span><span class="p">::</span><span class="n">info</span><span class="p">::</span><span class="n">device</span><span class="p">::</span><span class="n">name</span><span class="o">&gt;</span><span class="p">()</span>
             <span class="o">&lt;&lt;</span> <span class="nv">"</span><span class="se">\n</span><span class="nv">"</span><span class="p">;</span>
   <span class="p">{</span>
      <span class="o">//</span> <span class="err">发送到设备内存上</span>
      <span class="n">cl</span><span class="p">::</span><span class="n">sycl</span><span class="p">::</span><span class="n">buffer</span><span class="o">&lt;</span><span class="n">cl</span><span class="p">::</span><span class="n">sycl</span><span class="p">::</span><span class="n">float4</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">a_sycl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="n">cl</span><span class="p">::</span><span class="n">sycl</span><span class="p">::</span><span class="k">range</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
      <span class="n">cl</span><span class="p">::</span><span class="n">sycl</span><span class="p">::</span><span class="n">buffer</span><span class="o">&lt;</span><span class="n">cl</span><span class="p">::</span><span class="n">sycl</span><span class="p">::</span><span class="n">float4</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">b_sycl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">,</span> <span class="n">cl</span><span class="p">::</span><span class="n">sycl</span><span class="p">::</span><span class="k">range</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
      <span class="n">cl</span><span class="p">::</span><span class="n">sycl</span><span class="p">::</span><span class="n">buffer</span><span class="o">&lt;</span><span class="n">cl</span><span class="p">::</span><span class="n">sycl</span><span class="p">::</span><span class="n">float4</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">c_sycl</span><span class="p">(</span><span class="o">&amp;</span><span class="k">c</span><span class="p">,</span> <span class="n">cl</span><span class="p">::</span><span class="n">sycl</span><span class="p">::</span><span class="k">range</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
  
      <span class="o">//</span> <span class="err">提交一个</span><span class="n">lambda</span><span class="err">函数，异步执行</span>
      <span class="n">queue</span><span class="p">.</span><span class="n">submit</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">cl</span><span class="p">::</span><span class="n">sycl</span><span class="p">::</span><span class="k">handler</span><span class="o">&amp;</span> <span class="n">cgh</span><span class="p">)</span> <span class="p">{</span>
         <span class="o">//</span> <span class="err">为数据设置权限</span> <span class="k">read</span><span class="p">,</span> <span class="n">discard_write</span>
         <span class="n">auto</span> <span class="n">a_acc</span> <span class="o">=</span> <span class="n">a_sycl</span><span class="p">.</span><span class="n">get_access</span><span class="o">&lt;</span><span class="n">cl</span><span class="p">::</span><span class="n">sycl</span><span class="p">::</span><span class="k">access</span><span class="p">::</span><span class="k">mode</span><span class="p">::</span><span class="k">read</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cgh</span><span class="p">);</span>
         <span class="n">auto</span> <span class="n">b_acc</span> <span class="o">=</span> <span class="n">b_sycl</span><span class="p">.</span><span class="n">get_access</span><span class="o">&lt;</span><span class="n">cl</span><span class="p">::</span><span class="n">sycl</span><span class="p">::</span><span class="k">access</span><span class="p">::</span><span class="k">mode</span><span class="p">::</span><span class="k">read</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cgh</span><span class="p">);</span>
         <span class="n">auto</span> <span class="n">c_acc</span> <span class="o">=</span> <span class="n">c_sycl</span><span class="p">.</span><span class="n">get_access</span><span class="o">&lt;</span><span class="n">cl</span><span class="p">::</span><span class="n">sycl</span><span class="p">::</span><span class="k">access</span><span class="p">::</span><span class="k">mode</span><span class="p">::</span><span class="n">discard_write</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cgh</span><span class="p">);</span>

         <span class="o">//</span> <span class="err">定义了需要在设备上执行的内核函数</span>
         <span class="n">cgh</span><span class="p">.</span><span class="n">single_task</span><span class="o">&lt;</span><span class="k">class</span> <span class="n">vector_addition</span><span class="o">&gt;</span><span class="p">([</span><span class="o">=</span><span class="p">]</span> <span class="p">()</span> <span class="p">{</span>
         <span class="n">c_acc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">a_acc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">b_acc</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
         <span class="p">});</span>
      <span class="p">});</span>
   <span class="p">}</span>
   <span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="nv">"  A { "</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">x</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="nv">", "</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">y</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="nv">", "</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">z</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="nv">", "</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">w</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="nv">" }</span><span class="se">\n</span><span class="nv">"</span>
        <span class="o">&lt;&lt;</span> <span class="nv">"+ B { "</span> <span class="o">&lt;&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">x</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="nv">", "</span> <span class="o">&lt;&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">y</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="nv">", "</span> <span class="o">&lt;&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">z</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="nv">", "</span> <span class="o">&lt;&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">w</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="nv">" }</span><span class="se">\n</span><span class="nv">"</span>
        <span class="o">&lt;&lt;</span> <span class="nv">"------------------</span><span class="se">\n</span><span class="nv">"</span>
        <span class="o">&lt;&lt;</span> <span class="nv">"= C { "</span> <span class="o">&lt;&lt;</span> <span class="k">c</span><span class="p">.</span><span class="n">x</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="nv">", "</span> <span class="o">&lt;&lt;</span> <span class="k">c</span><span class="p">.</span><span class="n">y</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="nv">", "</span> <span class="o">&lt;&lt;</span> <span class="k">c</span><span class="p">.</span><span class="n">z</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="nv">", "</span> <span class="o">&lt;&lt;</span> <span class="k">c</span><span class="p">.</span><span class="n">w</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="nv">" }"</span>
        <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="p">::</span><span class="n">endl</span><span class="p">;</span>
   
   <span class="o">//</span> <span class="n">SYCL</span> <span class="err">的特点之一是它使用</span> <span class="k">C</span><span class="o">++</span> <span class="n">RAII</span><span class="err">（资源获取即初始化）。</span>
   <span class="o">//</span> <span class="err">这意味着没有显式清理，一切都是通过</span> <span class="n">SYCL</span> <span class="err">对象析构函数完成的。</span>

   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="dpcintel-的一个开源项目-扩展了-sycl">DPC++（Intel 的一个开源?项目, 扩展了 SYCL）</h2> <h3 id="代码放置到设备上执行">代码放置到设备上执行</h3> <h4 id="单源代码-在-host-和-device-上执行的代码可以放在同一个源文件中">单源代码: 在 host 和 device 上执行的代码可以放在同一个源文件中</h4> <ul> <li>主机代码：管理数据和管理依赖关系</li> <li> <p>设备代码</p> <ul> <li>异步执行：本质上就是不阻塞主机代码的执行方式</li> <li>内存限制：不支持动态内存分配</li> <li>API 限制：部分函数和查询功能只能在设备代码中使用</li> </ul> </li> <li>动作 Action：把设备代码提交给设备队列的过程叫做 Action，这种动作不只是<strong>代码的执行提交</strong>，还包括<strong>内存数据的移动</strong>。 【这个也太像 Legion 的核心目标了！】</li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/HKBXbtWgvoqpKcxhD3XcIuKPnUh-480.webp 480w, /assets/img/feishu_docs_static/HKBXbtWgvoqpKcxhD3XcIuKPnUh-800.webp 800w, /assets/img/feishu_docs_static/HKBXbtWgvoqpKcxhD3XcIuKPnUh-1400.webp 1400w, " sizes="95vw" type="image/webp"></source> <img src="/assets/img/feishu_docs_static/HKBXbtWgvoqpKcxhD3XcIuKPnUh.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/Ms0ZbC6DZo3WDNx2EIUc6qihntg-480.webp 480w, /assets/img/feishu_docs_static/Ms0ZbC6DZo3WDNx2EIUc6qihntg-800.webp 800w, /assets/img/feishu_docs_static/Ms0ZbC6DZo3WDNx2EIUc6qihntg-1400.webp 1400w, " sizes="95vw" type="image/webp"></source> <img src="/assets/img/feishu_docs_static/Ms0ZbC6DZo3WDNx2EIUc6qihntg.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <h4 id="c-lambda-functions-in-sycl">C++ Lambda Functions in SYCL</h4> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span> <span class="n">capture</span><span class="o">-</span><span class="n">list</span> <span class="p">]</span> <span class="p">(</span> <span class="n">params</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ret</span> <span class="p">{</span> <span class="n">body</span> <span class="p">}</span>
</code></pre></div></div> <ul> <li> <strong>capture-list</strong>： SYCL uses <code class="language-plaintext highlighter-rouge">[=]</code> as kernel does not support capturing variable by reference</li> <li> <strong>params</strong>： In SYCL, it can be unique 1D id, or 2D/3D id</li> <li> <strong>ret</strong>：SYCL kernels must always have a <code class="language-plaintext highlighter-rouge">void</code> return type thus it is not specified in SYCL kernel</li> <li> <strong>body</strong>： SYCL kernel body does not have any <code class="language-plaintext highlighter-rouge">return</code> statement</li> </ul> <h3 id="在任何设备上都可以运行">在任何设备上都可以运行</h3> <ul> <li>当我们不关心我们的设备代码将在哪里运行时，我们可以直接让运行时系统进行选择。</li> <li>如果没有指定队列应该绑定的设备，就会在运行时选择可用的设备，<strong>SYCL 保证至少有一个设备总是可用的，即主机设备本身</strong>。</li> </ul> <h3 id="设备选择接口-selector">设备选择接口 selector</h3> <ul> <li> <p>内置的设备选择接口</p> <ul> <li>default_selector</li> <li>host_selector</li> <li>cpu_selector</li> <li>gpu_selector</li> <li>accelerator_selector</li> <li>DPC++ 提供： ext::intel::fpga_selector</li> </ul> </li> <li> <p>自定义选择器接口</p> <ul> <li>my_selector</li> </ul> </li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;CL/sycl.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sycl/ext/intel/fpga_extensions.hpp&gt;</span><span class="c1"> // For fpga_selector</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">sycl</span><span class="p">;</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">queue</span> <span class="n">my_gpu_queue</span><span class="p">(</span> <span class="n">gpu_selector</span><span class="p">{}</span> <span class="p">);</span>
    <span class="n">queue</span> <span class="nf">my_fpga_queue</span><span class="p">(</span> <span class="n">ext</span><span class="o">::</span><span class="n">intel</span><span class="o">::</span><span class="n">fpga_selector</span><span class="p">{}</span> <span class="p">);</span>
    
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Selected device 1: "</span> <span class="o">&lt;&lt;</span><span class="n">my_gpu_queue</span><span class="p">.</span><span class="n">get_device</span><span class="p">().</span><span class="n">get_info</span><span class="o">&lt;</span><span class="n">info</span><span class="o">::</span><span class="n">device</span><span class="o">::</span><span class="n">name</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Selected device 2: "</span> <span class="o">&lt;&lt;</span><span class="n">my_fpga_queue</span><span class="p">.</span><span class="n">get_device</span><span class="p">().</span><span class="n">get_info</span><span class="o">&lt;</span><span class="n">info</span><span class="o">::</span><span class="n">device</span><span class="o">::</span><span class="n">name</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">my_selector</span> <span class="o">:</span> <span class="k">public</span> <span class="n">device_selector</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">device</span> <span class="o">&amp;</span><span class="n">dev</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">dev</span><span class="p">.</span><span class="n">get_info</span><span class="o">&lt;</span><span class="n">info</span><span class="o">::</span><span class="n">device</span><span class="o">::</span><span class="n">name</span><span class="o">&gt;</span><span class="p">().</span><span class="n">find</span><span class="p">(</span><span class="s">"Arria"</span><span class="p">)</span><span class="o">!=</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">npos</span> <span class="o">&amp;&amp;</span>
            <span class="n">dev</span><span class="p">.</span><span class="n">get_info</span><span class="o">&lt;</span><span class="n">info</span><span class="o">::</span><span class="n">device</span><span class="o">::</span><span class="n">vendor</span><span class="o">&gt;</span><span class="p">().</span><span class="n">find</span><span class="p">(</span><span class="s">"Intel"</span><span class="p">)</span><span class="o">!=</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">npos</span>
        <span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <h2 id="任务流图调度">任务流图调度</h2> <h3 id="核心要素-actiondependence">核心要素: Action+Dependence</h3> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/WQwwb48VNoYlxmxGBXlcsYISn2d-480.webp 480w, /assets/img/feishu_docs_static/WQwwb48VNoYlxmxGBXlcsYISn2d-800.webp 800w, /assets/img/feishu_docs_static/WQwwb48VNoYlxmxGBXlcsYISn2d-1400.webp 1400w, " sizes="95vw" type="image/webp"></source> <img src="/assets/img/feishu_docs_static/WQwwb48VNoYlxmxGBXlcsYISn2d.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <h3 id="命令组-command-group--actiondependence">命令组 Command Group = Action+Dependence+…</h3> <ul> <li> <p>Command Group 包含的内容</p> <ul> <li>Action</li> <li>Dependence：当某个 kernel 的依赖关系被满足，kernel 就会被执行</li> <li>其他主机代码</li> </ul> </li> <li> <p>Command Group 会在 Host 上被执行，在提交到队列的时候执行，且只会执行一次。</p> </li> </ul> <h4 id="action">Action</h4> <ul> <li>Device Code Execution（就是 Kernel）：通过 parallel_for 或 single_task 将工作提交到 device 的工作队列中</li> <li>Explicit Memory Operation（显式内存操作）：USM 的 memcpy, memset, fill 操作、 缓冲区的 copy, fill, update_host 操作</li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/NUukbq5l3oLSxVxdgTgcelznnTG-480.webp 480w, /assets/img/feishu_docs_static/NUukbq5l3oLSxVxdgTgcelznnTG-800.webp 800w, /assets/img/feishu_docs_static/NUukbq5l3oLSxVxdgTgcelznnTG-1400.webp 1400w, " sizes="95vw" type="image/webp"></source> <img src="/assets/img/feishu_docs_static/NUukbq5l3oLSxVxdgTgcelznnTG.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <h4 id="dependence-顺序队列和-waitdepends_on-和-accessor-隐式指定">Dependence: 顺序队列和 wait+depends_on 和 accessor 隐式指定</h4> <ul> <li>顺序队列：左图</li> <li>wait+depends_on，但是用 wait()和 depends_on()表示执行依赖：右图</li> <li> <p>accessor 隐式指定数据依赖</p> <ul> <li>Read After Write：B 任务需要依赖于 A 任务计算得到的结果，此时会出现隐式的数据依赖</li> <li>Write After Read：当 A 任务读取了某个数据，可能执行还没结束的时候，B 任务需要写这个数据，此时会有隐式的数据依赖</li> <li>Write After Write：当 A 任务在写某个数据的时候，B 任务也需要写某个数据</li> </ul> </li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/TwRDbpT1VooHLNxcVDWczLNPnRd-480.webp 480w, /assets/img/feishu_docs_static/TwRDbpT1VooHLNxcVDWczLNPnRd-800.webp 800w, /assets/img/feishu_docs_static/TwRDbpT1VooHLNxcVDWczLNPnRd-1400.webp 1400w, " sizes="95vw" type="image/webp"></source> <img src="/assets/img/feishu_docs_static/TwRDbpT1VooHLNxcVDWczLNPnRd.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/KtKkbZtQso2mWCxxagacG6jSnfd-480.webp 480w, /assets/img/feishu_docs_static/KtKkbZtQso2mWCxxagacG6jSnfd-800.webp 800w, /assets/img/feishu_docs_static/KtKkbZtQso2mWCxxagacG6jSnfd-1400.webp 1400w, " sizes="95vw" type="image/webp"></source> <img src="/assets/img/feishu_docs_static/KtKkbZtQso2mWCxxagacG6jSnfd.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <h3 id="和-host-同步方案">和 host 同步方案</h3> <ul> <li>方案 1：阻塞等待队列的完成 Q.wait() 和 Q.wait_and_throw()</li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/OMjybf1bEoPt2uxiUZ7cuxJ9nvb-480.webp 480w, /assets/img/feishu_docs_static/OMjybf1bEoPt2uxiUZ7cuxJ9nvb-800.webp 800w, /assets/img/feishu_docs_static/OMjybf1bEoPt2uxiUZ7cuxJ9nvb-1400.webp 1400w, " sizes="95vw" type="image/webp"></source> <img src="/assets/img/feishu_docs_static/OMjybf1bEoPt2uxiUZ7cuxJ9nvb.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <ul> <li>方案 2：对事件进行同步，允许程序在特定的命令组上同步</li> <li>方案 3：使用 host_accessor，确保被复制回 host 的数据是 device 计算完成后的数值</li> <li>方案 4（少见）：使用缓冲区的属性 use_mutex 进行信号量同步</li> </ul> <h2 id="数据管理">数据管理</h2> <ul> <li> <p>三种管理方式</p> <ul> <li>统一共享内存 Unified Shared Memory, USM：基于指针管理，支持 USM 的设备会有统一的虚拟地址空间，任何 host 上的 USM 动态内存分配函数返回的指针可以被 device 访问</li> </ul> </li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/BYhPbnXHEoX7KdxwxyWcYnLknXb-480.webp 480w, /assets/img/feishu_docs_static/BYhPbnXHEoX7KdxwxyWcYnLknXb-800.webp 800w, /assets/img/feishu_docs_static/BYhPbnXHEoX7KdxwxyWcYnLknXb-1400.webp 1400w, " sizes="95vw" type="image/webp"></source> <img src="/assets/img/feishu_docs_static/BYhPbnXHEoX7KdxwxyWcYnLknXb.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <ul> <li>缓冲区【Legion 的数据访问方式，但是没有 Legion 那么优秀】：代表一个或者多个 C++ 类型的对象，可以是标量数据（int、float、double），向量数据，用户定义的 struct。 缓冲区变量不是具体的内存地址，需要用 accessor 对象进行访问</li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/WF8qbZL6romP3gxCQtocGwmVnSc-480.webp 480w, /assets/img/feishu_docs_static/WF8qbZL6romP3gxCQtocGwmVnSc-800.webp 800w, /assets/img/feishu_docs_static/WF8qbZL6romP3gxCQtocGwmVnSc-1400.webp 1400w, " sizes="95vw" type="image/webp"></source> <img src="/assets/img/feishu_docs_static/WF8qbZL6romP3gxCQtocGwmVnSc.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <ul> <li>Images：专门用于图像处理的缓冲区管理</li> <li> <p>存储器的管理方式</p> <ul> <li>显式管理</li> <li>运行时隐式管理：由运行时系统自动完成，可以保证正确性。 缺点：性能差</li> </ul> </li> </ul> <h3 id="统一共享内存-unified-shared-memory-usm">统一共享内存 Unified Shared Memory, USM</h3> <ul> <li> <p>三种方式</p> <ul> <li>设备分配：直接在 device 上分配空间，host 无法访问，如果 host 需要这些数据需要使用 USM 的 memcpy 复制过来</li> <li>主机分配：在主机的内存中分配空间，host 和 device 都可以直接访问，但是不能直接迁移到 device 的存储器中，device 的访问是远程内进行的，通常需要经过 PCI-E 总线</li> <li>共享分配：可以被 host 和 device 访问，自行进行数据迁移，但是自动数据迁移会有延迟</li> </ul> </li> <li> <p>C 风格内存分配：分配完后得到 void*类型的数据，然后再进行强制类型转换</p> <ul> <li>malloc_device =&gt; aligned_alloc_device(用于返回对齐的内存指针)</li> <li>malloc_host =&gt; aligned_alloc_host</li> <li>malloc_shared =&gt; aligned_alloc_shared</li> </ul> </li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/BCFLbU6H3o6OLBxeYNOcXN0ynof-480.webp 480w, /assets/img/feishu_docs_static/BCFLbU6H3o6OLBxeYNOcXN0ynof-800.webp 800w, /assets/img/feishu_docs_static/BCFLbU6H3o6OLBxeYNOcXN0ynof-1400.webp 1400w, " sizes="95vw" type="image/webp"></source> <img src="/assets/img/feishu_docs_static/BCFLbU6H3o6OLBxeYNOcXN0ynof.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <ul> <li> <p>C++ 风格内存分配：可以使用模板函数，返回的是对应类型的指针</p> <ul> <li>支持 C++ allocator 进行内存释放</li> </ul> </li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/L6cXbWRT7o8rwdx4xxRcKcSYnHc-480.webp 480w, /assets/img/feishu_docs_static/L6cXbWRT7o8rwdx4xxRcKcSYnHc-800.webp 800w, /assets/img/feishu_docs_static/L6cXbWRT7o8rwdx4xxRcKcSYnHc-1400.webp 1400w, " sizes="95vw" type="image/webp"></source> <img src="/assets/img/feishu_docs_static/L6cXbWRT7o8rwdx4xxRcKcSYnHc.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <ul> <li> <p>数据初始化</p> <ul> <li>Memset</li> <li>Fill</li> </ul> </li> <li> <p>数据移动</p> <ul> <li>显式数据移动：memcpy</li> <li>隐式数据移动：</li> </ul> </li> </ul> <h3 id="缓冲区">缓冲区</h3> <ul> <li>核心思想：本身只能代表数据，如何管理数据（存储和移动）都是运行时的工作</li> <li> <p>创建缓冲区</p> <ul> <li>直接创建</li> </ul> </li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/XlmybzwVQoOKp9x6Cdxc32r6n9c-480.webp 480w, /assets/img/feishu_docs_static/XlmybzwVQoOKp9x6Cdxc32r6n9c-800.webp 800w, /assets/img/feishu_docs_static/XlmybzwVQoOKp9x6Cdxc32r6n9c-1400.webp 1400w, " sizes="95vw" type="image/webp"></source> <img src="/assets/img/feishu_docs_static/XlmybzwVQoOKp9x6Cdxc32r6n9c.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <ul> <li>从标量数组创建</li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/RJxqbHmG5owlwFxmogocIrhbnTv-480.webp 480w, /assets/img/feishu_docs_static/RJxqbHmG5owlwFxmogocIrhbnTv-800.webp 800w, /assets/img/feishu_docs_static/RJxqbHmG5owlwFxmogocIrhbnTv-1400.webp 1400w, " sizes="95vw" type="image/webp"></source> <img src="/assets/img/feishu_docs_static/RJxqbHmG5owlwFxmogocIrhbnTv.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <ul> <li>从 vector 创建</li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/QlIob1D5mo5R9MxXM9mcXqcinBh-480.webp 480w, /assets/img/feishu_docs_static/QlIob1D5mo5R9MxXM9mcXqcinBh-800.webp 800w, /assets/img/feishu_docs_static/QlIob1D5mo5R9MxXM9mcXqcinBh-1400.webp 1400w, " sizes="95vw" type="image/webp"></source> <img src="/assets/img/feishu_docs_static/QlIob1D5mo5R9MxXM9mcXqcinBh.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <ul> <li>使用缓冲区数据 Accessor：无法直接使用缓冲区的数据，必须定义对应数据的 accessor 才可以继续使用 <ul> <li>为 Accessor 设置访问标记：read_write, read_only, write_only, read_constant</li> </ul> </li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/UKUkbGJ1HoWtHUx1EbRcYHmHn3f-480.webp 480w, /assets/img/feishu_docs_static/UKUkbGJ1HoWtHUx1EbRcYHmHn3f-800.webp 800w, /assets/img/feishu_docs_static/UKUkbGJ1HoWtHUx1EbRcYHmHn3f-1400.webp 1400w, " sizes="95vw" type="image/webp"></source> <img src="/assets/img/feishu_docs_static/UKUkbGJ1HoWtHUx1EbRcYHmHn3f.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/Jw8bbR7xOoBFC0xb5hcc0Pp2nKf-480.webp 480w, /assets/img/feishu_docs_static/Jw8bbR7xOoBFC0xb5hcc0Pp2nKf-800.webp 800w, /assets/img/feishu_docs_static/Jw8bbR7xOoBFC0xb5hcc0Pp2nKf-1400.webp 1400w, " sizes="95vw" type="image/webp"></source> <img src="/assets/img/feishu_docs_static/Jw8bbR7xOoBFC0xb5hcc0Pp2nKf.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <h2 id="kernel-的三种表达方式">Kernel 的三种表达方式</h2> <h3 id="基本数据并行-spmd单程序多数据流">基本数据并行 SPMD(单程序多数据流)</h3> <ul> <li>基本的数据并行 kernel 的功能是通过三个 C++ 类表示的：<code class="language-plaintext highlighter-rouge">range</code>、<code class="language-plaintext highlighter-rouge">id</code> 和 <code class="language-plaintext highlighter-rouge">item</code> <ul> <li>range 表示一个一维、二维或三维的范围，维度需要在编译期确定，但每个维度的大小可以是动态的</li> <li>id 表示一个一维、二维或三维范围内的索引。尽管我们可以构造一个 id 来代表一个任意的索引，但为了获得与特定 kernel 实例相关的索引，我们必须将其作为 kernel 函数的一个参数。</li> <li>item 代表了一个 kernel 函数的单个实例，同时封装了其执行范围和实例在该范围内的索引。和 id 的主要区别在于 item 给出了额外的函数来查询范围与线性化的索引。</li> </ul> </li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/BKLjb8Aw7o0aT4xjabSc1H3znzl-480.webp 480w, /assets/img/feishu_docs_static/BKLjb8Aw7o0aT4xjabSc1H3znzl-800.webp 800w, /assets/img/feishu_docs_static/BKLjb8Aw7o0aT4xjabSc1H3znzl-1400.webp 1400w, " sizes="95vw" type="image/webp"></source> <img src="/assets/img/feishu_docs_static/BKLjb8Aw7o0aT4xjabSc1H3znzl.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/K2UZbUHYFox9ZuxniL5cfyhPnc7-480.webp 480w, /assets/img/feishu_docs_static/K2UZbUHYFox9ZuxniL5cfyhPnc7-800.webp 800w, /assets/img/feishu_docs_static/K2UZbUHYFox9ZuxniL5cfyhPnc7-1400.webp 1400w, " sizes="95vw" type="image/webp"></source> <img src="/assets/img/feishu_docs_static/K2UZbUHYFox9ZuxniL5cfyhPnc7.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/VowSb2lyQoz7Dpxl9TEca3DYnph-480.webp 480w, /assets/img/feishu_docs_static/VowSb2lyQoz7Dpxl9TEca3DYnph-800.webp 800w, /assets/img/feishu_docs_static/VowSb2lyQoz7Dpxl9TEca3DYnph-1400.webp 1400w, " sizes="95vw" type="image/webp"></source> <img src="/assets/img/feishu_docs_static/VowSb2lyQoz7Dpxl9TEca3DYnph.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/DoocbW5m4oM4qdxGgVgc5uk9n0b-480.webp 480w, /assets/img/feishu_docs_static/DoocbW5m4oM4qdxGgVgc5uk9n0b-800.webp 800w, /assets/img/feishu_docs_static/DoocbW5m4oM4qdxGgVgc5uk9n0b-1400.webp 1400w, " sizes="95vw" type="image/webp"></source> <img src="/assets/img/feishu_docs_static/DoocbW5m4oM4qdxGgVgc5uk9n0b.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <h3 id="nd-range-数据并行">ND-range 数据并行</h3> <ul> <li>三种划分方式 <ul> <li>Work-group：表示一个 kernel 函数的实例，可以按任何顺序执行，除了对全局内存的原子内存操作外，不能相互通信或同步。每个 work-group 中的 work-item 可以访问 work-group 的本地内存，可以映射到一些设备上的本地存储器，可以用 work-group barriers 进行同步。<strong>[同一 work-group 内的 work-item 可以保证同时执行，不同 work-group 内的 work-item 不能保证同时执行]</strong> </li> <li>Sub-group：用于进一步的局部调度，可以使用编译器向量化的功能使得 sub-group 内的 work-item 并行执行，sub-group 没有自己的本地内存，可以用 shuffle 操作直接交换数据</li> <li>work-items：</li> </ul> </li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/KxRxbXb57oxxQ2xRzV2clkvAnKb-480.webp 480w, /assets/img/feishu_docs_static/KxRxbXb57oxxQ2xRzV2clkvAnKb-800.webp 800w, /assets/img/feishu_docs_static/KxRxbXb57oxxQ2xRzV2clkvAnKb-1400.webp 1400w, " sizes="95vw" type="image/webp"></source> <img src="/assets/img/feishu_docs_static/KxRxbXb57oxxQ2xRzV2clkvAnKb.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/Al53bEE32ogJURxIbbJcnl5wnRf-480.webp 480w, /assets/img/feishu_docs_static/Al53bEE32ogJURxIbbJcnl5wnRf-800.webp 800w, /assets/img/feishu_docs_static/Al53bEE32ogJURxIbbJcnl5wnRf-1400.webp 1400w, " sizes="95vw" type="image/webp"></source> <img src="/assets/img/feishu_docs_static/Al53bEE32ogJURxIbbJcnl5wnRf.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <h3 id="分层数据并行不太详细">分层数据并行(不太详细)</h3> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/BdxvbRdQwoxnPhxjs2qcey87nhd-480.webp 480w, /assets/img/feishu_docs_static/BdxvbRdQwoxnPhxjs2qcey87nhd-800.webp 800w, /assets/img/feishu_docs_static/BdxvbRdQwoxnPhxjs2qcey87nhd-1400.webp 1400w, " sizes="95vw" type="image/webp"></source> <img src="/assets/img/feishu_docs_static/BdxvbRdQwoxnPhxjs2qcey87nhd.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <h2 id="通信与同步-针对-nd-range-数据并行">通信与同步: 针对 ND-range 数据并行</h2> <h3 id="基于-barrier-确保-work-group-内的-work-item-的同步">基于 Barrier 确保 work-group 内的 work-item 的同步</h3> <ul> <li>同一个 work-group 内的四个 work-items 通过 barrier 进行同步，尽管每个 work-item 的执行时间可能不同，但 没有任何 work-item 可以跨过 Barrier 执行，直到所有 work-item 都遇到了 Barrier。执行 Barrier 功能之后，所有工作 项就有了一致的内存。</li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/LDRabw0phooS5OxezqjcqSA1nQb-480.webp 480w, /assets/img/feishu_docs_static/LDRabw0phooS5OxezqjcqSA1nQb-800.webp 800w, /assets/img/feishu_docs_static/LDRabw0phooS5OxezqjcqSA1nQb-1400.webp 1400w, " sizes="95vw" type="image/webp"></source> <img src="/assets/img/feishu_docs_static/LDRabw0phooS5OxezqjcqSA1nQb.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <h3 id="基于-work-group-的本地内存进行同步">基于 Work-group 的本地内存进行同步</h3> <ul> <li>通信可以通过 USM 或缓冲区进行，但可能效率不高，因而可以专门划分一部分内存用于通信，作为 work-group 的本地内存。</li> <li>每个 work-group 都可以访问全局内存或自己的本地内存</li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/YBMwb79mmoHy8mx95y5cV1GhnZt-480.webp 480w, /assets/img/feishu_docs_static/YBMwb79mmoHy8mx95y5cV1GhnZt-800.webp 800w, /assets/img/feishu_docs_static/YBMwb79mmoHy8mx95y5cV1GhnZt-1400.webp 1400w, " sizes="95vw" type="image/webp"></source> <img src="/assets/img/feishu_docs_static/YBMwb79mmoHy8mx95y5cV1GhnZt.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> </article> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2024 Linchang Xiao. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?7b30caa5023af4af8408a472dc4e1ebb"></script> <script defer src="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js?d633890033921b33e0ceb13d22340a9c"></script> <script defer src="/assets/js/common.js?acdb9690d7641b2f8d40529018c71a01"></script> <script defer src="/assets/js/copy_code.js?9b43d6e67ddc7c0855b1478ee4c48c2d" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>