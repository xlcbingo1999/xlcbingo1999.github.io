<!DOCTYPE html> <html lang="cn"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>C++/Go算法学习 | Linchang Xiao</title> <meta name="author" content="Linchang Xiao"> <meta name="description" content="C++/Go算法学习 - 整个文档偏算法"> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?19f3075a2d19613090fe9e16b564e1fe" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/icon.jpg?7b7b29ac9f6063e03543e5148578c7f5"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://xlcbingo1999.github.io/blog/2023/cpp-go-learning/"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?e74e74bf055e5729d44a7d031a5ca6a5" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?6185d15ea1982787ad7f435576553d64"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/">Linchang Xiao</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about</a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">blog</a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fa-solid fa-moon"></i> <i class="fa-solid fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">C++/Go算法学习</h1> <p class="post-meta">March 30, 2023</p> <p class="post-tags"> <a href="/blog/2023"> <i class="fa-solid fa-calendar fa-sm"></i> 2023 </a>   ·   <a href="/blog/tag/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%AE%B0"> <i class="fa-solid fa-hashtag fa-sm"></i> 技术杂记</a>     ·   <a href="/blog/category/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%AE%B0"> <i class="fa-solid fa-tag fa-sm"></i> 技术杂记</a>   </p> </header> <article class="post-content"> <div id="markdown-content"> <h2 id="c-基础">C++ 基础</h2> <h3 id="class-中的变量权限">class 中的变量权限</h3> <ul> <li>类的一个特征就是<strong>封装</strong>，public 和 private 作用就是实现这一目的。类的另一个特征就是<strong>继承</strong>，protected 的作用就是实现这一目的 <ul> <li>public：用户代码（类外）可以访问 public 成员而不能访问 private 成员</li> <li>protected：protected 成员可以被派生类对象访问，不能被用户代码（类外）访问</li> <li>private：private 成员只能由类成员（类内）和友元访问。</li> </ul> </li> </ul> <h3 id="inline">inline</h3> <h3 id="c-中的函数调用">C++ 中的函数调用</h3> <ul> <li>当程序执行函数调用指令时，CPU 将存储该函数调用后指令的内存地址，将函数的参数复制到堆栈上，最后将控制权转移到指定的函数。然后，CPU 执行函数代码，将函数返回值存储在预定义的内存位置/寄存器中，并将控制权返回给调用函数。</li> <li> <p>时间消耗分析</p> <ul> <li>调用者函数到被调用者的切换时间</li> <li>函数执行时间</li> </ul> </li> </ul> <h2 id="cmake">CMake</h2> <h3 id="cmake-通常的-build-和编译位置">CMake 通常的 build 和编译位置</h3> <ul> <li>参考文献：<a href="https://blog.csdn.net/shaoyou223/article/details/84764633" rel="external nofollow noopener" target="_blank">https://blog.csdn.net/shaoyou223/article/details/84764633</a> </li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mkdir</span> <span class="n">build</span>
<span class="n">cd</span> <span class="n">build</span>
<span class="n">cmake</span> <span class="p">..</span>
<span class="n">make</span>
</code></pre></div></div> <h3 id="ubuntu-安装-cmake">Ubuntu 安装 CMake</h3> <ul> <li>参考文献：<a href="https://askubuntu.com/questions/355565/how-do-i-install-the-latest-version-of-cmake-from-the-command-line" rel="external nofollow noopener" target="_blank">https://askubuntu.com/questions/355565/how-do-i-install-the-latest-version-of-cmake-from-the-command-line</a> </li> <li>需要安装新版的 CMake 的时候就需要用这个文章里提到的方法</li> </ul> <h3 id="cmakelists-的编写规则">CMakelists 的编写规则</h3> <ul> <li>号称是全网最全的规则：<a href="https://zhuanlan.zhihu.com/p/534439206" rel="external nofollow noopener" target="_blank">https://zhuanlan.zhihu.com/p/534439206</a> </li> </ul> <h3 id="fetchcontent-依赖库">FetchContent 依赖库</h3> <ul> <li>参考文献：<a href="https://juejin.cn/post/7102762548423819272" rel="external nofollow noopener" target="_blank">https://juejin.cn/post/7102762548423819272</a> </li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp"># FetchContent 模块用于获取外部依赖库, 在构建生成文件的过程中被调用
</span><span class="n">include</span><span class="p">(</span><span class="n">FetchContent</span><span class="p">)</span>
<span class="cp"># FetchContent_Declare 描述如何下载依赖库
</span><span class="n">FetchContent_Declare</span><span class="p">(</span>
    <span class="n">pybind11</span>
    <span class="n">GIT_REPOSITORY</span> <span class="n">https</span><span class="o">:</span><span class="c1">//github.com/pybind/pybind11.git</span>
    <span class="n">GIT_TAG</span>        <span class="n">v2</span><span class="mf">.6.2</span>
    <span class="n">GIT_SHALLOW</span>    <span class="n">TRUE</span>
<span class="p">)</span>
<span class="cp"># FetchContent_MakeAvaliable 下载依赖库, 并使其可用
</span><span class="n">FetchContent_MakeAvailable</span><span class="p">(</span><span class="n">pybind11</span><span class="p">)</span>
</code></pre></div></div> <h3 id="cmake-的多版本共存">CMake 的多版本共存</h3> <ul> <li>请不要直接删除 cmake，可能会导致一些文件被删除</li> <li>多版本共存 CMake 参考文献：<a href="https://zhuanlan.zhihu.com/p/442561052" rel="external nofollow noopener" target="_blank">https://zhuanlan.zhihu.com/p/442561052</a> </li> </ul> <h2 id="makefile">Makefile</h2> <h2 id="pybind">Pybind</h2> <ul> <li>快速实现 C/C++ 和 Python 的互通 参考文献：<a href="https://www.jianshu.com/p/0b4b49dd706a" rel="external nofollow noopener" target="_blank">https://www.jianshu.com/p/0b4b49dd706a</a> </li> <li>比较复杂的教程，可以实现使用 python 调用 C++ 写的有关 numpy 的算子【来自论文 ELSED: Enhanced Line SEgment Drawing】：<a href="https://www.guyuehome.com/38198" rel="external nofollow noopener" target="_blank">https://www.guyuehome.com/38198</a> </li> </ul> <h2 id="c-虚函数表">C++ 虚函数表</h2> <ul> <li>参考文献：<a href="https://www.cnblogs.com/Mered1th/p/10924545.html" rel="external nofollow noopener" target="_blank">https://www.cnblogs.com/Mered1th/p/10924545.html</a> </li> <li> <p>单继承</p> <ul> <li>虚表中派生类覆盖的虚函数的地址被放在了基类相应的函数原来的位置</li> <li>派生类没有覆盖的虚函数就延用基类的。同时，虚函数按照其声明顺序放于表中，父类的虚函数在子类的虚函数前面。</li> </ul> </li> <li> <p>多继承</p> <ul> <li>每个基类都有自己的虚函数表</li> <li>派生类的虚函数地址存依照声明顺序放在第一个基类的虚表最后</li> </ul> </li> </ul> <h2 id="字符串">字符串</h2> <h3 id="字符串截取下标段">字符串截取下标段</h3> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">string</span> <span class="k">month</span> <span class="o">=</span> <span class="n">time_s</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="n">string</span> <span class="k">day</span> <span class="o">=</span> <span class="n">time_s</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
</code></pre></div></div> <h3 id="stoi-和-to_string">stoi 和 to_string</h3> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">int</span> <span class="n">month_n</span> <span class="o">=</span> <span class="n">stoi</span><span class="p">(</span><span class="k">month</span><span class="p">);</span>
<span class="nb">int</span> <span class="n">day_n</span> <span class="o">=</span> <span class="n">stoi</span><span class="p">(</span><span class="k">day</span><span class="p">);</span>

<span class="n">string</span> <span class="k">month</span> <span class="o">=</span> <span class="n">to_string</span><span class="p">(</span><span class="n">month_n</span><span class="p">);</span>
</code></pre></div></div> <h2 id="数组相关问题">数组相关问题</h2> <h3 id="一维数组的排序">一维数组的排序</h3> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">int</span> <span class="n">time_arr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">arriveAlice_n</span><span class="p">,</span> <span class="n">leaveAlice_n</span><span class="p">,</span> <span class="n">arriveBob_n</span><span class="p">,</span> <span class="n">leaveBob_n</span><span class="p">};</span>
<span class="n">sort</span><span class="p">(</span><span class="n">time_arr</span><span class="p">,</span> <span class="n">time_arr</span><span class="o">+</span><span class="mi">4</span><span class="p">);</span>
</code></pre></div></div> <h3 id="前缀和刷题框架">前缀和刷题框架</h3> <ul> <li>一维前缀和</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">NumArray</span> <span class="p">{</span>
    <span class="c1">// 前缀和数组</span>
    <span class="k">private</span> <span class="kt">int</span><span class="p">[]</span> <span class="n">preSum</span><span class="p">;</span>

    <span class="cm">/* 输入一个数组，构造前缀和 */</span>
    <span class="k">public</span> <span class="n">NumArray</span><span class="p">(</span><span class="kt">int</span><span class="p">[]</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// preSum[0] = 0，便于计算累加和</span>
        <span class="c1">// 这里是多增加了一个item, 主要是避免条件判断</span>
        <span class="n">preSum</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">nums</span><span class="p">.</span><span class="n">length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
        <span class="c1">// 计算 nums 的累加和</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">preSum</span><span class="p">.</span><span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">preSum</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">preSum</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="cm">/* 查询闭区间 [left, right] 的累加和 */</span>
    <span class="c1">// 这个函数调用次数很多, 应该尽量避免条件判断和遍历</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="nf">sumRange</span><span class="p">(</span><span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span> 
        <span class="k">return</span> <span class="n">preSum</span><span class="p">[</span><span class="n">right</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">preSum</span><span class="p">[</span><span class="n">left</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <ul> <li>二维前缀和</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">NumMatrix</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">NumMatrix</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">matrix</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">new_vec</span> <span class="o">=</span> <span class="p">{};</span>
        <span class="k">this</span><span class="o">-&gt;</span><span class="n">presum</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">new_vec</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="o">-&gt;</span><span class="n">presum</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="p">}</span>
        
        
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">matrix</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">new_vec</span> <span class="o">=</span> <span class="p">{};</span>
            <span class="k">this</span><span class="o">-&gt;</span><span class="n">presum</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">new_vec</span><span class="p">);</span>
            <span class="k">this</span><span class="o">-&gt;</span><span class="n">presum</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// 很重要的计算方式</span>
                <span class="k">this</span><span class="o">-&gt;</span><span class="n">presum</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span>
                    <span class="k">this</span><span class="o">-&gt;</span><span class="n">presum</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">presum</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">presum</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="p">);</span>
                <span class="c1">// cout &lt;&lt; "presum[" &lt;&lt; i &lt;&lt; "][" &lt;&lt; j &lt;&lt; "]: " &lt;&lt; this-&gt;presum[i][j] &lt;&lt; endl;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="kt">int</span> <span class="nf">sumRegion</span><span class="p">(</span><span class="kt">int</span> <span class="n">row1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">col1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">row2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">col2</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// cout &lt;&lt; "this-&gt;presum[row2+1][col2+1]: " &lt;&lt; this-&gt;presum[row2+1][col2+1] &lt;&lt; "; this-&gt;presum[row2+1][col1+1]: " &lt;&lt; this-&gt;presum[row2+1][col1+1]</span>
        <span class="c1">//     &lt;&lt; "; this-&gt;presum[row1+1][col2+1]: " &lt;&lt; this-&gt;presum[row1+1][col2+1] &lt;&lt; "; this-&gt;presum[row1+1][col1+1]: " &lt;&lt; this-&gt;presum[row1+1][col1+1] &lt;&lt; endl; </span>
        <span class="c1">// 很重要的计算方式</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">presum</span><span class="p">[</span><span class="n">row2</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">col2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">presum</span><span class="p">[</span><span class="n">row2</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">col1</span><span class="p">]</span> <span class="o">-</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">presum</span><span class="p">[</span><span class="n">row1</span><span class="p">][</span><span class="n">col2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">presum</span><span class="p">[</span><span class="n">row1</span><span class="p">][</span><span class="n">col1</span><span class="p">];</span>
    <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">presum</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="前缀和-vector-实现1">前缀和-vector 实现（1）</h3> <ul> <li>这是一个常见的算法，可以在只遍历一次的情况下，计算多个区间的统计信息。</li> <li> <p>方案</p> <ul> <li>设置一个前缀和数组 arr，位置 i+1 存储的是第 0 个元素到第 i 个元素的求和（或者其他统计信息）</li> <li>最后计算方案：arr[r+1] - arr[l]</li> </ul> </li> <li>Leetcode 2559</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">bool</span> <span class="n">isYuan</span><span class="p">(</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">word</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">bool</span> <span class="n">result</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">last_index</span> <span class="o">=</span> <span class="n">word</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">word</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">'a'</span> <span class="o">&amp;&amp;</span> <span class="n">word</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">'e'</span> <span class="o">&amp;&amp;</span> <span class="n">word</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">'i'</span> <span class="o">&amp;&amp;</span> <span class="n">word</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">'o'</span> <span class="o">&amp;&amp;</span> <span class="n">word</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">'u'</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">result</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">word</span><span class="p">[</span><span class="n">last_index</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">'a'</span> <span class="o">&amp;&amp;</span> <span class="n">word</span><span class="p">[</span><span class="n">last_index</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">'e'</span> <span class="o">&amp;&amp;</span> <span class="n">word</span><span class="p">[</span><span class="n">last_index</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">'i'</span> <span class="o">&amp;&amp;</span> <span class="n">word</span><span class="p">[</span><span class="n">last_index</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">'o'</span> <span class="o">&amp;&amp;</span> <span class="n">word</span><span class="p">[</span><span class="n">last_index</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">'u'</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">result</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vowelStrings</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">words</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">queries</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">num_v</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
        <span class="kt">int</span> <span class="n">len_num_v</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">word</span><span class="o">:</span> <span class="n">words</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">isYuan</span><span class="p">(</span><span class="n">word</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">num_v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">num_v</span><span class="p">[</span><span class="n">len_num_v</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">num_v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">num_v</span><span class="p">[</span><span class="n">len_num_v</span><span class="o">-</span><span class="mi">1</span><span class="p">]);</span>
            <span class="p">}</span>
            <span class="n">len_num_v</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="p">{};</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">pair</span><span class="o">:</span> <span class="n">queries</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">num_v</span><span class="p">[</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">num_v</span><span class="p">[</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]]);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="前缀和-stack-实现2">前缀和-stack 实现（2）</h3> <ul> <li>leetcode：<a href="https://leetcode.cn/problems/remove-zero-sum-consecutive-nodes-from-linked-list/submissions/" rel="external nofollow noopener" target="_blank">https://leetcode.cn/problems/remove-zero-sum-consecutive-nodes-from-linked-list/submissions/</a> </li> <li>方案：用 stack 可以实现一个在线维护更新的前缀和，可以通过 pop 操作将中间的一些情况给删除掉</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">struct</span> <span class="nc">ListNode</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
    <span class="n">ListNode</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
    <span class="n">ListNode</span><span class="p">()</span> <span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">next</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">ListNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">next</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">ListNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">ListNode</span> <span class="o">*</span><span class="n">next</span><span class="p">)</span> <span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">next</span><span class="p">(</span><span class="n">next</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>

    <span class="kt">void</span> <span class="n">print_list</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">result</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="nf">removeZeroSumSublists</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ListNode</span><span class="o">*</span> <span class="n">current_h</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="n">ListNode</span><span class="o">*</span> <span class="n">head_extend</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="o">-</span><span class="mi">999999</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>

        <span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">sum_front</span><span class="p">;</span>
        <span class="n">sum_front</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">ListNode</span><span class="o">*&gt;</span> <span class="n">sum_2_node</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">current_h</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"in current_h: "</span> <span class="o">&lt;&lt;</span> <span class="n">current_h</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">old_sum_front</span> <span class="o">=</span> <span class="n">sum_front</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
            <span class="kt">int</span> <span class="n">current_sum_front</span> <span class="o">=</span> <span class="n">old_sum_front</span> <span class="o">+</span> <span class="n">current_h</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
            <span class="n">ListNode</span><span class="o">*</span> <span class="n">same_sum_front_node</span> <span class="o">=</span> <span class="n">sum_2_node</span><span class="p">[</span><span class="n">current_sum_front</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">current_h</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">same_sum_front_node</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">same_sum_front_node</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">current_h</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="n">head_extend</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">current_h</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"current_sum_front: "</span> <span class="o">&lt;&lt;</span> <span class="n">current_sum_front</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
                
                <span class="k">if</span> <span class="p">(</span><span class="n">current_sum_front</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 全部删除</span>
                    <span class="n">head_extend</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">current_h</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
                    <span class="k">while</span> <span class="p">(</span><span class="n">sum_front</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                        <span class="kt">int</span> <span class="n">sum_f</span> <span class="o">=</span> <span class="n">sum_front</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
                        <span class="n">sum_2_node</span><span class="p">[</span><span class="n">sum_f</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
                        <span class="n">sum_front</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
                    <span class="p">}</span>
                <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">same_sum_front_node</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 已经存在</span>
                    <span class="n">same_sum_front_node</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">current_h</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
                    <span class="kt">int</span> <span class="n">sum_f</span> <span class="o">=</span> <span class="n">sum_front</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
                    <span class="k">while</span> <span class="p">(</span><span class="n">sum_f</span> <span class="o">!=</span> <span class="n">current_sum_front</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">sum_2_node</span><span class="p">[</span><span class="n">sum_f</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
                        <span class="n">sum_front</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
                        <span class="n">sum_f</span> <span class="o">=</span> <span class="n">sum_front</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
                    <span class="p">}</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">current_sum_front</span> <span class="o">&lt;&lt;</span> <span class="s">" push to sum_front"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
                    <span class="n">sum_front</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">current_sum_front</span><span class="p">);</span>
                    <span class="n">sum_2_node</span><span class="p">[</span><span class="n">current_sum_front</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_h</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="n">ListNode</span><span class="o">*</span> <span class="n">print_head_extend</span> <span class="o">=</span> <span class="n">head_extend</span><span class="p">;</span>
            <span class="k">this</span><span class="o">-&gt;</span><span class="n">print_list</span><span class="p">(</span><span class="n">print_head_extend</span><span class="p">);</span>

            <span class="n">current_h</span> <span class="o">=</span> <span class="n">current_h</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
 
        <span class="k">return</span> <span class="n">head_extend</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">);</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">);</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    
    <span class="n">Solution</span><span class="o">*</span> <span class="n">sol</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Solution</span><span class="p">();</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">result</span> <span class="o">=</span> <span class="n">sol</span><span class="o">-&gt;</span><span class="n">removeZeroSumSublists</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
    
    <span class="k">while</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="vector">vector</h2> <h3 id="二维-vector-排序算法">二维 vector 排序算法</h3> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vector&lt;vector&lt;int&gt;&gt; points;
sort(points.begin(), ppints.end(), [](const vector&lt;int&gt; &amp;a, const vector&lt;int&gt; &amp;b) {
    return a[0] &lt; b[0];
});
</code></pre></div></div> <h3 id="快速创建二维-vector-并初始化为-0">快速创建二维 vector 并初始化为 0</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">res</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">col</span><span class="p">));</span>
</code></pre></div></div> <h3 id="交换-i-和-j-的未知">交换 i 和 j 的未知</h3> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>std::swap(v[i], v[j]);
</code></pre></div></div> <h2 id="哈希表">哈希表</h2> <h3 id="哈希表迭代器">哈希表迭代器</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">select_it</span> <span class="o">=</span> <span class="n">select_map</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
<span class="k">while</span><span class="p">(</span><span class="n">select_it</span> <span class="o">!=</span> <span class="n">select_map</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// cout &lt;&lt; "pair select_it.key = " &lt;&lt; select_it-&gt;first &lt;&lt; " pair select_it.value = " &lt;&lt; select_it-&gt;second &lt;&lt; endl;</span>
    <span class="n">res</span><span class="p">[</span><span class="n">select_it</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">]</span> <span class="o">=</span> <span class="n">select_it</span><span class="o">-&gt;</span><span class="n">second</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="o">++</span><span class="n">select_it</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
</code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">//</span> <span class="n">for函数内进行迭代</span>
<span class="nf">for </span><span class="p">(</span><span class="n">auto</span> <span class="nb">iter</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">hashTable</span><span class="p">.</span><span class="nf">begin</span><span class="p">();</span> <span class="nb">iter</span> <span class="o">!=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">hashTable</span><span class="p">.</span><span class="nf">end</span><span class="p">();</span> <span class="o">++</span><span class="nb">iter</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">if </span><span class="p">(</span><span class="nb">iter</span><span class="o">-&gt;</span><span class="n">second</span> <span class="o">&gt;</span> <span class="n">max_result</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">max_result</span> <span class="o">=</span> <span class="nb">iter</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="哈希表复杂-key自定义-hashfunc-和-equalfunc">哈希表复杂 key——自定义 Hashfunc 和 Equalfunc</h3> <ul> <li>Hashfunc 结构体需要重写()操作，主要是对复杂的 key 利用 hasher 进行哈希，注意要指定 seed</li> <li>Equalfunc 结构体需要重写()操作，这个比较简单，确定两个 key 相同即可。</li> <li>创建：<code class="language-plaintext highlighter-rouge">unordered_map&lt;vector&lt;int&gt;, int, Hashfunc, Equalfunc&gt; hashTable</code> </li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">Hashfunc</span> <span class="p">{</span>
    <span class="kt">size_t</span> <span class="k">operator</span><span class="p">()</span> <span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">hash</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">hasher</span><span class="p">;</span>
        <span class="kt">size_t</span> <span class="n">seed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">:</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">seed</span> <span class="o">^=</span> <span class="n">hasher</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="mh">0x9e3779b9</span> <span class="o">+</span> <span class="p">(</span><span class="n">seed</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">seed</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">seed</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">Equalfunc</span> <span class="p">{</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="p">()</span> <span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="n">b</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">Hashfunc</span><span class="p">,</span> <span class="n">Equalfunc</span><span class="o">&gt;</span> <span class="n">hashTable</span><span class="p">;</span>
</code></pre></div></div> <p>###</p> <h2 id="集合">集合</h2> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">neighs</span><span class="p">;</span>
<span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;::</span><span class="n">iterator</span> <span class="n">n_left_it</span> <span class="o">=</span> <span class="n">neighs</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">n_left_it</span> <span class="o">==</span> <span class="n">neighs</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">r</span> <span class="o">=</span> <span class="p">{</span><span class="n">right</span><span class="p">};</span>
    <span class="n">neighs</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span>
    <span class="c1">// cout &lt;&lt; "add left first" &lt;&lt; left &lt;&lt; " ";</span>
    <span class="c1">// print_vec(r);</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">n_left_it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">right</span><span class="p">);</span>
    <span class="c1">// cout &lt;&lt; "add left not first" &lt;&lt; left &lt;&lt; " ";</span>
    <span class="c1">// print_vec(r);</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="链表">链表</h2> <h3 id="核心思想-qia">核心思想 qia</h3> <ul> <li>链表是一种兼具递归和迭代性质的数据结构</li> <li> <p>递归的核心解法</p> <ul> <li>回溯算法：后序遍历的重要性</li> <li>例子：反转链表</li> </ul> </li> <li> <p>迭代的核心解法</p> <ul> <li>三指针法： pre、cur、next [始终一步一步地将 cur-&gt;next 设置为 pre，然后将 pre 设置为 cur，将 cur 设置为 next]</li> <li>例子：k 个一组翻转；判断回文链表</li> </ul> </li> </ul> <h3 id="反转链表">反转链表</h3> <ul> <li>Leetcode 92：<a href="https://leetcode.cn/problems/reverse-linked-list-ii/submissions/" rel="external nofollow noopener" target="_blank">https://leetcode.cn/problems/reverse-linked-list-ii/submissions/</a> </li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">backtrack</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 模板: 反转前n个节点的链表!</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="o">-&gt;</span><span class="n">wait_next</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">head</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">ListNode</span><span class="o">*</span> <span class="n">back</span> <span class="o">=</span> <span class="n">backtrack</span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>

        <span class="c1">// cout &lt;&lt; "head: " &lt;&lt; head-&gt;val &lt;&lt; " ; back: " &lt;&lt; back-&gt;val &lt;&lt; endl;</span>
        <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">wait_next</span><span class="p">;</span> <span class="c1">// 之后会断掉, 目的是让第一个节点可以直接和最后相连</span>
        <span class="k">return</span> <span class="n">back</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="nf">reverseBetween</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">,</span> <span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ListNode</span><span class="o">*</span> <span class="n">dummy_head</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="o">-</span><span class="mi">100</span><span class="p">);</span> <span class="c1">// 技巧: 增加一个节点</span>
        <span class="n">dummy_head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="n">ListNode</span><span class="o">*</span> <span class="n">need_next</span> <span class="o">=</span> <span class="n">dummy_head</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">need_next</span> <span class="o">=</span> <span class="n">need_next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// cout &lt;&lt; "check need_next: " &lt;&lt; need_next-&gt;val &lt;&lt; endl;</span>
        

        <span class="n">ListNode</span><span class="o">*</span> <span class="n">new_head</span> <span class="o">=</span> <span class="n">backtrack</span><span class="p">(</span><span class="n">need_next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> 
        <span class="n">need_next</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">new_head</span><span class="p">;</span>

        
        <span class="k">return</span> <span class="n">dummy_head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">wait_next</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="k-个一组反转链表">k 个一组反转链表</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">reverse_a_b</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="n">ListNode</span><span class="o">*</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 迭代方案</span>
        <span class="n">ListNode</span><span class="o">*</span> <span class="n">pre</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
        <span class="n">ListNode</span><span class="o">*</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
        <span class="n">ListNode</span><span class="o">*</span> <span class="n">nex</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// [a, b)</span>
            <span class="n">nex</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">pre</span><span class="p">;</span>
            <span class="n">pre</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">nex</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">pre</span><span class="p">;</span> <span class="c1">// 将头返回</span>
    <span class="p">}</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="nf">reverseKGroup</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 递归方案</span>
        <span class="n">ListNode</span><span class="o">*</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">cur</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 不够就返回head</span>
                <span class="k">return</span> <span class="n">head</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        
        <span class="n">ListNode</span><span class="o">*</span> <span class="n">new_head</span> <span class="o">=</span> <span class="n">reverse_a_b</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">cur</span><span class="p">);</span>
        <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">reverseKGroup</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span> <span class="c1">// 很简洁的写法</span>
        <span class="k">return</span> <span class="n">new_head</span><span class="p">;</span>   
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <h2 id="二叉树">二叉树</h2> <h3 id="核心思想">核心思想</h3> <ul> <li>二叉树的前序遍历、中序遍历、后序遍历 其实本质上等同于 链表和数组的递归遍历思路</li> </ul> <div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">/</span><span class="o">*</span> <span class="err">迭代遍历数组</span> <span class="o">*</span><span class="p">/</span>
<span class="n">void</span> <span class="n">traverse</span><span class="p">(</span><span class="n">int</span><span class="p">[]</span> <span class="n">arr</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="nb">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

    <span class="p">}</span>
<span class="p">}</span>

<span class="p">/</span><span class="o">*</span> <span class="err">递归遍历数组</span> <span class="o">*</span><span class="p">/</span>
<span class="n">void</span> <span class="n">traverse</span><span class="p">(</span><span class="n">int</span><span class="p">[]</span> <span class="n">arr</span><span class="p">,</span> <span class="n">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">arr</span><span class="o">.</span><span class="nb">length</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="p">//</span> <span class="err">前序位置</span>
    <span class="n">traverse</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">//</span> <span class="err">后序位置</span>
<span class="p">}</span>

<span class="p">/</span><span class="o">*</span> <span class="err">迭代遍历单链表</span> <span class="o">*</span><span class="p">/</span>
<span class="n">void</span> <span class="n">traverse</span><span class="p">(</span><span class="n">ListNode</span> <span class="nb">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">ListNode</span> <span class="n">p</span> <span class="o">=</span> <span class="nb">head</span><span class="p">;</span> <span class="n">p</span> <span class="err">!</span><span class="o">=</span> <span class="nb">null</span><span class="p">;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>

    <span class="p">}</span>
<span class="p">}</span>

<span class="p">/</span><span class="o">*</span> <span class="err">递归遍历单链表</span> <span class="o">*</span><span class="p">/</span>
<span class="n">void</span> <span class="n">traverse</span><span class="p">(</span><span class="n">ListNode</span> <span class="nb">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">head</span> <span class="o">==</span> <span class="nb">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="p">//</span> <span class="err">前序位置</span>
    <span class="n">traverse</span><span class="p">(</span><span class="nb">head</span><span class="o">.</span><span class="n">next</span><span class="p">);</span>
    <span class="p">//</span> <span class="err">后序位置</span>
<span class="p">}</span>

<span class="p">/</span><span class="o">*</span> <span class="err">递归遍历二叉树</span> <span class="o">*</span><span class="p">/</span>
<span class="n">void</span> <span class="n">traverse</span><span class="p">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="p">//</span> <span class="err">前序位置</span>
    <span class="n">traverse</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">);</span>
    <span class="p">//</span> <span class="err">中序位置</span>
    <span class="n">traverse</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">);</span>
    <span class="p">//</span> <span class="err">后序位置</span>
<span class="p">}</span>
</code></pre></div></div> <ul> <li> <strong>针对</strong><strong>链表</strong><strong>：</strong>所谓前序位置，就是刚进入一个节点（元素）的时候，后序位置就是即将离开一个节点（元素）的时候，那么进一步，你把代码写在不同位置，代码执行的时机也不同：</li> <li> <p><strong>针对二叉树：</strong>前中后序是遍历二叉树过程中处理每一个节点的三个特殊时间点，绝不仅仅是三个顺序不同的 List：【<strong>你可以发现每个节点都有「唯一」属于自己的前中后序位置</strong>，所以我说前中后序遍历是遍历二叉树过程中处理<strong>每一个节点</strong>的三个特殊时间点。】【二叉树的所有问题，就是让你在前中后序位置注入巧妙的代码逻辑，去达到自己的目的，你只需要单独思考每一个节点应该做什么，其他的不用你管，抛给二叉树遍历框架，递归会在所有节点上做相同的操作。】</p> <ul> <li> <strong>前序位置</strong>的代码在刚刚进入一个二叉树节点的时候执行；【很多题都是在前序位置写代码，实际上是因为我们习惯把那些对前中后序位置不敏感的代码写在前序位置罢了。】【前序位置的代码只能从函数参数中获取父节点传递来的数据！】</li> <li> <strong>中序位置</strong>的代码在一个二叉树节点左子树都遍历完，即将开始遍历右子树的时候执行。【中序位置主要用在 BST 场景中，你完全可以把 BST 的中序遍历认为是遍历有序数组。】</li> <li> <strong>后序位置</strong>的代码在将要离开一个二叉树节点的时候执行；【主要的代码逻辑集中在后序位置：因为这个思路正确的核心在于，你确实可以通过子树的最大深度推导出原树的深度，所以当然要首先利用递归函数的定义算出左右子树的最大深度，然后推出原树的最大深度，主要逻辑自然放在后序位置。】【后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据。】【一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了。】</li> </ul> </li> </ul> <h3 id="递归解题思路">递归解题思路</h3> <ul> <li>二叉树题目的递归解法可以分两类思路，第一类是遍历一遍二叉树得出答案，第二类是通过分解问题（分解成子树）计算出答案，这两类思路分别对应着 <a href="https://labuladong.gitee.io/algo/di-ling-zh-bfe1b/hui-su-sua-c26da/" rel="external nofollow noopener" target="_blank">回溯算法核心框架</a> 和 <a href="https://labuladong.gitee.io/algo/di-ling-zh-bfe1b/dong-tai-g-1e688/" rel="external nofollow noopener" target="_blank">动态规划核心框架</a>。 <ul> <li>在 <a href="https://labuladong.gitee.io/algo/di-ling-zh-bfe1b/hui-su-sua-c26da/" rel="external nofollow noopener" target="_blank">回溯算法核心框架</a> 中给出的函数签名一般也是没有返回值的 <code class="language-plaintext highlighter-rouge">void backtrack(...)</code>【一般还会涉及到做选择和撤销选择】</li> <li>在 <a href="https://labuladong.gitee.io/algo/di-ling-zh-bfe1b/dong-tai-g-1e688/" rel="external nofollow noopener" target="_blank">动态规划核心框架</a> 中给出的函数签名是带有返回值的 <code class="language-plaintext highlighter-rouge">dp</code> 函数。</li> </ul> </li> </ul> <h3 id="动态规划--dfs--回溯算法">动态规划 / DFS / 回溯算法</h3> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/SuX8bPFrvojMzVx7HpXcbAg0nwf-480.webp 480w, /assets/img/feishu_docs_static/SuX8bPFrvojMzVx7HpXcbAg0nwf-800.webp 800w, /assets/img/feishu_docs_static/SuX8bPFrvojMzVx7HpXcbAg0nwf-1400.webp 1400w, " sizes="95vw" type="image/webp"></source> <img src="/assets/img/feishu_docs_static/SuX8bPFrvojMzVx7HpXcbAg0nwf.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <ul> <li>动态规划 <ul> <li> <p>分解问题的思路，关注点在 <strong>子树</strong>！</p> </li> <li> <p>例子：</p> <ul> <li>Leetcode 100：<a href="https://leetcode.cn/problems/same-tree/description/?show=1" rel="external nofollow noopener" target="_blank">https://leetcode.cn/problems/same-tree/description/?show=1</a> <ul> <li>前序遍历即可，注意参数需要传两个指针，这样可以一起进行遍历</li> </ul> </li> <li>Leetcode 101：<a href="https://leetcode.cn/problems/symmetric-tree/description/?show=1" rel="external nofollow noopener" target="_blank">https://leetcode.cn/problems/symmetric-tree/description/?show=1</a> <ul> <li>非常好的一道题目，还是 DP 的思想，让每个子树的两层满足部分情况即可!</li> <li>请多看题解：<a href="https://leetcode.cn/problems/symmetric-tree/solutions/46560/dong-hua-yan-shi-101-dui-cheng-er-cha-shu-by-user7/?show=1" rel="external nofollow noopener" target="_blank">https://leetcode.cn/problems/symmetric-tree/solutions/46560/dong-hua-yan-shi-101-dui-cheng-er-cha-shu-by-user7/?show=1</a> </li> </ul> </li> <li>Leetcode 1008：<a href="https://leetcode.cn/problems/construct-binary-search-tree-from-preorder-traversal/submissions/?show=1" rel="external nofollow noopener" target="_blank">https://leetcode.cn/problems/construct-binary-search-tree-from-preorder-traversal/submissions/?show=1</a> <ul> <li>非常好的一道题目，从前序遍历的 vector 中恢复，因为本质上前序遍历就是找到一左一右，因此可以快速二分。二分后每次让子树去生成左右节点，因此这是一道 DP 的题目！</li> </ul> </li> </ul> </li> </ul> </li> <li>DFS <ul> <li>遍历的思路， 关注点在 <strong>节点</strong>！【似乎不关心走一条边多少次，关注的是节点访问的情况】</li> <li>做选择和撤销选择的逻辑都在 for 循环外面</li> </ul> </li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/HWtQbusLIoaAfoxD5lcchhyfnMc-480.webp 480w, /assets/img/feishu_docs_static/HWtQbusLIoaAfoxD5lcchhyfnMc-800.webp 800w, /assets/img/feishu_docs_static/HWtQbusLIoaAfoxD5lcchhyfnMc-1400.webp 1400w, " sizes="95vw" type="image/webp"></source> <img src="/assets/img/feishu_docs_static/HWtQbusLIoaAfoxD5lcchhyfnMc.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/WrM0bWjgSoHhQKx6I7Ic5usWnQf-480.webp 480w, /assets/img/feishu_docs_static/WrM0bWjgSoHhQKx6I7Ic5usWnQf-800.webp 800w, /assets/img/feishu_docs_static/WrM0bWjgSoHhQKx6I7Ic5usWnQf-1400.webp 1400w, " sizes="95vw" type="image/webp"></source> <img src="/assets/img/feishu_docs_static/WrM0bWjgSoHhQKx6I7Ic5usWnQf.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <ul> <li> <p>回溯算法</p> <ul> <li> <p>遍历的思路，关注点在 <strong>树枝</strong>！【一般来说，走过的路还要走回来，所以说关注点在树枝】</p> </li> <li> <p>做选择和撤销选择的逻辑都在 for 循环里面【因为需要拿到树枝的两个端点】</p> </li> </ul> </li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/TJJabIayQoWdnxxffXUcKbTKnrX-480.webp 480w, /assets/img/feishu_docs_static/TJJabIayQoWdnxxffXUcKbTKnrX-800.webp 800w, /assets/img/feishu_docs_static/TJJabIayQoWdnxxffXUcKbTKnrX-1400.webp 1400w, " sizes="95vw" type="image/webp"></source> <img src="/assets/img/feishu_docs_static/TJJabIayQoWdnxxffXUcKbTKnrX.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/B0EobRET3oolkDxjpoicCbfln5s-480.webp 480w, /assets/img/feishu_docs_static/B0EobRET3oolkDxjpoicCbfln5s-800.webp 800w, /assets/img/feishu_docs_static/B0EobRET3oolkDxjpoicCbfln5s-1400.webp 1400w, " sizes="95vw" type="image/webp"></source> <img src="/assets/img/feishu_docs_static/B0EobRET3oolkDxjpoicCbfln5s.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <h3 id="二叉树的深度-后序框架分解问题框架--其他---leetcode-543">二叉树的深度 后序框架[分解问题框架] + 其他 - Leetcode 543</h3> <div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
    <span class="n">int</span> <span class="n">transver</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="n">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        
        <span class="n">int</span> <span class="n">left_length</span> <span class="o">=</span> <span class="n">transver</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
        <span class="n">int</span> <span class="n">right_length</span> <span class="o">=</span> <span class="n">transver</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
        

        <span class="n">int</span> <span class="n">result_length</span> <span class="o">=</span> <span class="n">left_length</span> <span class="o">+</span> <span class="n">right_length</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">result_length</span> <span class="o">&gt;</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">max_length</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">this</span><span class="o">-&gt;</span><span class="n">max_length</span> <span class="o">=</span> <span class="n">result_length</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="n">left_length</span><span class="p">,</span> <span class="n">right_length</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">int</span> <span class="n">diameterOfBinaryTree</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">int</span> <span class="n">temp_result</span> <span class="o">=</span> <span class="n">transver</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">max_length</span><span class="p">;</span>
    <span class="p">}</span>
<span class="n">private</span><span class="p">:</span>
    <span class="n">int</span> <span class="n">max_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="完美二叉树的三叉树化可以用于对同层的不同子树进行连接">完美二叉树的三叉树化：可以用于对同层的不同子树进行连接</h3> <ul> <li>Leetcode 116 <ul> <li>参考文献：<a href="https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-66994/dong-ge-da-cbce8/" rel="external nofollow noopener" target="_blank">https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-66994/dong-ge-da-cbce8/</a> </li> </ul> </li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 注意：cpp 代码由 chatGPT🤖 根据我的 java 代码翻译，旨在帮助不同背景的读者理解算法逻辑。</span>
<span class="c1">// 本代码不保证正确性，仅供参考。如有疑惑，可以参照我写的 java 代码对比查看。</span>

<span class="c1">// 主函数</span>
<span class="n">Node</span><span class="o">*</span> <span class="nf">connect</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="c1">// 遍历「三叉树」，连接相邻节点</span>
    <span class="n">traverse</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 三叉树遍历框架</span>
<span class="kt">void</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">node1</span><span class="p">,</span> <span class="n">Node</span><span class="o">*</span> <span class="n">node2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node1</span> <span class="o">==</span> <span class="nb">nullptr</span> <span class="o">||</span> <span class="n">node2</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="cm">/**** 前序位置 ****/</span>
    <span class="c1">// 将传入的两个节点穿起来</span>
    <span class="n">node1</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">node2</span><span class="p">;</span>
    
    <span class="c1">// 连接相同父节点的两个子节点</span>
    <span class="n">traverse</span><span class="p">(</span><span class="n">node1</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">node1</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
    <span class="n">traverse</span><span class="p">(</span><span class="n">node2</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">node2</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
    <span class="c1">// 连接跨越父节点的两个子节点</span>
    <span class="n">traverse</span><span class="p">(</span><span class="n">node1</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">node2</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="dfs">DFS</h3> <ul> <li>Leetcode 1457</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
Definition for a binary tree node.
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};
 */</span>

<span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">struct</span> <span class="nc">TreeNode</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">left</span><span class="p">;</span>
    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">right</span><span class="p">;</span>
    <span class="n">TreeNode</span><span class="p">()</span> <span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">left</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">),</span> <span class="n">right</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">TreeNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">left</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">),</span> <span class="n">right</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">TreeNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">TreeNode</span> <span class="o">*</span><span class="n">left</span><span class="p">,</span> <span class="n">TreeNode</span> <span class="o">*</span><span class="n">right</span><span class="p">)</span> <span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">left</span><span class="p">(</span><span class="n">left</span><span class="p">),</span> <span class="n">right</span><span class="p">(</span><span class="n">right</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">bool</span> <span class="n">checkHuiwen</span><span class="p">(</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">umap</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">bool</span> <span class="n">has_one_single</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">umap</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">iter</span> <span class="o">!=</span> <span class="n">umap</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">iter</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">second</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">has_one_single</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">has_one_single</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">second</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="n">has_one_single</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="nf">preTransver</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">result</span><span class="p">,</span> <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">umap</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"check root-&gt;val [add one]: "</span> <span class="o">&lt;&lt;</span>  <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="n">umap</span><span class="p">[</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">checkHuiwen</span><span class="p">(</span><span class="n">umap</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"is hui wen"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
                
                <span class="k">return</span> <span class="n">result</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"not is hui wen"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
                <span class="c1">// umap[root-&gt;val] -= 1;</span>
                <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">preTransver</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">umap</span><span class="p">);</span>
            <span class="n">umap</span><span class="p">[</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[sub one]: "</span> <span class="o">&lt;&lt;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">preTransver</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">umap</span><span class="p">);</span>
            <span class="n">umap</span><span class="p">[</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[sub one]: "</span> <span class="o">&lt;&lt;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
        
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>

    <span class="p">}</span>
    <span class="kt">int</span> <span class="nf">pseudoPalindromicPaths</span> <span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">umap</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">preTransver</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">umap</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
    <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

    <span class="n">Solution</span> <span class="o">*</span><span class="n">sol</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Solution</span><span class="p">();</span>

    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">sol</span><span class="o">-&gt;</span><span class="n">pseudoPalindromicPaths</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="bfs-可以用分层-next-链表去替代-queue">BFS (可以用分层 next 链表去替代 queue)</h3> <ul> <li>Leetcode 116/117：<a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/" rel="external nofollow noopener" target="_blank">填充每个节点的下一个右侧节点指针</a> </li> <li>经典 BFS：严重依赖于 queue！</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Node</span><span class="o">*</span> <span class="nf">connect</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">queue</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">*&gt;</span> <span class="n">q</span><span class="p">;</span>
    <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">level</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">next_level</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">Node</span> <span class="o">*</span><span class="n">current_pointer</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
        <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">current_pointer</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">current_pointer</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">current_pointer</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
            <span class="n">next_level</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">current_pointer</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">current_pointer</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
            <span class="n">next_level</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"set current_pointer: "</span> <span class="o">&lt;&lt;</span> <span class="n">current_pointer</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="s">" to next: "</span> <span class="o">&lt;&lt;</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
            <span class="n">current_pointer</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
            <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>

            <span class="n">current_pointer</span> <span class="o">=</span> <span class="n">current_pointer</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">current_pointer</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">current_pointer</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
                <span class="n">next_level</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">current_pointer</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">current_pointer</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
                <span class="n">next_level</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"next_level: "</span> <span class="o">&lt;&lt;</span> <span class="n">next_level</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="n">level</span> <span class="o">=</span> <span class="n">next_level</span><span class="p">;</span>
        <span class="n">next_level</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <ul> <li>利用链表模拟</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Node</span><span class="o">*</span> <span class="nf">connect</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">Node</span> <span class="o">*</span><span class="n">cur</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Node</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">Node</span> <span class="o">*</span><span class="n">tail</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(;</span> <span class="n">cur</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// cout &lt;&lt; "set tail: " &lt;&lt; tail-&gt;val &lt;&lt; " next: " &lt;&lt; cur-&gt;left-&gt;val &lt;&lt; endl;</span>
                <span class="n">tail</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
                <span class="n">tail</span> <span class="o">=</span> <span class="n">tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// cout &lt;&lt; "set tail: " &lt;&lt; tail-&gt;val &lt;&lt; " next: " &lt;&lt; cur-&gt;right-&gt;val &lt;&lt; endl;</span>
                <span class="n">tail</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
                <span class="n">tail</span> <span class="o">=</span> <span class="n">tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="前序遍历-总是先判断根节点再处理子节点">前序遍历 (总是先判断根节点再处理子节点)</h3> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 前序遍历, 总是先走到最左端点再回来
int front_transve(TreeNode* root, int up, int down, int result) {
    if (root == nullptr) {
        return up - down;
    }
    
    up = max(up, root-&gt;val);
    down = min(down, root-&gt;val);
    

    int left_result = front_transve(root-&gt;left, up, down, result);
    int right_result = front_transve(root-&gt;right, up, down, result);
    result = max(max(left_result, right_result), up-down);

    return result;
}
</code></pre></div></div> <h3 id="后序遍历-总是先判断两个子节点再处理根节点">后序遍历 (总是先判断两个子节点再处理根节点)</h3> <ul> <li>一些二叉树搜索操作很常见</li> <li>题型：根据某些条件删除二叉树的部分节点、根据某些条件拆分二叉树、根据子节点的统计信息处理根节点</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 1110. 删点成林</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">backTransver</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="n">TreeNode</span><span class="o">*</span> <span class="n">parent</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">left</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;&amp;</span> <span class="n">result</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">to_delete</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">backTransver</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">to_delete</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">backTransver</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">to_delete</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">find</span><span class="p">(</span><span class="n">to_delete</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">to_delete</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="o">!=</span> <span class="n">to_delete</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">parent</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">parent</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="n">parent</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">delNodes</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">to_delete</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="p">{};</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">!=</span> <span class="nb">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">find</span><span class="p">(</span><span class="n">to_delete</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">to_delete</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="o">==</span> <span class="n">to_delete</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">backTransver</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">to_delete</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <h2 id="回溯算法">回溯算法</h2> <h3 id="选择-递归-撤销选择的思路">选择-递归-撤销选择的思路</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">def</span> <span class="n">backtrack</span><span class="p">(</span><span class="err">路径</span><span class="p">,</span> <span class="err">选择列表</span><span class="p">)</span><span class="o">:</span>
    <span class="k">if</span> <span class="err">满足结束条件</span><span class="o">:</span>
        <span class="n">result</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="err">路径</span><span class="p">)</span>
        <span class="k">return</span>
    
    <span class="k">for</span> <span class="err">选择</span> <span class="n">in</span> <span class="err">选择列表</span><span class="o">:</span>
        <span class="err">做选择</span>
        <span class="n">backtrack</span><span class="p">(</span><span class="err">路径</span><span class="p">,</span> <span class="err">选择列表</span><span class="p">)</span>
        <span class="err">撤销选择</span>
</code></pre></div></div> <h3 id="和-dfs-的区别">和 DFS 的区别</h3> <ul> <li>回溯算法：关心的是边，选择和撤销发生在 for 循环内部</li> <li>DFS：关心的节点，选择和撤销发生在 for 循环外部</li> </ul> <h3 id="回溯算法的分类">回溯算法的分类</h3> <h4 id="子集-元素没有重复元素不可以重复选">子集 [元素没有重复、元素不可以重复选]</h4> <ul> <li>剪枝法</li> </ul> <div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">void</span> <span class="n">backtrack</span><span class="p">(</span><span class="n">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">int</span> <span class="n">k</span><span class="p">,</span> <span class="n">int</span> <span class="nb">start</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="nb">path</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;&amp;</span> <span class="nb">result</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">//</span> <span class="err">每个</span><span class="nb">path</span><span class="err">都要被采用</span>
    <span class="nb">result</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="nb">path</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="nb">start</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">//</span> <span class="err">选择</span>
        <span class="nb">path</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        
        <span class="n">backtrack</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">path</span><span class="p">,</span> <span class="nb">result</span><span class="p">);</span>

        <span class="p">//</span> <span class="err">撤销选择</span>
        <span class="nb">path</span><span class="o">.</span><span class="n">pop_back</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="组合-元素没有重复元素不可以重复选">组合 [元素没有重复、元素不可以重复选]</h4> <ul> <li>剪枝法</li> </ul> <div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">void</span> <span class="n">backtrack</span><span class="p">(</span><span class="n">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">int</span> <span class="n">k</span><span class="p">,</span> <span class="n">int</span> <span class="nb">start</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="nb">path</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;&amp;</span> <span class="nb">result</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">path</span><span class="o">.</span><span class="nb">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">result</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="nb">path</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nb">path</span><span class="o">.</span><span class="nb">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="nb">start</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">//</span> <span class="err">选择</span>
        <span class="nb">path</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        
        <span class="n">backtrack</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">path</span><span class="p">,</span> <span class="nb">result</span><span class="p">);</span>

        <span class="p">//</span> <span class="err">撤销选择</span>
        <span class="nb">path</span><span class="o">.</span><span class="n">pop_back</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="排列-元素没有重复元素不可以重复选">排列 [元素没有重复、元素不可以重复选]</h4> <ul> <li>需要 flag 数组标记【注意，如果是类似 N 皇后那种只用两种状态无法表征的情况，则需要使用 int 类型的数组】</li> </ul> <div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">void</span> <span class="n">backtrack</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="n">bool</span><span class="o">*</span> <span class="n">used_flag</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="nb">path</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;&amp;</span> <span class="nb">result</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">path</span><span class="o">.</span><span class="nb">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">nums</span><span class="o">.</span><span class="nb">size</span><span class="p">())</span> <span class="p">{</span>
        <span class="nb">result</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="nb">path</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="nb">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">used_flag</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="p">//</span> <span class="err">做决定</span>
        <span class="nb">path</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">used_flag</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        
        <span class="n">backtrack</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">used_flag</span><span class="p">,</span> <span class="nb">path</span><span class="p">,</span> <span class="nb">result</span><span class="p">);</span>
        <span class="p">//</span> <span class="err">撤销决定</span>
        <span class="nb">path</span><span class="o">.</span><span class="n">pop_back</span><span class="p">();</span>
        <span class="n">used_flag</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="子集--组合-元素有重复元素不可以重复选">子集 / 组合 [元素有重复、元素不可以重复选]</h4> <ul> <li>for 循环的时候，遇到相同的就不走了！所以判断条件是那样子</li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/Oi3Ob0dmbo1xaAxAb6jc9YUlnMh-480.webp 480w, /assets/img/feishu_docs_static/Oi3Ob0dmbo1xaAxAb6jc9YUlnMh-800.webp 800w, /assets/img/feishu_docs_static/Oi3Ob0dmbo1xaAxAb6jc9YUlnMh-1400.webp 1400w, " sizes="95vw" type="image/webp"></source> <img src="/assets/img/feishu_docs_static/Oi3Ob0dmbo1xaAxAb6jc9YUlnMh.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
    <span class="n">void</span> <span class="n">backtrack</span><span class="p">(</span><span class="n">int</span> <span class="nb">start</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="nb">path</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;&amp;</span> <span class="nb">result</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">result</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="nb">path</span><span class="p">);</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="nb">start</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="nb">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="nb">start</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span> 
                <span class="p">//</span> <span class="err">不能是第一个，因为不能和</span><span class="nb">start</span><span class="o">-</span><span class="mi">1</span><span class="err">比较</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="nb">path</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            
            <span class="n">backtrack</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">nums</span><span class="p">,</span> <span class="nb">path</span><span class="p">,</span> <span class="nb">result</span><span class="p">);</span>

            <span class="nb">path</span><span class="o">.</span><span class="n">pop_back</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;</span> <span class="n">subsetsWithDup</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">sort</span><span class="p">(</span><span class="n">nums</span><span class="o">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">nums</span><span class="o">.</span><span class="k">end</span><span class="p">());</span>
        <span class="n">int</span> <span class="nb">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="nb">path</span> <span class="o">=</span> <span class="p">{};</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;</span> <span class="nb">result</span> <span class="o">=</span> <span class="p">{};</span>
        <span class="p">//</span> <span class="err">排序后正常剪枝?</span>
        <span class="n">backtrack</span><span class="p">(</span><span class="nb">start</span><span class="p">,</span> <span class="n">nums</span><span class="p">,</span> <span class="nb">path</span><span class="p">,</span> <span class="nb">result</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">result</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <h4 id="排列-元素有重复元素不可以重复选">排列 [元素有重复、元素不可以重复选]</h4> <ul> <li>将重复元素剔除掉，同时还要保证顺序不乱？ <ul> <li>顺序不乱的要求：前一个元素需要用过才会进入？</li> </ul> </li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/CE0Vb5BBvo7F23xg8A1ccbaonFd-480.webp 480w, /assets/img/feishu_docs_static/CE0Vb5BBvo7F23xg8A1ccbaonFd-800.webp 800w, /assets/img/feishu_docs_static/CE0Vb5BBvo7F23xg8A1ccbaonFd-1400.webp 1400w, " sizes="95vw" type="image/webp"></source> <img src="/assets/img/feishu_docs_static/CE0Vb5BBvo7F23xg8A1ccbaonFd.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
    <span class="n">void</span> <span class="n">backtrack</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;&amp;</span> <span class="nb">result</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="nb">path</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">bool</span><span class="o">&gt;&amp;</span> <span class="n">used_flag</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">path</span><span class="o">.</span><span class="nb">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">nums</span><span class="o">.</span><span class="nb">size</span><span class="p">())</span> <span class="p">{</span>
            <span class="nb">result</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="nb">path</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="nb">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="err">!</span><span class="n">used_flag</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">used_flag</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="p">//</span> <span class="n">jueding</span> 
            <span class="nb">path</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="n">used_flag</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            
            <span class="n">backtrack</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="nb">result</span><span class="p">,</span> <span class="nb">path</span><span class="p">,</span> <span class="n">used_flag</span><span class="p">);</span>
            <span class="p">//</span> <span class="n">chexiao</span> <span class="n">jueding</span>
            <span class="nb">path</span><span class="o">.</span><span class="n">pop_back</span><span class="p">();</span>
            <span class="n">used_flag</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;</span> <span class="n">permuteUnique</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">sort</span><span class="p">(</span><span class="n">nums</span><span class="o">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">nums</span><span class="o">.</span><span class="k">end</span><span class="p">());</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;</span> <span class="nb">result</span> <span class="o">=</span> <span class="p">{};</span> 
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="nb">path</span> <span class="o">=</span> <span class="p">{};</span> 
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">bool</span><span class="o">&gt;</span> <span class="n">used_flag</span> <span class="o">=</span> <span class="p">{};</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="nb">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">used_flag</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">backtrack</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="nb">result</span><span class="p">,</span> <span class="nb">path</span><span class="p">,</span> <span class="n">used_flag</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">result</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <h4 id="组合-元素没有重复元素可以被重复选">组合 [元素没有重复、元素可以被重复选]</h4> <ul> <li>进入递归的时候，传入 i 可以重复选这个项目！</li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/H3mpbbECgoiUDIxMEIscEJqDnIJ-480.webp 480w, /assets/img/feishu_docs_static/H3mpbbECgoiUDIxMEIscEJqDnIJ-800.webp 800w, /assets/img/feishu_docs_static/H3mpbbECgoiUDIxMEIscEJqDnIJ-1400.webp 1400w, " sizes="95vw" type="image/webp"></source> <img src="/assets/img/feishu_docs_static/H3mpbbECgoiUDIxMEIscEJqDnIJ.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
    <span class="n">void</span> <span class="n">backtrack</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">candidates</span><span class="p">,</span> <span class="n">int</span> <span class="n">target</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;&amp;</span> <span class="nb">result</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="nb">path</span><span class="p">,</span> <span class="n">int</span> <span class="n">path_sum</span><span class="p">,</span> <span class="n">int</span> <span class="nb">start</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">path_sum</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">path_sum</span> <span class="o">==</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
            <span class="nb">result</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="nb">path</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="nb">start</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">candidates</span><span class="o">.</span><span class="nb">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="nb">path</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">candidates</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="n">path_sum</span> <span class="o">+=</span> <span class="n">candidates</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

            <span class="n">backtrack</span><span class="p">(</span><span class="n">candidates</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="nb">result</span><span class="p">,</span> <span class="nb">path</span><span class="p">,</span> <span class="n">path_sum</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span> <span class="p">//</span> <span class="err">下次还从</span><span class="n">i</span><span class="err">的位置开始还能接着选</span>

            <span class="nb">path</span><span class="o">.</span><span class="n">pop_back</span><span class="p">();</span>
            <span class="n">path_sum</span> <span class="o">-=</span> <span class="n">candidates</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
        
    <span class="p">}</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;</span> <span class="n">combinationSum</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">candidates</span><span class="p">,</span> <span class="n">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">sort</span><span class="p">(</span><span class="n">candidates</span><span class="o">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">candidates</span><span class="o">.</span><span class="k">end</span><span class="p">(),</span> <span class="n">greater</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span><span class="p">());</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;</span> <span class="nb">result</span> <span class="o">=</span> <span class="p">{};</span> 
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="nb">path</span> <span class="o">=</span> <span class="p">{};</span> 
        <span class="n">int</span> <span class="n">path_sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">int</span> <span class="nb">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">backtrack</span><span class="p">(</span><span class="n">candidates</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="nb">result</span><span class="p">,</span> <span class="nb">path</span><span class="p">,</span> <span class="n">path_sum</span><span class="p">,</span> <span class="nb">start</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">result</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="例子-leetcode-51-n-皇后">例子: Leetcode 51 N 皇后</h3> <ul> <li>注意：状态可能 bool 状态无法完全表达，因为 2 元状态机可能撤销的时候会被覆盖！</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">transve</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;&amp;</span> <span class="n">result</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">path</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">flag</span><span class="p">,</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">new_line</span><span class="p">,</span> <span class="kt">int</span> <span class="n">row_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// cout &lt;&lt; "whta?" &lt;&lt; endl;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">row_id</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="n">row_id</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">// 选择</span>
            
            <span class="n">new_line</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'Q'</span><span class="p">;</span>
            <span class="c1">// cout &lt;&lt; "check new_line: " &lt;&lt; new_line &lt;&lt; endl;</span>
            <span class="n">path</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">new_line</span><span class="p">);</span>
            <span class="n">new_line</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'.'</span><span class="p">;</span>
            
            <span class="c1">// i列, (row_id++, i++)</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">row_id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">flag</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">row_id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">,</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">flag</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">row_id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">,</span> <span class="o">--</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">flag</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">transve</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">flag</span><span class="p">,</span> <span class="n">new_line</span><span class="p">,</span> <span class="n">row_id</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>

            <span class="c1">// 撤销选择</span>
            <span class="n">path</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">row_id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">flag</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">row_id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">,</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">flag</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">row_id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">,</span> <span class="o">--</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">flag</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">solveNQueens</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// cout &lt;&lt; "what?" &lt;&lt; endl;</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="p">{};</span> 
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">path</span> <span class="o">=</span> <span class="p">{};</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">flag</span> <span class="o">=</span> <span class="p">{};</span>
        <span class="kt">char</span> <span class="n">ch</span> <span class="o">=</span> <span class="sc">'.'</span><span class="p">;</span>
        <span class="n">string</span> <span class="nf">new_line</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">ch</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">line</span> <span class="o">=</span> <span class="p">{};</span>
            <span class="n">flag</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">line</span><span class="p">);</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">flag</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span> 
        <span class="kt">int</span> <span class="n">row_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        
        <span class="n">transve</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">flag</span><span class="p">,</span> <span class="n">new_line</span><span class="p">,</span> <span class="n">row_id</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="例子-leetcode-78-返回全排列组合">例子: Leetcode 78 返回全排列组合</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">backtrack</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">path</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">result</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">path</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

            <span class="n">backtrack</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// 剪枝树, 避免重复计算</span>

            <span class="n">path</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">subsets</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">path</span> <span class="o">=</span> <span class="p">{};</span> 
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="p">{};</span>
        <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="n">backtrack</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <h2 id="遍历-for">遍历 for</h2> <h3 id="auto-智能指针">auto 智能指针</h3> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for (const auto x: arr) {
    cout &lt;&lt; x &lt;&lt; endl;
}
</code></pre></div></div> <h2 id="tuple">Tuple</h2> <ul> <li>一个避免使用 struct 的简易数据结构，可以用 std::tuple 进行初始化，并用 std::tie 进行解包</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;tuple&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 感觉是一个不错的东西, 可以避免使用struct构造, 方便!</span>
    <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">t3</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="s">"3"</span><span class="p">};</span> <span class="c1">// 初始化</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">j</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">k</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">tie</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">=</span> <span class="n">t3</span><span class="p">;</span> <span class="c1">// 解包</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"i: "</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">"; j: "</span> <span class="o">&lt;&lt;</span> <span class="n">j</span> <span class="o">&lt;&lt;</span> <span class="s">"; k: "</span> <span class="o">&lt;&lt;</span> <span class="n">k</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="c-的-deque">C++ 的 deque</h2> <ul> <li>双端队列，使用两个双端队列可以用在滑动窗口中以非常低的成本来快速维护窗口中局部的 Max 和 Min</li> <li>方法：用一个 Max queue 保存最大值和比最大值小一些的量，直到窗口滑到一个比最大值还大的量，则抛弃之前的保存值；Min queue 也是同理。</li> <li><a href="https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/solution/gai-zhuang-ban-hua-dong-chuang-kou-liang-271k/" rel="external nofollow noopener" target="_blank">https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/solution/gai-zhuang-ban-hua-dong-chuang-kou-liang-271k/</a></li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">longestSubarray</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">limit</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">deque</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">min_heap</span><span class="p">;</span>
        <span class="n">deque</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">max_heap</span><span class="p">;</span>
        

        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">max_heap</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">max_heap</span><span class="p">.</span><span class="n">front</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">r</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">max_heap</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span> <span class="c1">// 只有当右边新来的item比维护的最大值大的时候, 需要删除所有内容</span>
            <span class="p">}</span>
            <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">min_heap</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">min_heap</span><span class="p">.</span><span class="n">front</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">r</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">min_heap</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span> <span class="c1">// 只有当右边新来的item比维护的最小值小的时候，需要删除所有内容</span>
            <span class="p">}</span>

            <span class="c1">// 两个deque合并在一起就是当前窗口的内容，其中最大值的位置会有两个值</span>

            <span class="n">max_heap</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">r</span><span class="p">]);</span>
            <span class="n">min_heap</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">r</span><span class="p">]);</span>

            <span class="n">r</span><span class="o">++</span><span class="p">;</span>
            
            <span class="k">while</span> <span class="p">(</span><span class="n">max_heap</span><span class="p">.</span><span class="n">front</span><span class="p">()</span> <span class="o">-</span> <span class="n">min_heap</span><span class="p">.</span><span class="n">front</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">limit</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 判断条件! 可以自定义</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">max_heap</span><span class="p">.</span><span class="n">front</span><span class="p">()</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">l</span><span class="p">])</span> <span class="p">{</span>
                    <span class="n">max_heap</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span>
                <span class="p">}</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">min_heap</span><span class="p">.</span><span class="n">front</span><span class="p">()</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">l</span><span class="p">])</span> <span class="p">{</span>
                    <span class="n">min_heap</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span>
                <span class="p">}</span>
                <span class="n">l</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">res</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">r</span><span class="o">-</span><span class="n">l</span><span class="p">);</span>
        <span class="p">}</span>
        
        <span class="c1">// cout &lt;&lt; "min_heap: " &lt;&lt; min_heap.top() &lt;&lt; endl;</span>
        <span class="c1">// cout &lt;&lt; "max_heap: " &lt;&lt; max_heap.top() &lt;&lt; endl;</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <h2 id="c11-整个专题">C++11 整个专题</h2> <h3 id="lambda">lambda</h3> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/RDU2bwI42oqB4yxeX0pcJgfCnJg-480.webp 480w, /assets/img/feishu_docs_static/RDU2bwI42oqB4yxeX0pcJgfCnJg-800.webp 800w, /assets/img/feishu_docs_static/RDU2bwI42oqB4yxeX0pcJgfCnJg-1400.webp 1400w, " sizes="95vw" type="image/webp"></source> <img src="/assets/img/feishu_docs_static/RDU2bwI42oqB4yxeX0pcJgfCnJg.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <ul> <li>这是一个比较大的坑，在 C++11 引入 lambda 函数，后续在 C++14 引入了泛型。</li> <li>function&lt; 返回值类型(参数类型)&gt; = <a href="%E5%8F%82%E6%95%B0">&amp;</a> -&gt; 返回值类型 {} <ol> <li>capture 子句（在 C++ 规范中也称为 Lambda 引导。）</li> <li>参数列表（可选）。 （也称为 Lambda 声明符）</li> <li>mutable 规范（可选）。</li> <li>exception-specification（可选）。</li> <li>trailing-return-type（可选）。</li> <li>Lambda 体。</li> </ol> </li> <li> <p>[] 中的内容表示不同的 capture 子句：Lambda 可在其主体中引入新的变量（用 C++14），它还可以访问（或“捕获”）周边范围内的变量。 Lambda 以 capture 子句开头。 它指定捕获哪些变量，以及捕获是通过值还是通过引用进行的。</p> <ul> <li>有与号 (<code class="language-plaintext highlighter-rouge">&amp;</code>) 前缀的变量通过引用进行访问，没有该前缀的变量通过值进行访问。</li> <li>空 capture 子句 <code class="language-plaintext highlighter-rouge">[ ]</code> 指示 lambda 表达式的主体不访问封闭范围中的变量。</li> <li>可以使用默认捕获模式来指示如何捕获 Lambda 体中引用的任何外部变量：<code class="language-plaintext highlighter-rouge">[&amp;]</code> 表示通过引用捕获引用的所有变量，而 <code class="language-plaintext highlighter-rouge">[=]</code> 表示通过值捕获它们。</li> <li>可以使用默认捕获模式，然后为特定变量显式指定相反的模式。 例如，如果 lambda 体通过引用访问外部变量 <code class="language-plaintext highlighter-rouge">total</code> 并通过值访问外部变量 <code class="language-plaintext highlighter-rouge">factor</code>，则以下 capture 子句等效：</li> </ul> </li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="o">&amp;</span><span class="n">total</span><span class="p">,</span> <span class="n">factor</span><span class="p">]</span>
<span class="p">[</span><span class="n">factor</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">total</span><span class="p">]</span>
<span class="p">[</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">factor</span><span class="p">]</span>
<span class="p">[</span><span class="o">=</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">total</span><span class="p">]</span>
</code></pre></div></div> <p>-</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">Node</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">time</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">*&gt;</span> <span class="n">childs</span><span class="p">;</span>

    <span class="n">Node</span><span class="p">(</span><span class="kt">int</span> <span class="n">time</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="o">-&gt;</span><span class="n">time</span> <span class="o">=</span> <span class="n">time</span><span class="p">;</span>
        <span class="k">this</span><span class="o">-&gt;</span><span class="n">childs</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">add_child</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">child</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// cout &lt;&lt; "add " &lt;&lt; child-&gt;id &lt;&lt; " into " &lt;&lt; this-&gt;id &lt;&lt; endl;</span>
        <span class="k">this</span><span class="o">-&gt;</span><span class="n">childs</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">numOfMinutes</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">headID</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">manager</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">informTime</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// build tree</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">*&gt;</span> <span class="n">id_tree_vec</span> <span class="o">=</span> <span class="p">{};</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">id</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">id</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Node</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">(</span><span class="n">informTime</span><span class="p">[</span><span class="n">id</span><span class="p">]);</span>
            <span class="n">id_tree_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
        <span class="p">}</span>
        
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">id</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">id</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">manager_id</span> <span class="o">=</span> <span class="n">manager</span><span class="p">[</span><span class="n">id</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">manager_id</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">id_tree_vec</span><span class="p">[</span><span class="n">manager_id</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">add_child</span><span class="p">(</span><span class="n">id_tree_vec</span><span class="p">[</span><span class="n">id</span><span class="p">]);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">rec</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">Node</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">childs</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>
            
            <span class="kt">int</span> <span class="n">max_child_result</span> <span class="o">=</span> <span class="o">-</span><span class="mi">9999999</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">c</span><span class="o">:</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">childs</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">max_child_result</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">max_child_result</span><span class="p">,</span> <span class="n">rec</span><span class="p">(</span><span class="n">c</span><span class="p">));</span>
            <span class="p">}</span>
            <span class="c1">// cout &lt;&lt; "in " &lt;&lt; root-&gt;id &lt;&lt; " max_child_result: " &lt;&lt; max_child_result &lt;&lt; endl;</span>
            <span class="k">return</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">time</span> <span class="o">+</span> <span class="n">max_child_result</span><span class="p">;</span>
        <span class="p">};</span>
        <span class="c1">// cout &lt;&lt; "finished!" &lt;&lt; id_tree_vec[headID]-&gt;id &lt;&lt; endl;</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">rec</span><span class="p">(</span><span class="n">id_tree_vec</span><span class="p">[</span><span class="n">headID</span><span class="p">]);</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <h2 id="动态规划">动态规划</h2> <h3 id="leetcode-1039切分三角形">Leetcode 1039：切分三角形</h3> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="p">:</span>
    <span class="nb">int</span> <span class="n">minScoreTriangulation</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;&amp;</span> <span class="k">values</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">int</span> <span class="k">size</span> <span class="o">=</span> <span class="k">values</span><span class="p">.</span><span class="k">size</span><span class="p">();</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;&gt;</span> <span class="n">dp</span><span class="p">(</span><span class="k">size</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span><span class="p">(</span><span class="k">size</span><span class="p">));</span>
        <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">step</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">step</span> <span class="o">&lt;</span> <span class="k">size</span><span class="p">;</span> <span class="o">++</span><span class="n">step</span><span class="p">)</span> <span class="p">{</span>
            <span class="o">//</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="nv">"[step: "</span> <span class="o">&lt;&lt;</span> <span class="n">step</span> <span class="o">&lt;&lt;</span> <span class="nv">"]"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">size</span> <span class="o">-</span> <span class="n">step</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
                <span class="o">//</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="nv">"enter: i["</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
 
                <span class="nb">int</span> <span class="k">temp</span> <span class="o">=</span> <span class="mi">9999999</span><span class="p">;</span>
                <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">i</span> <span class="o">+</span> <span class="n">step</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">step</span> <span class="o">&lt;</span> <span class="k">size</span><span class="p">)</span> <span class="p">{</span>
                        <span class="k">temp</span> <span class="o">=</span> <span class="k">min</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="o">+</span><span class="n">step</span><span class="p">]</span> <span class="o">+</span> <span class="k">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="k">values</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="k">values</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">step</span><span class="p">],</span> <span class="k">temp</span><span class="p">);</span>
                        <span class="o">//</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="nv">"dp[i][k]: "</span> <span class="o">&lt;&lt;</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
                        <span class="o">//</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="nv">"dp[k][i+step]: "</span> <span class="o">&lt;&lt;</span>  <span class="n">dp</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="o">+</span><span class="n">step</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
                        <span class="o">//</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="nv">"values[i] * values[k] * values[i+step]:"</span> <span class="o">&lt;&lt;</span> <span class="k">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="k">values</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="k">values</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">step</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
                        <span class="o">//</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="nv">"jisuan: "</span> <span class="o">&lt;&lt;</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="o">+</span><span class="n">step</span><span class="p">]</span> <span class="o">+</span> <span class="k">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="k">values</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="k">values</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">step</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
                        <span class="o">//</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="nv">"[i: "</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="nv">"; k: "</span> <span class="o">&lt;&lt;</span> <span class="n">k</span> <span class="o">&lt;&lt;</span> <span class="nv">"; i+step: "</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">+</span> <span class="n">step</span> <span class="o">&lt;&lt;</span> <span class="nv">"]: "</span> <span class="o">&lt;&lt;</span> <span class="k">temp</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>
                <span class="o">//</span> <span class="n">printf</span><span class="p">(</span><span class="nv">"set: dp[%d][%d]: %d</span><span class="se">\n</span><span class="nv">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="n">step</span><span class="p">,</span> <span class="k">temp</span><span class="p">);</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="o">+</span><span class="n">step</span><span class="p">]</span> <span class="o">=</span>  <span class="k">temp</span><span class="p">;</span>
                
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="k">size</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="leetcode-2304-网格中的最小路径代价">Leetcode 2304： 网格中的最小路径代价</h3> <ul> <li>暴力 DP：</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">minPathCost</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">grid</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">moveCost</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">dp</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">row_num</span> <span class="o">=</span> <span class="n">grid</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="kt">int</span> <span class="n">col_num</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">row_num</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">line_result</span> <span class="o">=</span> <span class="p">{};</span>
            <span class="n">dp</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">line_result</span><span class="p">);</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">col_num</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">col_num</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
        <span class="p">}</span>

        <span class="kt">int</span> <span class="n">MAX_NUM</span> <span class="o">=</span> <span class="mi">1410065404</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">row_num</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">col_num</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
                <span class="kt">int</span> <span class="n">min_dp</span> <span class="o">=</span> <span class="n">MAX_NUM</span><span class="p">;</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="n">col_num</span><span class="p">;</span> <span class="o">++</span><span class="n">m</span><span class="p">)</span> <span class="p">{</span>
                    <span class="c1">// cout &lt;&lt; "forward is (i - 1): " &lt;&lt; i - 1 &lt;&lt; " m: " &lt;&lt; m &lt;&lt; " moveCost[grid[i-1][m]][j]: " &lt;&lt; moveCost[grid[i-1][m]][j] &lt;&lt; endl;</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">m</span><span class="p">]</span> <span class="o">+</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">moveCost</span><span class="p">[</span><span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">m</span><span class="p">]][</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_dp</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">min_dp</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">m</span><span class="p">]</span> <span class="o">+</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">moveCost</span><span class="p">[</span><span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">m</span><span class="p">]][</span><span class="n">j</span><span class="p">];</span>
                    <span class="p">}</span>
                    
                <span class="p">}</span>

                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_dp</span><span class="p">;</span>
                <span class="c1">// cout &lt;&lt; "to i: " &lt;&lt; i &lt;&lt; " j: " &lt;&lt; j &lt;&lt; " dp value: " &lt;&lt; dp[i][j] &lt;&lt; endl;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">MAX_NUM</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">col_num</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">row_num</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">result</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">row_num</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <ul> <li>优化：原地修改【直接从下到上！！！】</li> </ul> <h2 id="bfs">BFS</h2> <ul> <li>Leetcode 2451</li> <li>BFS 很适合确定层数！</li> </ul> <h2 id="贪心算法">贪心算法</h2> <h3 id="leetcode-1053-更换顺序字典序最小序列">Leetcode 1053 更换顺序字典序最小序列</h3> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/EniqbAu5noCw84xQmyUcbqUjnTc-480.webp 480w, /assets/img/feishu_docs_static/EniqbAu5noCw84xQmyUcbqUjnTc-800.webp 800w, /assets/img/feishu_docs_static/EniqbAu5noCw84xQmyUcbqUjnTc-1400.webp 1400w, " sizes="95vw" type="image/webp"></source> <img src="/assets/img/feishu_docs_static/EniqbAu5noCw84xQmyUcbqUjnTc.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">prevPermOpt1</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">arr</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">arr</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">swap</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">arr</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">last_one_up</span> <span class="o">=</span> <span class="mi">99999</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">last_index</span> <span class="o">=</span> <span class="n">arr</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">last_index</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="p">[</span><span class="n">last_index</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">last_one_up</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">last_one_up</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">last_index</span><span class="p">];</span>
                <span class="n">last_index</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">last_index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">arr</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">last_one_up</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">last_index</span><span class="p">];</span>
            <span class="p">}</span>
            <span class="kt">int</span> <span class="n">second_index</span> <span class="o">=</span> <span class="n">arr</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">second_index</span> <span class="o">&gt;</span> <span class="n">last_index</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="p">[</span><span class="n">second_index</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">last_one_up</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// cout &lt;&lt; "arr[second_index]: " &lt;&lt; arr[second_index] &lt;&lt; "; last_one_up: " &lt;&lt; last_one_up &lt;&lt; endl; </span>
                <span class="o">--</span><span class="n">second_index</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="kt">int</span> <span class="n">second_one_up</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">second_index</span><span class="p">];</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">second_index</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">last_index</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="p">[</span><span class="n">second_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">second_one_up</span><span class="p">)</span> <span class="p">{</span>
                <span class="o">--</span><span class="n">second_index</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="c1">// cout &lt;&lt; "last_index: " &lt;&lt; last_index &lt;&lt; "; second_index: " &lt;&lt; second_index &lt;&lt; endl; </span>
            <span class="n">swap</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">last_index</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">second_index</span><span class="p">]);</span>
            <span class="k">return</span> <span class="n">arr</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="kt">int</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">b</span><span class="o">=</span><span class="mi">3</span><span class="p">;</span>
    <span class="n">cont</span><span class="o">&lt;&lt;</span><span class="s">"KFC V me 50"</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="leetcode-1042-着色问题">Leetcode 1042 着色问题</h3> <ul> <li><a href="https://leetcode.cn/problems/flower-planting-with-no-adjacent/submissions/" rel="external nofollow noopener" target="_blank">1042. 不邻接植花 - 力扣（LeetCode）</a></li> <li>这个贪心用的非常直接，而且算法还是比较暴力且考验各种数据结构的熟练程度，是一个不错的代码</li> </ul> <h3 id="leetcode-2517-最大最小优化问题">Leetcode 2517 最大最小优化问题</h3> <ul> <li><a href="https://leetcode.cn/problems/maximum-tastiness-of-candy-basket/" rel="external nofollow noopener" target="_blank">https://leetcode.cn/problems/maximum-tastiness-of-candy-basket/</a></li> <li>这就是一个非常经典的最大最小优化问题</li> </ul> <h3 id="leetcode-2611-两方离线资源分配问题">Leetcode 2611 两方离线资源分配问题</h3> <ul> <li>这个题很简单，但是自己想却想不出来……</li> <li>思路就是计算所有资源分配给 1 和分配给 2 的 utility 差值，然后从高到低排序即可！但是如果搜索算法的效率就会很低，但是贪心直接就得到了最优解！</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">cmp</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span> 
    <span class="k">return</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>

<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">miceAndCheese</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">reward1</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">reward2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
        
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">reward1</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">reward1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">reward1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">reward2</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>

        <span class="n">sort</span><span class="p">(</span><span class="n">reward1</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">reward1</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">cmp</span><span class="p">);</span>
        

        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="p">(</span><span class="n">reward1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">reward2</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">reward1</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="n">reward2</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <h2 id="单调栈">单调栈</h2> <h3 id="leetcode-1019-获取链表的下一个更大的值">Leetcode 1019 获取链表的下一个更大的值</h3> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">package</span> <span class="n">main</span>

<span class="n">import</span> <span class="p">(</span>
    <span class="nv">"fmt"</span>
    <span class="nv">"sync"</span>
<span class="p">)</span>

<span class="k">type</span> <span class="n">ListNode</span> <span class="n">struct</span> <span class="p">{</span>
    <span class="n">Val</span>  <span class="nb">int</span>
    <span class="k">Next</span> <span class="o">*</span><span class="n">ListNode</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Item</span> <span class="n">struct</span> <span class="p">{</span>
    <span class="n">OriginIndex</span> <span class="nb">int</span>
    <span class="n">Val</span>         <span class="nb">int</span>
<span class="p">}</span>
<span class="k">type</span> <span class="n">ItemStack</span> <span class="n">struct</span> <span class="p">{</span>
    <span class="n">items</span> <span class="p">[]</span><span class="n">Item</span>
    <span class="k">lock</span>  <span class="n">sync</span><span class="p">.</span><span class="n">RWMutex</span>
<span class="p">}</span>

<span class="n">func</span> <span class="n">NewStack</span><span class="p">()</span> <span class="o">*</span><span class="n">ItemStack</span> <span class="p">{</span>
    <span class="n">s</span> <span class="p">:</span><span class="o">=</span> <span class="o">&amp;</span><span class="n">ItemStack</span><span class="p">{}</span>  <span class="o">//</span> <span class="err">初始化</span><span class="n">Stack</span>
    <span class="n">s</span><span class="p">.</span><span class="n">items</span> <span class="o">=</span> <span class="p">[]</span><span class="n">Item</span><span class="p">{}</span> <span class="o">//</span> <span class="err">初始化数组</span>
    <span class="k">return</span> <span class="n">s</span>
<span class="p">}</span>

<span class="n">func</span> <span class="p">(</span><span class="n">s</span> <span class="o">*</span><span class="n">ItemStack</span><span class="p">)</span> <span class="n">Print</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">fmt</span><span class="p">.</span><span class="n">Println</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">items</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">func</span> <span class="p">(</span><span class="n">s</span> <span class="o">*</span><span class="n">ItemStack</span><span class="p">)</span> <span class="n">Push</span><span class="p">(</span><span class="n">t</span> <span class="n">Item</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">s</span><span class="p">.</span><span class="k">lock</span><span class="p">.</span><span class="k">Lock</span><span class="p">()</span>
    <span class="n">defer</span> <span class="n">s</span><span class="p">.</span><span class="k">lock</span><span class="p">.</span><span class="n">Unlock</span><span class="p">()</span>
    <span class="o">//</span> <span class="n">fmt</span><span class="p">.</span><span class="n">Println</span><span class="p">(</span><span class="nv">"push t: "</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
    <span class="n">s</span><span class="p">.</span><span class="n">items</span> <span class="o">=</span> <span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">items</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">func</span> <span class="p">(</span><span class="n">s</span> <span class="o">*</span><span class="n">ItemStack</span><span class="p">)</span> <span class="n">Pop</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">s</span><span class="p">.</span><span class="k">lock</span><span class="p">.</span><span class="k">Lock</span><span class="p">()</span>
    <span class="n">defer</span> <span class="n">s</span><span class="p">.</span><span class="k">lock</span><span class="p">.</span><span class="n">Unlock</span><span class="p">()</span>
    <span class="n">if</span> <span class="n">len</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">items</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="k">index</span> <span class="p">:</span><span class="o">=</span> <span class="n">len</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">items</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="o">//</span> <span class="n">item</span> <span class="p">:</span><span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">items</span><span class="p">[</span><span class="k">index</span><span class="p">]</span>
    <span class="o">//</span> <span class="n">fmt</span><span class="p">.</span><span class="n">Println</span><span class="p">(</span><span class="nv">"pop t: "</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
    <span class="n">s</span><span class="p">.</span><span class="n">items</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">items</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="k">index</span><span class="p">]</span>
    <span class="o">//</span> <span class="n">fmt</span><span class="p">.</span><span class="n">Println</span><span class="p">(</span><span class="nv">"success pop !"</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">func</span> <span class="p">(</span><span class="n">s</span> <span class="o">*</span><span class="n">ItemStack</span><span class="p">)</span> <span class="n">Top</span><span class="p">()</span> <span class="o">*</span><span class="n">Item</span> <span class="p">{</span>
    <span class="n">s</span><span class="p">.</span><span class="k">lock</span><span class="p">.</span><span class="k">Lock</span><span class="p">()</span>
    <span class="n">defer</span> <span class="n">s</span><span class="p">.</span><span class="k">lock</span><span class="p">.</span><span class="n">Unlock</span><span class="p">()</span>

    <span class="o">//</span> <span class="n">fmt</span><span class="p">.</span><span class="n">Println</span><span class="p">(</span><span class="nv">"get index"</span><span class="p">)</span>
    <span class="n">if</span> <span class="n">len</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">items</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">nil</span>
    <span class="p">}</span>
    <span class="k">index</span> <span class="p">:</span><span class="o">=</span> <span class="n">len</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">items</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="n">item</span> <span class="p">:</span><span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">items</span><span class="p">[</span><span class="k">index</span><span class="p">]</span>
    <span class="o">//</span> <span class="n">fmt</span><span class="p">.</span><span class="n">Println</span><span class="p">(</span><span class="nv">"success top !"</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="n">item</span>
<span class="p">}</span>

<span class="n">func</span> <span class="p">(</span><span class="n">s</span> <span class="o">*</span><span class="n">ItemStack</span><span class="p">)</span> <span class="n">Len</span><span class="p">()</span> <span class="nb">int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">len</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">items</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">func</span> <span class="n">transver</span><span class="p">(</span><span class="n">head</span> <span class="o">*</span><span class="n">ListNode</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">head</span> <span class="o">!=</span> <span class="n">nil</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="p">.</span><span class="n">Println</span><span class="p">(</span><span class="n">head</span><span class="p">.</span><span class="n">Val</span><span class="p">)</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="p">.</span><span class="k">Next</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">func</span> <span class="n">nextLargerNodes</span><span class="p">(</span><span class="n">head</span> <span class="o">*</span><span class="n">ListNode</span><span class="p">)</span> <span class="p">[]</span><span class="nb">int</span> <span class="p">{</span>
    <span class="n">stack</span> <span class="p">:</span><span class="o">=</span> <span class="n">NewStack</span><span class="p">()</span>

    <span class="n">var</span> <span class="k">index</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">var</span> <span class="n">res</span> <span class="p">[]</span><span class="nb">int</span>
    <span class="k">for</span> <span class="n">head</span> <span class="o">!=</span> <span class="n">nil</span> <span class="p">{</span>
        <span class="n">if</span> <span class="n">stack</span><span class="p">.</span><span class="n">Len</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="n">var</span> <span class="n">item</span> <span class="n">Item</span>
            <span class="n">item</span><span class="p">.</span><span class="n">OriginIndex</span> <span class="o">=</span> <span class="k">index</span>
            <span class="n">item</span><span class="p">.</span><span class="n">Val</span> <span class="o">=</span> <span class="n">head</span><span class="p">.</span><span class="n">Val</span>
            <span class="n">stack</span><span class="p">.</span><span class="n">Push</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
            <span class="o">//</span> <span class="n">fmt</span><span class="p">.</span><span class="n">Println</span><span class="p">(</span><span class="nv">"current stack: "</span><span class="p">,</span> <span class="n">stack</span><span class="p">.</span><span class="n">items</span><span class="p">)</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">top_item</span> <span class="p">:</span><span class="o">=</span> <span class="n">stack</span><span class="p">.</span><span class="n">Top</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">top_item</span> <span class="o">!=</span> <span class="n">nil</span> <span class="o">&amp;&amp;</span> <span class="n">head</span><span class="p">.</span><span class="n">Val</span> <span class="o">&gt;</span> <span class="n">top_item</span><span class="p">.</span><span class="n">Val</span> <span class="p">{</span>
                <span class="o">//</span> <span class="n">fmt</span><span class="p">.</span><span class="n">Println</span><span class="p">(</span><span class="nv">"pop_item: "</span><span class="p">,</span> <span class="n">top_item</span><span class="p">.</span><span class="n">Val</span><span class="p">,</span> <span class="nv">" head.Val: "</span><span class="p">,</span> <span class="n">head</span><span class="p">.</span><span class="n">Val</span><span class="p">)</span>
                <span class="n">stack</span><span class="p">.</span><span class="n">Pop</span><span class="p">()</span>
                <span class="n">res</span><span class="p">[</span><span class="n">top_item</span><span class="p">.</span><span class="n">OriginIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">head</span><span class="p">.</span><span class="n">Val</span>
                <span class="n">top_item</span> <span class="o">=</span> <span class="n">stack</span><span class="p">.</span><span class="n">Top</span><span class="p">()</span>
                <span class="o">//</span> <span class="n">fmt</span><span class="p">.</span><span class="n">Println</span><span class="p">(</span><span class="nv">"next top_item: "</span><span class="p">,</span> <span class="n">top_item</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="n">var</span> <span class="n">item</span> <span class="n">Item</span>
            <span class="n">item</span><span class="p">.</span><span class="n">OriginIndex</span> <span class="o">=</span> <span class="k">index</span>
            <span class="n">item</span><span class="p">.</span><span class="n">Val</span> <span class="o">=</span> <span class="n">head</span><span class="p">.</span><span class="n">Val</span>
            <span class="n">stack</span><span class="p">.</span><span class="n">Push</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
            <span class="o">//</span> <span class="n">fmt</span><span class="p">.</span><span class="n">Println</span><span class="p">(</span><span class="nv">"current stack: "</span><span class="p">,</span> <span class="n">stack</span><span class="p">.</span><span class="n">items</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">append</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">index</span> <span class="o">=</span> <span class="k">index</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="p">.</span><span class="k">Next</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">res</span>
<span class="p">}</span>

<span class="n">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">var</span> <span class="n">head</span> <span class="o">=</span> <span class="k">new</span><span class="p">(</span><span class="n">ListNode</span><span class="p">)</span>
    <span class="n">head</span><span class="p">.</span><span class="n">Val</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="n">var</span> <span class="k">second</span> <span class="o">=</span> <span class="k">new</span><span class="p">(</span><span class="n">ListNode</span><span class="p">)</span>
    <span class="k">second</span><span class="p">.</span><span class="n">Val</span> <span class="o">=</span> <span class="mi">7</span>
    <span class="n">head</span><span class="p">.</span><span class="k">Next</span> <span class="o">=</span> <span class="k">second</span>

    <span class="n">var</span> <span class="n">third</span> <span class="o">=</span> <span class="k">new</span><span class="p">(</span><span class="n">ListNode</span><span class="p">)</span>
    <span class="n">third</span><span class="p">.</span><span class="n">Val</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="k">second</span><span class="p">.</span><span class="k">Next</span> <span class="o">=</span> <span class="n">third</span>

    <span class="n">var</span> <span class="n">fourth</span> <span class="o">=</span> <span class="k">new</span><span class="p">(</span><span class="n">ListNode</span><span class="p">)</span>
    <span class="n">fourth</span><span class="p">.</span><span class="n">Val</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="n">third</span><span class="p">.</span><span class="k">Next</span> <span class="o">=</span> <span class="n">fourth</span>

    <span class="n">var</span> <span class="n">fifth</span> <span class="o">=</span> <span class="k">new</span><span class="p">(</span><span class="n">ListNode</span><span class="p">)</span>
    <span class="n">fifth</span><span class="p">.</span><span class="n">Val</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="n">fourth</span><span class="p">.</span><span class="k">Next</span> <span class="o">=</span> <span class="n">fifth</span>

    <span class="k">result</span> <span class="p">:</span><span class="o">=</span> <span class="n">nextLargerNodes</span><span class="p">(</span><span class="n">head</span><span class="p">)</span>
    <span class="n">fmt</span><span class="p">.</span><span class="n">Println</span><span class="p">(</span><span class="k">result</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="请复习leetcode-907-子数组的最小值之和">【请复习】Leetcode 907 子数组的最小值之和</h3> <ul> <li>参考文献：<a href="https://lfool.github.io/LFool-Notes/algorithm/%E5%8D%95%E8%B0%83%E6%A0%88-%E6%8B%93%E5%B1%95%E5%BA%94%E7%94%A8.html" rel="external nofollow noopener" target="_blank">https://lfool.github.io/LFool-Notes/algorithm/%E5%8D%95%E8%B0%83%E6%A0%88-%E6%8B%93%E5%B1%95%E5%BA%94%E7%94%A8.html</a> </li> </ul> <h2 id="数论">数论</h2> <h3 id="负二进制模拟">负二进制模拟</h3> <ul> <li>这是一个在 KTV 写的题，当时没有写出来，现在回想一下还是比较简单的。</li> <li> <p>第一步，先要将十进制数进行二进制分解</p> <ul> <li>27 =&gt; 16 + 8 + 2 + 1</li> </ul> </li> <li> <p>第二步，将这些数中无法在二进制中取得负数的值转化一下</p> <ul> <li>8 = 16 + (-8)</li> <li>2 = 4 + (-2)</li> </ul> </li> <li> <p>第三步，从低位到高位将转化后的二进制数组写出来，slice 中第一位表示负二进制数，第二位表示出现的次数</p> <ul> <li>[(1, 1), (-2, 1), (4, 1), (-8, 1), (16, 2)]</li> </ul> </li> <li> <p>第四步，对出现大于等于 2 和小于等于-1 的情况进行处理</p> <ul> <li>大于等于 2：当前位减去 2，高一位减去 1</li> <li>小于等于-1：当前位加上 2，高一位加上 1</li> </ul> </li> <li>第五步，一个 while 循环，直到最高位置出现的数量为 0 或 1 结束即可！</li> </ul> <h2 id="双指针">双指针</h2> <ul> <li> <p>链表中的双指针：</p> <ul> <li>中间相差 k 可以获取从前后开始的第 k 个节点 - <a href="https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/" rel="external nofollow noopener" target="_blank">https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/</a> </li> <li>快指针走 2 步，慢指针走 1 步：可以在不知道 n 的情况下获得中点的位置！ - <a href="https://leetcode.cn/problems/middle-of-the-linked-list/" rel="external nofollow noopener" target="_blank">https://leetcode.cn/problems/middle-of-the-linked-list/</a> </li> <li>快指针走 2 步，慢指针走 1 步：可以判断一个链表是否成环！【因为只要有环，肯定会让快慢指针重合的，没有环肯定就直接走了！】</li> <li>同速指针：找到两个链表的相交 node！！【同时应该考虑链表的长度~】</li> </ul> </li> <li> <p>数组中的双指针</p> <ul> <li>左右窗口双指针：用于左右压缩空间</li> <li>快慢双指针：一般是一个指针比较快，另一个指针比较慢，一般是用于原地覆盖 nums！！</li> </ul> </li> </ul> <h3 id="lcr-140-链表的倒数第-k-个-node---快慢指针">LCR. 140 链表的倒数第 k 个 node - 快慢指针</h3> <ul> <li>快慢指针，快指针比慢指针多走 k 步，最后快指针到 null 的时候，倒数第 k 个就慢指针的位置。</li> </ul> <div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">trainingPlan</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="nb">head</span><span class="p">,</span> <span class="n">int</span> <span class="n">cnt</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ListNode</span><span class="o">*</span> <span class="n">fast</span> <span class="o">=</span> <span class="nb">head</span><span class="p">;</span>
        <span class="n">ListNode</span><span class="o">*</span> <span class="n">slow</span> <span class="o">=</span> <span class="nb">head</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cnt</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">fast</span> <span class="err">!</span><span class="o">=</span> <span class="n">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">slow</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="leetcode-1410-字符串匹配和替换">Leetcode 1410 字符串匹配和替换</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">string</span> <span class="n">entityParser</span><span class="p">(</span><span class="n">string</span> <span class="n">text</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;</span> <span class="n">umap</span><span class="p">;</span>
        
        <span class="n">umap</span><span class="p">[</span><span class="s">"&amp;quot;"</span><span class="p">]</span> <span class="o">=</span> <span class="s">"</span><span class="se">\"</span><span class="s">"</span><span class="p">;</span>
        <span class="n">umap</span><span class="p">[</span><span class="s">"&amp;apos;"</span><span class="p">]</span> <span class="o">=</span> <span class="s">"</span><span class="se">\'</span><span class="s">"</span><span class="p">;</span>
        <span class="n">umap</span><span class="p">[</span><span class="s">"&amp;amp;"</span><span class="p">]</span> <span class="o">=</span> <span class="s">"&amp;"</span><span class="p">;</span>
        <span class="n">umap</span><span class="p">[</span><span class="s">"&amp;gt;"</span><span class="p">]</span> <span class="o">=</span> <span class="s">"&gt;"</span><span class="p">;</span>
        <span class="n">umap</span><span class="p">[</span><span class="s">"&amp;lt;"</span><span class="p">]</span> <span class="o">=</span> <span class="s">"&lt;"</span><span class="p">;</span>
        <span class="n">umap</span><span class="p">[</span><span class="s">"&amp;frasl;"</span><span class="p">]</span> <span class="o">=</span> <span class="s">"/"</span><span class="p">;</span>

        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">left_fix</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">right_fix</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">to_copy_str_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">string</span> <span class="n">result</span> <span class="o">=</span> <span class="s">""</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">text</span><span class="p">.</span><span class="n">length</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">text</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'&amp;'</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
                <span class="n">left_fix</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                <span class="c1">// cout &lt;&lt; "left: " &lt;&lt; left &lt;&lt; endl; </span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">text</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">';'</span> <span class="o">&amp;&amp;</span> <span class="n">left_fix</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
                <span class="n">right_fix</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                <span class="c1">// cout &lt;&lt; "right: " &lt;&lt; right &lt;&lt; endl; </span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">left_fix</span> <span class="o">&amp;&amp;</span> <span class="n">right_fix</span> <span class="o">&amp;&amp;</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">text</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">text</span><span class="p">.</span><span class="n">length</span><span class="p">())</span> <span class="p">{</span>
                <span class="n">string</span> <span class="n">need_judge_substr</span> <span class="o">=</span> <span class="n">text</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

                <span class="c1">// cout &lt;&lt; "need_judge_substr: " &lt;&lt; need_judge_substr &lt;&lt; endl; </span>
                <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">umap</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">need_judge_substr</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">iter</span> <span class="o">!=</span> <span class="n">umap</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
                    <span class="kt">int</span> <span class="n">to_copy_len</span> <span class="o">=</span> <span class="n">left</span> <span class="o">-</span> <span class="n">to_copy_str_index</span><span class="p">;</span>
                    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">q</span> <span class="o">=</span> <span class="n">to_copy_str_index</span><span class="p">;</span> <span class="n">q</span> <span class="o">&lt;</span> <span class="n">to_copy_str_index</span> <span class="o">+</span> <span class="n">to_copy_len</span><span class="p">;</span> <span class="o">++</span><span class="n">q</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">result</span> <span class="o">+=</span> <span class="n">text</span><span class="p">[</span><span class="n">q</span><span class="p">];</span>
                    <span class="p">}</span>
                    <span class="n">result</span> <span class="o">+=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
                    
                    <span class="n">to_copy_str_index</span> <span class="o">=</span> <span class="n">right</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
                    <span class="n">left_fix</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
                    <span class="n">right_fix</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="n">left_fix</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
                    <span class="n">right_fix</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">to_copy_str_index</span> <span class="o">&lt;</span> <span class="n">text</span><span class="p">.</span><span class="n">length</span><span class="p">())</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">to_copy_len</span> <span class="o">=</span> <span class="n">text</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">-</span> <span class="n">to_copy_str_index</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">q</span> <span class="o">=</span> <span class="n">to_copy_str_index</span><span class="p">;</span> <span class="n">q</span> <span class="o">&lt;</span> <span class="n">to_copy_str_index</span> <span class="o">+</span> <span class="n">to_copy_len</span><span class="p">;</span> <span class="o">++</span><span class="n">q</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="n">text</span><span class="p">[</span><span class="n">q</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="leetcode-142-环形链表-ii">Leetcode 142 环形链表 II</h3> <ul> <li>这道题真的是双指针的代表性题目 <ul> <li>先变速指针：相遇之后，快指针走 2k 步，慢指针走 k 步。其中 k 肯定是环的倍数！</li> <li>后同速指针：那么从 head 到相遇点是 k，整个环也是 k，因此可以从数学上获得入环的起点！</li> </ul> </li> </ul> <div class="row mt-3"> <figure> <picture> <source class="responsive-img-srcset" srcset=" /assets/img/feishu_docs_static/PdICb8ez0odjTsxOYcXcZCV1n7e-480.webp 480w, /assets/img/feishu_docs_static/PdICb8ez0odjTsxOYcXcZCV1n7e-800.webp 800w, /assets/img/feishu_docs_static/PdICb8ez0odjTsxOYcXcZCV1n7e-1400.webp 1400w, " sizes="95vw" type="image/webp"></source> <img src="/assets/img/feishu_docs_static/PdICb8ez0odjTsxOYcXcZCV1n7e.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <h3 id="leetcode--5-最长回文子串">Leetcode 5 最长回文子串</h3> <ul> <li>尽量记住，子串一般使用双指针！</li> <li>这道题的思路应该是从中间开始向左右指针，这样复杂度每个都可以压倒 O(n)，总共需要外层训练 O(n)次，复杂度是 O(n^2)</li> </ul> <div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="n">test</span><span class="p">(</span><span class="nb">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">,</span> <span class="n">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">int</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="nb">size</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">i</span><span class="o">--</span><span class="p">;</span>
            <span class="n">j</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">int</span> <span class="n">len</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>
        <span class="n">res</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">res</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
        <span class="p">//</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s2">"push: "</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="s2">" "</span> <span class="o">&lt;&lt;</span> <span class="n">len</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nb">string</span> <span class="n">longestPalindrome</span><span class="p">(</span><span class="nb">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">int</span> <span class="n">max_len</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">};</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="nb">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="n">sub_str_0</span> <span class="o">=</span> <span class="n">test</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
            <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="n">sub_str_1</span> <span class="o">=</span> <span class="n">test</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">sub_str_0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">max_len</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sub_str_0</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
                <span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sub_str_0</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
                <span class="n">max_len</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">sub_str_1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">max_len</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sub_str_1</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
                <span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sub_str_1</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
                <span class="n">max_len</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">substr</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <h2 id="滑动窗口">滑动窗口</h2> <h3 id="请复习滑动窗口的模板">【请复习】滑动窗口的模板</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* 滑动窗口算法框架 */</span>
<span class="kt">void</span> <span class="nf">slidingWindow</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 用合适的数据结构记录窗口中的数据</span>
    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">window</span><span class="p">;</span>
    
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">right</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
        <span class="c1">// c 是将移入窗口的字符</span>
        <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">right</span><span class="p">];</span>
        <span class="n">window</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="c1">// 增大窗口</span>
        <span class="n">right</span><span class="o">++</span><span class="p">;</span>
        <span class="c1">// 进行窗口内数据的一系列更新</span>
        <span class="p">...</span>

        <span class="cm">/*** debug 输出的位置 ***/</span>
        <span class="c1">// 注意在最终的解法代码中不要 print</span>
        <span class="c1">// 因为 IO 操作很耗时，可能导致超时</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"window: [%d, %d)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
        <span class="cm">/********************/</span>
        
        <span class="c1">// 判断左侧窗口是否要收缩</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">window</span> <span class="n">needs</span> <span class="n">shrink</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// d 是将移出窗口的字符</span>
            <span class="kt">char</span> <span class="n">d</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">left</span><span class="p">];</span>
            <span class="n">window</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="c1">// 缩小窗口</span>
            <span class="n">left</span><span class="o">++</span><span class="p">;</span>
            <span class="c1">// 进行窗口内数据的一系列更新</span>
            <span class="p">...</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="leetcode-3">Leetcode 3</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">lengthOfLongestSubstring</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">mp</span><span class="p">;</span>
    
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">max_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">right</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">right</span><span class="p">];</span>
        <span class="n">mp</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
        <span class="n">right</span><span class="o">++</span><span class="p">;</span>
        <span class="c1">// cout &lt;&lt; "left: " &lt;&lt; left &lt;&lt; " right: " &lt;&lt; right &lt;&lt; " : ";</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">mp</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">char</span> <span class="n">left_c</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">left</span><span class="p">];</span>
            <span class="n">mp</span><span class="p">[</span><span class="n">left_c</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
            <span class="n">left</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span> 
        <span class="n">max_len</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">max_len</span><span class="p">,</span> <span class="n">right</span><span class="o">-</span><span class="n">left</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">max_len</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="位操作">位操作</h2> <h3 id="判断一个-list-中元素出现偶数还是奇数32-位以内">判断一个 list 中元素出现偶数还是奇数（32 位以内）</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">}</span>
<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">res</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">result</span> <span class="o">^=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="c1">// 异或操作, 出现一次的位会被设置为1</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="lowbit-操作">lowbit 操作</h3> <ul> <li> <p>快速找到一个数中二进制的最高位置的 1 以及<strong>后面所有 0</strong>的组合</p> <ul> <li>原码 = 101010101000000</li> <li>补码 = 010101011000000</li> <li>原码&amp;补码 = 000000001000000 = 1000000</li> </ul> </li> <li> <p>求二进制中 1 的个数</p> <ul> <li>每次都通过 lowbit()获取最高位置的 1 及后续 0 串，然后不断减</li> </ul> </li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">lowbit</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">n</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">-</span><span class="n">n</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">n</span> <span class="o">-=</span> <span class="n">lowbit</span><span class="p">(</span><span class="n">n</span><span class="p">);</span> <span class="c1">//每次减掉最后一个1及其后面所有0的部分</span>
        <span class="n">res</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">res</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <ul> <li>判断是否最多只有一个字符出现奇数次的操作，也就是判断一个二进制数字是为全为 0 或仅有一位 1，可配合 lowbit 来做，若 cnt 与 lowbit(cnt) = cnt &amp; -cnt 相等，说明满足要求。 <ul> <li>考虑到对 lowbit(x) = x &amp; -x 不熟悉的同学，这里再做简单介绍：lowbit(x) 表示 x 的二进制表示<strong>最低位的 1 所在的位置对应的值</strong>，即仅保留从最低位起的第一个 1，其余位均以 0 填充：</li> <li>x = 6，其二进制表示为 110 ，那么 lowbit(6)=(010)=2</li> <li>x = 12，其二进制表示为 1100，那么 lowbit(12)=(100)=4</li> </ul> </li> </ul> <h3 id="伪回文路径判断条件">伪回文路径判断条件</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">mask</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
</code></pre></div></div> <ul> <li>Leetcode 1457</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
Definition for a binary tree node.
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};
 */</span>

<span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">struct</span> <span class="nc">TreeNode</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">left</span><span class="p">;</span>
    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">right</span><span class="p">;</span>
    <span class="n">TreeNode</span><span class="p">()</span> <span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">left</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">),</span> <span class="n">right</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">TreeNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">left</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">),</span> <span class="n">right</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">TreeNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">TreeNode</span> <span class="o">*</span><span class="n">left</span><span class="p">,</span> <span class="n">TreeNode</span> <span class="o">*</span><span class="n">right</span><span class="p">)</span> <span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">left</span><span class="p">(</span><span class="n">left</span><span class="p">),</span> <span class="n">right</span><span class="p">(</span><span class="n">right</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>

    <span class="kt">int</span> <span class="n">preTransver</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">result</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cnt</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"check root-&gt;val [add one]: "</span> <span class="o">&lt;&lt;</span>  <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="c1">// umap[root-&gt;val] += 1;</span>
        <span class="n">cnt</span> <span class="o">^=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"cnt: "</span> <span class="o">&lt;&lt;</span> <span class="n">cnt</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="n">cnt</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"is hui wen"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
                
                <span class="k">return</span> <span class="n">result</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"not is hui wen"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
                <span class="c1">// umap[root-&gt;val] -= 1;</span>
                <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">preTransver</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">cnt</span><span class="p">);</span>
            <span class="c1">// umap[root-&gt;left-&gt;val] -= 1;</span>
            <span class="c1">// cout &lt;&lt; "[sub one]: " &lt;&lt; root-&gt;left-&gt;val &lt;&lt; endl;</span>
        <span class="p">}</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">preTransver</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">cnt</span><span class="p">);</span>
            <span class="c1">// umap[root-&gt;right-&gt;val] -= 1;</span>
            <span class="c1">// cout &lt;&lt; "[sub one]: " &lt;&lt; root-&gt;right-&gt;val &lt;&lt; endl;</span>
        <span class="p">}</span>
        
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>

    <span class="p">}</span>
    <span class="kt">int</span> <span class="nf">pseudoPalindromicPaths</span> <span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">preTransver</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">cnt</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
    <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

    <span class="n">Solution</span> <span class="o">*</span><span class="n">sol</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Solution</span><span class="p">();</span>

    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">sol</span><span class="o">-&gt;</span><span class="n">pseudoPalindromicPaths</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> </div> </article> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2025 Linchang Xiao. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?7b30caa5023af4af8408a472dc4e1ebb"></script> <script defer src="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js?d633890033921b33e0ceb13d22340a9c"></script> <script defer src="/assets/js/common.js?acdb9690d7641b2f8d40529018c71a01"></script> <script defer src="/assets/js/copy_code.js?9b43d6e67ddc7c0855b1478ee4c48c2d" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>