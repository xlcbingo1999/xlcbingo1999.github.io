<!DOCTYPE html> <html lang="cn"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Python 相关指令 | Linchang Xiao</title> <meta name="author" content="Linchang Xiao"> <meta name="description" content="Python 相关指令"> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?19f3075a2d19613090fe9e16b564e1fe" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/icon.jpg?7b7b29ac9f6063e03543e5148578c7f5"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://xlcbingo1999.github.io/blog/2021/Python/"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?e74e74bf055e5729d44a7d031a5ca6a5" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?6185d15ea1982787ad7f435576553d64"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/">Linchang Xiao</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about</a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">blog</a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fa-solid fa-moon"></i> <i class="fa-solid fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">Python 相关指令</h1> <p class="post-meta">October 6, 2021</p> <p class="post-tags"> <a href="/blog/2021"> <i class="fa-solid fa-calendar fa-sm"></i> 2021 </a>   ·   <a href="/blog/tag/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%AE%B0"> <i class="fa-solid fa-hashtag fa-sm"></i> 技术杂记</a>     ·   <a href="/blog/category/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%AE%B0"> <i class="fa-solid fa-tag fa-sm"></i> 技术杂记</a>   </p> </header> <article class="post-content"> <div id="markdown-content"> <h2 id="yield-的一些特殊用法">yield 的一些特殊用法</h2> <ul> <li><a href="https://blog.csdn.net/mieleizhi0522/article/details/82142856" rel="external nofollow noopener" target="_blank">https://blog.csdn.net/mieleizhi0522/article/details/82142856</a></li> <li>带 yield 的函数是一个生成器，而不是一个函数了，这个生成器有一个函数就是 next 函数，next 就相当于“下一步”生成哪个数，这一次的 next 开始的地方是接着上一次的 next 停止的地方执行的，所以调用 next 的时候，生成器并不会从 foo 函数的开始执行，只是接着上一步停止的地方开始，然后遇到 yield 后，return 出要生成的数，此步就结束。</li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">starting...</span><span class="sh">"</span><span class="p">)</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="k">yield</span> <span class="mi">4</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">res:</span><span class="sh">"</span><span class="p">,</span><span class="n">res</span><span class="p">)</span>
<span class="n">g</span> <span class="o">=</span> <span class="nf">foo</span><span class="p">()</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">next</span><span class="p">(</span><span class="n">g</span><span class="p">))</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">*</span><span class="sh">"</span><span class="o">*</span><span class="mi">20</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">next</span><span class="p">(</span><span class="n">g</span><span class="p">))</span>

<span class="c1"># starting...
# 4
# ********************
# res: None (这里是因为最后一步为yield 4, 返回了之后下次进入函数就没有右值了！)
# 4
</span></code></pre></div></div> <ul> <li>这里有一个 B 站的专栏学习，可以参考： <ul> <li><a href="https://www.bilibili.com/read/cv11290757?spm_id_from=333.999.0.0" rel="external nofollow noopener" target="_blank">https://www.bilibili.com/read/cv11290757?spm_id_from=333.999.0.0</a></li> <li> <a href="https://www.bilibili.com/read/cv11291938?spm_id_from=333.999.0.0" rel="external nofollow noopener" target="_blank">【simpy】光速上手 2——简单的 process 交互</a> <ul> <li>强行中断可以使用：interrupt</li> </ul> </li> </ul> </li> </ul> <h2 id="python-import-踩坑指南">python import 踩坑指南</h2> <ul> <li>参考文章：<a href="https://blog.csdn.net/karmayh/article/details/108697835" rel="external nofollow noopener" target="_blank">https://blog.csdn.net/karmayh/article/details/108697835</a> </li> <li> <p>问题就来自于 sys.path 的路径设置问题</p> <ul> <li>详细的教程如下： <a href="http://www.coolpython.net/python_senior/module_concept/modify-sys-path.html" rel="external nofollow noopener" target="_blank">http://www.coolpython.net/python_senior/module_concept/modify-sys-path.html</a> </li> <li>sys.path 是一个列表，存放的是 python 搜索模块时可以搜索的路径，启动 python 脚本时，会将执行当前命令所在的目录添加到这个列表中，而且是在列表的最前面，正是因为这个操作，你才能在自己的项目里引用自己编写的模块，当模块名称与第三方模块或系统模块冲突时，优先引用项目里的模块。通常，sys.python 里的内容如下所示：</li> <li>执行打印 sys.path 的操作结果如下：</li> </ul> </li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="n">sys</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">sys</span><span class="p">.</span><span class="n">path</span>
<span class="p">[</span><span class="sh">''</span><span class="p">,</span> <span class="sh">'</span><span class="s">/home/linchangxiao/anaconda3/envs/py36tf112/lib/python36.zip</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">/home/linchangxiao/anaconda3/envs/py36tf112/lib/python3.6</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">/home/linchangxiao/anaconda3/envs/py36tf112/lib/python3.6/lib-dynload</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">/home/linchangxiao/anaconda3/envs/py36tf112/lib/python3.6/site-packages</span><span class="sh">'</span><span class="p">]</span>
</code></pre></div></div> <h2 id="虚拟环境与包管理器的相关问题">虚拟环境与包管理器的相关问题</h2> <h3 id="conda-安装与设置相关操作">Conda 安装与设置相关操作</h3> <ul> <li>安装流程：<a href="https://zhuanlan.zhihu.com/p/459607806" rel="external nofollow noopener" target="_blank">Ubuntu 安装 conda - 知乎 (zhihu.com)</a> </li> </ul> <div class="language-apache highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wget https://mirrors.bfsu.edu.cn/anaconda/archive/[Anaconda3-2023.07-2-Linux-x86_64.sh](https://repo.anaconda.com/archive/Anaconda3-2023.07-2-Linux-x86_64.sh) --no-check-certificate

bash Anaconda3-2023.07-2-Linux-x86_64.sh

source ~/.bashrc
</code></pre></div></div> <h3 id="conda-和-pip-源---建议直接安装-conda-后直接修改">Conda 和 Pip 源 - 建议直接安装 conda 后直接修改</h3> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">vim</span> <span class="o">~/</span><span class="nc">.condarc</span>


<span class="nt">channels</span><span class="o">:</span>
  <span class="nt">-</span> <span class="nt">defaults</span>
<span class="nt">show_channel_urls</span><span class="o">:</span> <span class="nt">true</span>
<span class="nt">default_channels</span><span class="o">:</span>
  <span class="nt">-</span> <span class="nt">https</span><span class="o">://</span><span class="nt">mirrors</span><span class="nc">.tuna.tsinghua.edu.cn</span><span class="o">/</span><span class="nt">anaconda</span><span class="o">/</span><span class="nt">pkgs</span><span class="o">/</span><span class="nt">main</span>
  <span class="nt">-</span> <span class="nt">https</span><span class="o">://</span><span class="nt">mirrors</span><span class="nc">.tuna.tsinghua.edu.cn</span><span class="o">/</span><span class="nt">anaconda</span><span class="o">/</span><span class="nt">pkgs</span><span class="o">/</span><span class="nt">r</span>
  <span class="nt">-</span> <span class="nt">https</span><span class="o">://</span><span class="nt">mirrors</span><span class="nc">.tuna.tsinghua.edu.cn</span><span class="o">/</span><span class="nt">anaconda</span><span class="o">/</span><span class="nt">pkgs</span><span class="o">/</span><span class="nt">msys2</span>
<span class="nt">custom_channels</span><span class="o">:</span>
  <span class="nt">conda-forge</span><span class="o">:</span> <span class="nt">https</span><span class="o">://</span><span class="nt">mirrors</span><span class="nc">.tuna.tsinghua.edu.cn</span><span class="o">/</span><span class="nt">anaconda</span><span class="o">/</span><span class="nt">cloud</span>
  <span class="nt">msys2</span><span class="o">:</span> <span class="nt">https</span><span class="o">://</span><span class="nt">mirrors</span><span class="nc">.tuna.tsinghua.edu.cn</span><span class="o">/</span><span class="nt">anaconda</span><span class="o">/</span><span class="nt">cloud</span>
  <span class="nt">bioconda</span><span class="o">:</span> <span class="nt">https</span><span class="o">://</span><span class="nt">mirrors</span><span class="nc">.tuna.tsinghua.edu.cn</span><span class="o">/</span><span class="nt">anaconda</span><span class="o">/</span><span class="nt">cloud</span>
  <span class="nt">menpo</span><span class="o">:</span> <span class="nt">https</span><span class="o">://</span><span class="nt">mirrors</span><span class="nc">.tuna.tsinghua.edu.cn</span><span class="o">/</span><span class="nt">anaconda</span><span class="o">/</span><span class="nt">cloud</span>
  <span class="nt">pytorch</span><span class="o">:</span> <span class="nt">https</span><span class="o">://</span><span class="nt">mirrors</span><span class="nc">.tuna.tsinghua.edu.cn</span><span class="o">/</span><span class="nt">anaconda</span><span class="o">/</span><span class="nt">cloud</span>
  <span class="nt">pytorch-lts</span><span class="o">:</span> <span class="nt">https</span><span class="o">://</span><span class="nt">mirrors</span><span class="nc">.tuna.tsinghua.edu.cn</span><span class="o">/</span><span class="nt">anaconda</span><span class="o">/</span><span class="nt">cloud</span>
  <span class="nt">simpleitk</span><span class="o">:</span> <span class="nt">https</span><span class="o">://</span><span class="nt">mirrors</span><span class="nc">.tuna.tsinghua.edu.cn</span><span class="o">/</span><span class="nt">anaconda</span><span class="o">/</span><span class="nt">cloud</span>
  <span class="nt">deepmodeling</span><span class="o">:</span> <span class="nt">https</span><span class="o">://</span><span class="nt">mirrors</span><span class="nc">.tuna.tsinghua.edu.cn</span><span class="o">/</span><span class="nt">anaconda</span><span class="o">/</span><span class="nt">cloud</span><span class="o">/</span>
</code></pre></div></div> <h3 id="pip-包管理器的完整执行流程">pip 包管理器的完整执行流程</h3> <ul> <li>参考文献：<a href="https://blog.csdn.net/qq_33339479/article/details/93094774" rel="external nofollow noopener" target="_blank">pip 包管理工具-install 执行流程简单查看_%pip install ==_小屋子大侠的博客-CSDN 博客</a> </li> </ul> <h3 id="pipenv">Pipenv</h3> <ul> <li>有一些仓库会出现 Pipfile 和 Pipfile.lock，故使用这个会比较好一些？</li> <li>参考文献：<a href="https://pipenv-zh.readthedocs.io/zh_CN/latest/basics.html" rel="external nofollow noopener" target="_blank">Pipenv 的基本使用 — pipenv 2020.8.13.dev0 文档 (pipenv-zh.readthedocs.io)</a> </li> <li> <p>但是突然发现这个 Pipfile 根本没有任何的进度条提示，非常不方便，所以想转换为 requirements.txt：</p> <ul> <li>pipenv requirements &gt; requirements.txt &amp;&amp; pipenv requirements –dev-only &gt; requirements-dev.txt</li> </ul> </li> </ul> <h3 id="pip-生成-requirementstxt">pip 生成 requirements.txt</h3> <div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pip</span> <span class="s">freeze</span> <span class="s">&gt;</span> <span class="s">requirements.txt</span>
</code></pre></div></div> <h3 id="从源码在-conda-虚拟环境中安装一个-pip-包的流程">从源码在 conda 虚拟环境中安装一个 pip 包的流程</h3> <p><code class="language-plaintext highlighter-rouge">python -m pip install -e .</code> 是一个用于安装当前 Python 项目的命令，其中 <code class="language-plaintext highlighter-rouge">-e</code> 表示使用可编辑模式（editable mode）。这种模式下，安装的包实际上是在当前项目的源代码目录上创建的符号链接，而不是将包复制到 Python 安装目录。</p> <p>以下是这个命令的执行流程：</p> <ol> <li> <code class="language-plaintext highlighter-rouge">python -m pip</code>：使用 Python 解释器的 <code class="language-plaintext highlighter-rouge">pip</code> 模块进行包管理。</li> <li> <code class="language-plaintext highlighter-rouge">install</code>：指示 <code class="language-plaintext highlighter-rouge">pip</code> 安装包。</li> <li> <p><code class="language-plaintext highlighter-rouge">-e .</code>：使用可编辑模式安装当前目录的包。</p> <ul> <li> <code class="language-plaintext highlighter-rouge">-e</code> 或 <code class="language-plaintext highlighter-rouge">--editable</code> 表示使用编辑模式。</li> <li> <code class="language-plaintext highlighter-rouge">.</code> 表示当前目录，即安装当前项目。</li> </ul> </li> </ol> <p>在执行这个命令时，发生的一些关键步骤包括：</p> <ul> <li> <code class="language-plaintext highlighter-rouge">pip</code> 会在当前目录查找 <code class="language-plaintext highlighter-rouge">setup.py</code> 文件，该文件描述了项目的元信息和依赖关系。</li> <li> <code class="language-plaintext highlighter-rouge">pip</code> 将项目安装到一个虚拟环境中（如果存在），或者全局 Python 环境中。</li> <li>使用可编辑模式安装时，<code class="language-plaintext highlighter-rouge">pip</code> 不会将包复制到 Python 安装目录。相反，它会在当前项目的虚拟环境或全局环境中创建一个符号链接，指向项目的源代码目录。这样，对项目源代码的修改会立即反映在安装的包中，无需重新安装。</li> </ul> <p>这种可编辑模式通常用于开发过程中，允许开发人员实时调试和修改项目代码，而无需反复安装包。在项目开发过程中，经常会使用这种模式来快速测试和验证代码修改。</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">os</span>
<span class="kn">from</span> <span class="n">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

<span class="kn">from</span> <span class="n">setuptools</span> <span class="kn">import</span> <span class="n">find_packages</span>
<span class="kn">from</span> <span class="n">skbuild</span> <span class="kn">import</span> <span class="n">setup</span>

<span class="kn">import</span> <span class="n">legate.install_info</span> <span class="k">as</span> <span class="n">lg_install_info</span>

<span class="n">legate_dir</span> <span class="o">=</span> <span class="nc">Path</span><span class="p">(</span><span class="n">lg_install_info</span><span class="p">.</span><span class="n">libpath</span><span class="p">).</span><span class="n">parent</span><span class="p">.</span><span class="nf">as_posix</span><span class="p">()</span>

<span class="n">cmake_flags</span> <span class="o">=</span> <span class="p">[</span>
    <span class="sa">f</span><span class="sh">"</span><span class="s">-Dlegate_core_ROOT:STRING=</span><span class="si">{</span><span class="n">legate_dir</span><span class="si">}</span><span class="sh">"</span><span class="p">,</span>
<span class="p">]</span>

<span class="n">env_cmake_args</span> <span class="o">=</span> <span class="n">os</span><span class="p">.</span><span class="n">environ</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="sh">"</span><span class="s">CMAKE_ARGS</span><span class="sh">"</span><span class="p">)</span>
<span class="k">if</span> <span class="n">env_cmake_args</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
    <span class="n">cmake_flags</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">env_cmake_args</span><span class="p">)</span>
<span class="n">os</span><span class="p">.</span><span class="n">environ</span><span class="p">[</span><span class="sh">"</span><span class="s">CMAKE_ARGS</span><span class="sh">"</span><span class="p">]</span> <span class="o">=</span> <span class="sh">"</span><span class="s"> </span><span class="sh">"</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">cmake_flags</span><span class="p">)</span>


<span class="nf">setup</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="sh">"</span><span class="s">Legate Hello</span><span class="sh">"</span><span class="p">,</span>
    <span class="n">version</span><span class="o">=</span><span class="sh">"</span><span class="s">0.1</span><span class="sh">"</span><span class="p">,</span>
    <span class="n">description</span><span class="o">=</span><span class="sh">"</span><span class="s">A Hello World for Legate</span><span class="sh">"</span><span class="p">,</span>
    <span class="n">author</span><span class="o">=</span><span class="sh">"</span><span class="s">NVIDIA Corporation</span><span class="sh">"</span><span class="p">,</span>
    <span class="n">license</span><span class="o">=</span><span class="sh">"</span><span class="s">Apache 2.0</span><span class="sh">"</span><span class="p">,</span>
    <span class="n">classifiers</span><span class="o">=</span><span class="p">[</span>
        <span class="sh">"</span><span class="s">Intended Audience :: Developers</span><span class="sh">"</span><span class="p">,</span>
        <span class="sh">"</span><span class="s">Topic :: Database</span><span class="sh">"</span><span class="p">,</span>
        <span class="sh">"</span><span class="s">Topic :: Scientific/Engineering</span><span class="sh">"</span><span class="p">,</span>
        <span class="sh">"</span><span class="s">License :: OSI Approved :: Apache Software License</span><span class="sh">"</span><span class="p">,</span>
        <span class="sh">"</span><span class="s">Programming Language :: Python</span><span class="sh">"</span><span class="p">,</span>
        <span class="sh">"</span><span class="s">Programming Language :: Python :: 3.9</span><span class="sh">"</span><span class="p">,</span>
        <span class="sh">"</span><span class="s">Programming Language :: Python :: 3.10</span><span class="sh">"</span><span class="p">,</span>
        <span class="sh">"</span><span class="s">Programming Language :: Python :: 3.11</span><span class="sh">"</span><span class="p">,</span>
    <span class="p">],</span>
    <span class="n">packages</span><span class="o">=</span><span class="nf">find_packages</span><span class="p">(</span>
        <span class="n">where</span><span class="o">=</span><span class="sh">"</span><span class="s">.</span><span class="sh">"</span><span class="p">,</span>
        <span class="n">include</span><span class="o">=</span><span class="p">[</span><span class="sh">"</span><span class="s">hello</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">hello.*</span><span class="sh">"</span><span class="p">],</span>
    <span class="p">),</span>
    <span class="n">include_package_data</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
    <span class="n">zip_safe</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
<span class="p">)</span>
</code></pre></div></div> <h3 id="伟大的-mamba">伟大的 mamba</h3> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">conda</span> <span class="n">install</span> <span class="n">mamba</span> <span class="p">-</span><span class="n">c</span> <span class="n">conda</span><span class="p">-</span><span class="n">forge</span>
</code></pre></div></div> <h3 id="conda-删除-env">conda 删除 env</h3> <h2 id="vscode-的相关操作">Vscode 的相关操作</h2> <h3 id="搭建-conda-环境搭建-pylint">搭建 conda 环境、搭建 pylint</h3> <ul> <li>参考文档：<a href="https://ethanblog.com/tips/python-in-visual-studio-code-with-anaconda.html" rel="external nofollow noopener" target="_blank">https://ethanblog.com/tips/python-in-visual-studio-code-with-anaconda.html</a> </li> </ul> <h3 id="远程连接-notebook">远程连接 notebook</h3> <ul> <li>请直接用下面连接的方法即可完成 <ul> <li><a href="https://www.jianshu.com/p/f1a075457557" rel="external nofollow noopener" target="_blank">https://www.jianshu.com/p/f1a075457557</a></li> </ul> </li> </ul> <h3 id="远程安装-vscode-插件非常慢的解决方案">远程安装 vscode 插件非常慢的解决方案</h3> <ul> <li>参考文献：<a href="https://www.361shipin.com/blog/1553458388535345152" rel="external nofollow noopener" target="_blank">vscode 下链接远程服务器安装插件失败、速度慢等解决方法 (361shipin.com)</a> </li> <li>从 vsix 安装，从官网上下载，历史版本比较难下载到，需要注意。</li> </ul> <h3 id="debug-问题">Debug 问题</h3> <h4 id="invalid-value-encountered-in-long_scalars">Invalid value encountered in long_scalars</h4> <ul> <li><a href="https://zhpmatrix.github.io/2017/09/24/python-debug-experience/" rel="external nofollow noopener" target="_blank">[Python]记一次 Debug 经历</a></li> <li>自己也遇到了这个问题，抛出错误接不住</li> </ul> <h4 id="vscode-的-python-插件不支持-python-36-版本的问题">Vscode 的 python 插件不支持 python 3.6 版本的问题</h4> <ul> <li>参考文献：<a href="https://itcn.blog/p/5327568696.html" rel="external nofollow noopener" target="_blank">【vscode】python F5 调试 没反应 一闪而过 【已解决】-IT Blog (itcn.blog)</a> </li> <li>最近（2022 年 7 月 11 日）在使用 vscode 调试 python 时出现按 F5 无法进入调试的情况，经过一番查找，根本原因是 vscode 的 python 扩展插件的最新版本（2022.10.0）不再支持 python3.6 了</li> </ul> <h4 id="vscode-调试带参数">VScode 调试带参数</h4> <ul> <li>直接创建.vscode/launch.json 即可</li> </ul> <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="err">//</span><span class="w"> </span><span class="err">Use</span><span class="w"> </span><span class="err">IntelliSense</span><span class="w"> </span><span class="err">to</span><span class="w"> </span><span class="err">learn</span><span class="w"> </span><span class="err">about</span><span class="w"> </span><span class="err">possible</span><span class="w"> </span><span class="err">attributes.</span><span class="w">
    </span><span class="err">//</span><span class="w"> </span><span class="err">Hover</span><span class="w"> </span><span class="err">to</span><span class="w"> </span><span class="err">view</span><span class="w"> </span><span class="err">descriptions</span><span class="w"> </span><span class="err">of</span><span class="w"> </span><span class="err">existing</span><span class="w"> </span><span class="err">attributes.</span><span class="w">
    </span><span class="err">//</span><span class="w"> </span><span class="err">For</span><span class="w"> </span><span class="err">more</span><span class="w"> </span><span class="err">information</span><span class="p">,</span><span class="w"> </span><span class="err">visit:</span><span class="w"> </span><span class="err">https://go.microsoft.com/fwlink/?linkid=</span><span class="mi">830387</span><span class="w">
    </span><span class="nl">"version"</span><span class="p">:</span><span class="w"> </span><span class="s2">"0.2.0"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"configurations"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">

        </span><span class="p">{</span><span class="w">
            </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Python: Current File"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"python"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"request"</span><span class="p">:</span><span class="w"> </span><span class="s2">"launch"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"program"</span><span class="p">:</span><span class="w"> </span><span class="s2">"${file}"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"console"</span><span class="p">:</span><span class="w"> </span><span class="s2">"integratedTerminal"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"justMyCode"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w">
            </span><span class="nl">"args"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
                </span><span class="s2">"--cluster_job_log"</span><span class="p">,</span><span class="w"> </span><span class="s2">"trace/cluster_job_log"</span><span class="p">,</span><span class="w">
                </span><span class="s2">"--analyze_trace"</span><span class="p">,</span><span class="w">
            </span><span class="p">]</span><span class="w">
        </span><span class="p">},</span><span class="w">
    </span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div> <h4 id="条件断点">条件断点</h4> <ul> <li>参考文献：<a href="https://blog.csdn.net/znsoft/article/details/124266919" rel="external nofollow noopener" target="_blank">vscode 中使用条件断点_znsoft 的博客-CSDN 博客_vscode 条件断点</a> </li> </ul> <h4 id="debug-中出现的-open相对路径找不到的解决">debug 中出现的 open()相对路径找不到的解决</h4> <ul> <li>参考文献：<a href="https://stackoverflow.com/questions/38623138/vscode-how-to-set-working-directory-for-debugging-a-python-program" rel="external nofollow noopener" target="_blank">visual studio code - VSCode – how to set working directory for debugging a Python program - Stack Overflow</a> </li> </ul> <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="err">//</span><span class="w"> </span><span class="err">Use</span><span class="w"> </span><span class="err">IntelliSense</span><span class="w"> </span><span class="err">to</span><span class="w"> </span><span class="err">learn</span><span class="w"> </span><span class="err">about</span><span class="w"> </span><span class="err">possible</span><span class="w"> </span><span class="err">attributes.</span><span class="w">
    </span><span class="err">//</span><span class="w"> </span><span class="err">Hover</span><span class="w"> </span><span class="err">to</span><span class="w"> </span><span class="err">view</span><span class="w"> </span><span class="err">descriptions</span><span class="w"> </span><span class="err">of</span><span class="w"> </span><span class="err">existing</span><span class="w"> </span><span class="err">attributes.</span><span class="w">
    </span><span class="err">//</span><span class="w"> </span><span class="err">For</span><span class="w"> </span><span class="err">more</span><span class="w"> </span><span class="err">information</span><span class="p">,</span><span class="w"> </span><span class="err">visit:</span><span class="w"> </span><span class="err">https://go.microsoft.com/fwlink/?linkid=</span><span class="mi">830387</span><span class="w">
    </span><span class="nl">"version"</span><span class="p">:</span><span class="w"> </span><span class="s2">"0.2.0"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"configurations"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">


        </span><span class="p">{</span><span class="w">
            </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Python: Current File"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"python"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"request"</span><span class="p">:</span><span class="w"> </span><span class="s2">"launch"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"program"</span><span class="p">:</span><span class="w"> </span><span class="s2">"${file}"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"console"</span><span class="p">:</span><span class="w"> </span><span class="s2">"integratedTerminal"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"justMyCode"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w">
            </span><span class="nl">"args"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
                
            </span><span class="p">],</span><span class="w">
            </span><span class="err">//</span><span class="w"> </span><span class="nl">"env"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="nl">"PYTHONPATH"</span><span class="p">:</span><span class="w"> </span><span class="s2">"${workspaceFolder}/yafs${pathSeparator}${env:PYTHONPATH}"</span><span class="p">}</span><span class="w">
            </span><span class="nl">"cwd"</span><span class="p">:</span><span class="w"> </span><span class="s2">"${fileDirname}"</span><span class="p">,</span><span class="w">
        </span><span class="p">},</span><span class="w">
    </span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div> <p>##</p> <h2 id="python-原生语法">Python 原生语法</h2> <h3 id="装饰器学习">装饰器学习</h3> <ul> <li> <p>建议通过廖雪峰学习</p> <ul> <li><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017451662295584" rel="external nofollow noopener" target="_blank">https://www.liaoxuefeng.com/wiki/1016959663602400/1017451662295584</a></li> </ul> </li> <li> <p>@register_model 的介绍</p> <ul> <li><a href="https://www.cnblogs.com/wanger-sjtu/p/15013460.html" rel="external nofollow noopener" target="_blank">https://www.cnblogs.com/wanger-sjtu/p/15013460.html</a></li> </ul> </li> </ul> <h3 id="python-遍历删除">Python 遍历删除</h3> <ul> <li>参考文章：<a href="https://segmentfault.com/a/1190000007214571" rel="external nofollow noopener" target="_blank">https://segmentfault.com/a/1190000007214571</a> </li> <li> <p>具体的实现方式推荐：</p> <ul> <li>列表解析</li> </ul> </li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">lst</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">lst</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>
<span class="k">print</span> <span class="n">lst</span>
</code></pre></div></div> <h3 id="with-关键字">with 关键字</h3> <ul> <li> <p>这个关键字一直在用，但是之前没有很清晰地去理解含义</p> <ul> <li>参考文档：<a href="https://www.jianshu.com/p/5b01fb36fd4c" rel="external nofollow noopener" target="_blank">https://www.jianshu.com/p/5b01fb36fd4c</a> </li> </ul> </li> <li> <p>其实就是一个 Try-catch 结构的修改版</p> <ul> <li>支持场景：1、文件操作。2、进程线程之间互斥对象。3、支持上下文其他对象。</li> </ul> </li> <li> <p>原理：</p> <ul> <li>with 语句实质是上下文管理。</li> <li>1、上下文管理协议。包含方法__enter__() 和 <strong>exit</strong>()，支持该协议对象要实现这两个方法。</li> <li>2、上下文管理器，定义执行 with 语句时要建立的运行时上下文，负责执行 with 语句块上下文中的进入与退出操作。</li> <li>3、进入上下文的时候执行__enter__方法，如果设置 as var 语句，var 变量接受__enter__()方法返回值。</li> <li>4、如果运行时发生了异常，就退出上下文管理器。调用管理器__exit__方法</li> </ul> </li> </ul> <h3 id="号--与-号">*号 与 **号</h3> <ul> <li>后面会增加和 zip 绑定在一起的操作，该操作经常出现在很多源码中。</li> <li>用于乘法计算（*） 和幂乘（**）</li> <li> <p>用于元组打包与解包</p> <ul> <li>打包：将传递给函数的任意多个（也可以是 0 个）非关键字参数/关键字参数打包成一个元组（*号）/字典（**号）【元组只能接收非关键字参数，字典只能接收关键字参数】</li> </ul> </li> <li>解包：就是传递给函数的列表、元组、字典拆分成独立的多个元素然后赋值给函数中参变量（包括普通的位置参数、关键字参数、非关键字参数）。【解出来传给函数的只有键值（.key）】</li> </ul> <h3 id="zip和-zip">zip()和 zip(*)</h3> <ul> <li>参考文献 1： <a href="https://blog.nowcoder.net/n/f1caca2e5e2a4943b1697133f084bf6b" rel="external nofollow noopener" target="_blank">https://blog.nowcoder.net/n/f1caca2e5e2a4943b1697133f084bf6b</a> <ul> <li>zip() 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。</li> <li>如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同。利用 * 号操作符，可以将元组解压为列表。zip(*)解压函数，将对象中的每一个元素/元祖/字符串的相同位置的子元素组合成一个新的元祖，并将所有组成的元祖以列表的形式进行展示。</li> </ul> </li> </ul> <div class="language-prolog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="ss">a</span> <span class="o">=</span> <span class="p">[</span><span class="m">1</span><span class="p">,</span><span class="m">2</span><span class="p">,</span><span class="m">3</span><span class="p">]</span> 
<span class="o">&gt;&gt;&gt;</span> <span class="ss">b</span> <span class="o">=</span> <span class="p">[</span><span class="m">4</span><span class="p">,</span><span class="m">5</span><span class="p">,</span><span class="m">6</span><span class="p">]</span> 
<span class="o">&gt;&gt;&gt;</span> <span class="ss">c</span> <span class="o">=</span> <span class="p">[</span><span class="m">4</span><span class="p">,</span><span class="m">5</span><span class="p">,</span><span class="m">6</span><span class="p">,</span><span class="m">7</span><span class="p">,</span><span class="m">8</span><span class="p">]</span> 
<span class="o">&gt;&gt;&gt;</span> <span class="ss">zipped</span> <span class="o">=</span> <span class="ss">zip</span><span class="p">(</span><span class="ss">a</span><span class="p">,</span><span class="ss">b</span><span class="p">)</span> 
<span class="o">#</span> <span class="err">打包为元组的列表</span> <span class="p">[(</span><span class="m">1</span><span class="p">,</span> <span class="m">4</span><span class="p">),</span> <span class="p">(</span><span class="m">2</span><span class="p">,</span> <span class="m">5</span><span class="p">),</span> <span class="p">(</span><span class="m">3</span><span class="p">,</span> <span class="m">6</span><span class="p">)]</span> 
<span class="o">&gt;&gt;&gt;</span> <span class="ss">zip</span><span class="p">(</span><span class="ss">a</span><span class="p">,</span><span class="ss">c</span><span class="p">)</span> 
<span class="o">#</span> <span class="err">元素个数与最短的列表一致</span> <span class="p">[(</span><span class="m">1</span><span class="p">,</span> <span class="m">4</span><span class="p">),</span> <span class="p">(</span><span class="m">2</span><span class="p">,</span> <span class="m">5</span><span class="p">),</span> <span class="p">(</span><span class="m">3</span><span class="p">,</span> <span class="m">6</span><span class="p">)]</span> 
<span class="o">&gt;&gt;&gt;</span> <span class="ss">zip</span><span class="p">(</span><span class="o">*</span><span class="ss">zipped</span><span class="p">)</span> 
<span class="o">#</span> <span class="err">与</span> <span class="ss">zip</span> <span class="err">相反，可理解为解压，返回二维矩阵式</span> <span class="p">[(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">),</span> <span class="p">(</span><span class="m">4</span><span class="p">,</span> <span class="m">5</span><span class="p">,</span> <span class="m">6</span><span class="p">)]</span>
</code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">l</span> <span class="o">=</span> <span class="p">[</span><span class="sh">'</span><span class="s">flower</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">flow</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">flight</span><span class="sh">'</span><span class="p">]</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">zip</span><span class="p">(</span><span class="n">l</span><span class="p">))</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">zip</span><span class="p">(</span><span class="o">*</span><span class="n">l</span><span class="p">))</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="nf">zip</span><span class="p">(</span><span class="n">l</span><span class="p">)))</span> <span class="c1">#转换为list显示
</span><span class="nf">print</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="nf">zip</span><span class="p">(</span><span class="o">*</span><span class="n">l</span><span class="p">)))</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">tuple</span><span class="p">(</span><span class="nf">zip</span><span class="p">(</span><span class="n">l</span><span class="p">)))</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">tuple</span><span class="p">(</span><span class="nf">zip</span><span class="p">(</span><span class="o">*</span><span class="n">l</span><span class="p">)))</span>

<span class="c1"># &lt;zip object at 0x0000018B0BBD4F08&gt;
# &lt;zip object at 0x0000018B0BBD4F08&gt;
# [('flower',), ('flow',), ('flight',)]
# [('f', 'f', 'f'), ('l', 'l', 'l'), ('o', 'o', 'i'), ('w', 'w', 'g')]
# (('flower',), ('flow',), ('flight',))
# (('f', 'f', 'f'), ('l', 'l', 'l'), ('o', 'o', 'i'), ('w', 'w', 'g'))
</span>
<span class="n">l</span> <span class="o">=</span> <span class="p">[</span><span class="sh">'</span><span class="s">flower</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">flow</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">flight</span><span class="sh">'</span><span class="p">]</span>
<span class="n">m</span> <span class="o">=</span> <span class="p">[</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">b</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">c</span><span class="sh">'</span><span class="p">]</span>
<span class="n">k</span> <span class="o">=</span> <span class="nf">zip</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
<span class="k">print</span> <span class="n">k</span>
<span class="k">print</span> <span class="nf">zip</span><span class="p">(</span><span class="o">*</span><span class="n">k</span><span class="p">)</span>

<span class="c1"># [('flower', 'a'), ('flow', 'b'), ('flight', 'c')]
# [('flower', 'flow', 'flight'), ('a', 'b', 'c')]
</span></code></pre></div></div> <ul> <li>参考文献 2：<a href="https://developer.aliyun.com/article/373387" rel="external nofollow noopener" target="_blank">https://developer.aliyun.com/article/373387</a> <ul> <li>应用场景 1： 矩阵转置 <ul> <li>zip(*a)：将 list 看成 tuple 解压，恰好得到我们“行列互换”的效果；</li> <li>map(list,zip(*a))：再通过对每个元素应用 list()函数，将 tuple 转换为 list；</li> <li>zip 函数接受任意多个序列作为参数，将所有序列按相同的索引组合成一个元素是各个序列合并成的 tuple 的新序列，新的序列的长度以参数中最短的序列为准。</li> <li>另外(*)操作符与 zip 函数配合可以实现与 zip 相反的功能，即将合并的序列拆成多个 tuple。</li> </ul> </li> </ul> </li> </ul> <div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="s">[[1, 2, 3], [4, 5, 6], [7, 8, 9]]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">zip</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">)</span>
<span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">)]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">map</span><span class="p">(</span><span class="n">list</span><span class="p">,</span><span class="n">zip</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">))</span>
<span class="s">[[1, 4, 7], [2, 5, 8], [3, 6, 9]]</span>
</code></pre></div></div> <p>###</p> <h3 id="list">List</h3> <h4 id="获取二维及以上维度的-list-的最大最小值语法糖">获取二维及以上维度的 List 的最大最小值语法糖</h4> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">print</span><span class="p">(</span><span class="nf">min</span><span class="p">(</span><span class="nf">min</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">simUsers</span><span class="p">),</span> <span class="nf">max</span><span class="p">(</span><span class="nf">max</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">simUsers</span><span class="p">))</span>
</code></pre></div></div> <h3 id="map">Map</h3> <h4 id="获取-map-中-value-为特定值的-key">获取 map 中 value 为特定值的 key</h4> <h3 id="tuple">Tuple</h3> <h4 id="nametuple">nametuple</h4> <ul> <li>参考文献：</li> <li>namedtuple 是继承自 tuple 的子类。namedtuple 创建一个和 tuple 类似的对象，而且对象拥有可访问的属性。</li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">namedtuple</span>

<span class="c1"># 定义一个namedtuple类型User，并包含name，sex和age属性。
</span><span class="n">User</span> <span class="o">=</span> <span class="nf">namedtuple</span><span class="p">(</span><span class="sh">'</span><span class="s">User</span><span class="sh">'</span><span class="p">,</span> <span class="p">[</span><span class="sh">'</span><span class="s">name</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">sex</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">age</span><span class="sh">'</span><span class="p">])</span>

<span class="c1"># 创建一个User对象
</span><span class="n">user</span> <span class="o">=</span> <span class="nc">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="sh">'</span><span class="s">kongxx</span><span class="sh">'</span><span class="p">,</span> <span class="n">sex</span><span class="o">=</span><span class="sh">'</span><span class="s">male</span><span class="sh">'</span><span class="p">,</span> <span class="n">age</span><span class="o">=</span><span class="mi">21</span><span class="p">)</span>

<span class="c1"># 也可以通过一个list来创建一个User对象，这里注意需要使用"_make"方法
</span><span class="n">user</span> <span class="o">=</span> <span class="n">User</span><span class="p">.</span><span class="nf">_make</span><span class="p">([</span><span class="sh">'</span><span class="s">kongxx</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">male</span><span class="sh">'</span><span class="p">,</span> <span class="mi">21</span><span class="p">])</span>

<span class="k">print</span> <span class="n">user</span>
<span class="c1"># User(name='user1', sex='male', age=21)
</span>
<span class="c1"># 获取用户的属性
</span><span class="k">print</span> <span class="n">user</span><span class="p">.</span><span class="n">name</span>
<span class="k">print</span> <span class="n">user</span><span class="p">.</span><span class="n">sex</span>
<span class="k">print</span> <span class="n">user</span><span class="p">.</span><span class="n">age</span>

<span class="c1"># 修改对象属性，注意要使用"_replace"方法
</span><span class="n">user</span> <span class="o">=</span> <span class="n">user</span><span class="p">.</span><span class="nf">_replace</span><span class="p">(</span><span class="n">age</span><span class="o">=</span><span class="mi">22</span><span class="p">)</span>
<span class="k">print</span> <span class="n">user</span>
<span class="c1"># User(name='user1', sex='male', age=21)
</span>
<span class="c1"># 将User对象转换成字典，注意要使用"_asdict"
</span><span class="k">print</span> <span class="n">user</span><span class="p">.</span><span class="nf">_asdict</span><span class="p">()</span>
<span class="c1"># OrderedDict([('name', 'kongxx'), ('sex', 'male'), ('age', 22)])
</span></code></pre></div></div> <h3 id="json-操作">JSON 操作</h3> <h4 id="json-格式转化">JSON 格式转化</h4> <ul> <li><a href="https://tool.oschina.net/codeformat/json" rel="external nofollow noopener" target="_blank">在线代码格式化</a></li> </ul> <h4 id="json-读取和写入">json 读取和写入</h4> <ul> <li>参考文献：<a href="https://www.cnblogs.com/bigberg/p/6430095.html" rel="external nofollow noopener" target="_blank">python 读写 json 文件 - Bigberg - 博客园 (cnblogs.com)</a> </li> </ul> <h3 id="collection-语法">Collection 语法</h3> <h4 id="获取-list-的分布频数">获取 List 的分布/频数</h4> <ul> <li>使用：</li> </ul> <div class="language-coffeescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">from</span> <span class="nx">collections</span> <span class="k">import</span> <span class="nx">Counter</span>
<span class="nx">origin_label_distribution</span> <span class="o">=</span> <span class="nx">Counter</span><span class="p">(</span><span class="nx">train_all_dataset</span><span class="p">.</span><span class="na">get_subset_targets</span><span class="p">())</span>
<span class="nx">print</span><span class="p">(</span><span class="nx">origin_label_distribution</span><span class="p">)</span>
</code></pre></div></div> <h3 id="global与-local">global()与 local()</h3> <ul> <li>globals()函数和 locals()函数都是 python 的内置函数，他们的作用分别是以 dict 数据类型返回 python 程序的全局变量和某个局部的变量。globals()可读可写，而 locals()是只读！</li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="nf">globals</span><span class="p">()</span> 
<span class="p">{</span><span class="sh">'</span><span class="s">__name__</span><span class="sh">'</span><span class="p">:</span> <span class="sh">'</span><span class="s">__main__</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">__doc__</span><span class="sh">'</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span> <span class="sh">'</span><span class="s">__package__</span><span class="sh">'</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span> <span class="sh">'</span><span class="s">__loader__</span><span class="sh">'</span><span class="p">:</span> <span class="p">,</span> <span class="sh">'</span><span class="s">__spec__</span><span class="sh">'</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span> <span class="sh">'</span><span class="s">__annotations__</span><span class="sh">'</span><span class="p">:</span> <span class="p">{},</span> <span class="sh">'</span><span class="s">__builtins__</span><span class="sh">'</span><span class="p">:</span> <span class="p">}</span> 
<span class="o">&gt;&gt;&gt;</span> 
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span> 
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span> 
<span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="n">os</span> 
<span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="n">sys</span> 
<span class="o">&gt;&gt;&gt;</span> <span class="nf">globals</span><span class="p">()</span> 
<span class="p">{</span><span class="sh">'</span><span class="s">__name__</span><span class="sh">'</span><span class="p">:</span> <span class="sh">'</span><span class="s">__main__</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">__doc__</span><span class="sh">'</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span> <span class="sh">'</span><span class="s">__package__</span><span class="sh">'</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span> <span class="sh">'</span><span class="s">__loader__</span><span class="sh">'</span><span class="p">:</span> <span class="p">,</span> <span class="sh">'</span><span class="s">__spec__</span><span class="sh">'</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span> <span class="sh">'</span><span class="s">__annotations__</span><span class="sh">'</span><span class="p">:</span> <span class="p">{},</span> <span class="sh">'</span><span class="s">__builtins__</span><span class="sh">'</span><span class="p">:</span> <span class="p">,</span> <span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="sh">'</span><span class="s">b</span><span class="sh">'</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="sh">'</span><span class="s">os</span><span class="sh">'</span><span class="p">:</span> <span class="p">,</span> <span class="sh">'</span><span class="s">sys</span><span class="sh">'</span><span class="p">:</span> <span class="p">}</span> 
<span class="o">&gt;&gt;&gt;</span>
</code></pre></div></div> <h3 id="文件操作">文件操作</h3> <h4 id="判断路径存在与创建新文件夹">判断路径存在与创建新文件夹</h4> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>os.path.exists(path)
</code></pre></div></div> <h4 id="列出文件夹目录下的所有文件名">列出文件夹目录下的所有文件名</h4> <h3 id="sorted">Sorted</h3> <ul> <li> <p>key 传参的用法</p> <ul> <li>用于排序的优先级</li> <li>参考文档：<a href="https://blog.csdn.net/m0_38109046/article/details/86636511" rel="external nofollow noopener" target="_blank">https://blog.csdn.net/m0_38109046/article/details/86636511</a> </li> </ul> </li> <li> <p>reverse 的用法</p> <ul> <li>True： 从大到小排列</li> </ul> </li> <li> <p>将 index 和 value 一起排序</p> </li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 按列表a中元素的值进行排序，并返回元素对应索引序列
</span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">a:</span><span class="sh">'</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="n">sorted_id</span> <span class="o">=</span> <span class="nf">sorted</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">a</span><span class="p">)),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="n">a</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">元素索引序列：</span><span class="sh">'</span><span class="p">,</span> <span class="n">sorted_id</span><span class="p">)</span>

<span class="c1"># 结果
# a: [1, 3, 4, 5, 2, 7, 9]
# 元素索引序列： [6, 5, 3, 2, 1, 4, 0]
</span></code></pre></div></div> <h3 id="datetime-语法中的问题">datetime 语法中的问题</h3> <ul> <li> <p>匹配’2021-05-30T21:17:08+00:00’现在不可以了，但是可以匹配’2021-05-30T21:17:08+0000’，因此需要删除最后一个’:’</p> <ul> <li>str_new = str[::-1].replace(‘:’,’‘,1)[::-1]</li> </ul> </li> <li> <p>参考文献：<a href="https://stackoverflow.com/questions/69660901/python-time-data-does-not-match-format" rel="external nofollow noopener" target="_blank">datetime - Python: time data does not match format - Stack Overflow</a></p> </li> </ul> <h2 id="多进程与多线程相关主题">多进程与多线程相关主题</h2> <h3 id="multiprocess">Multiprocess</h3> <h4 id="multiprocessingsimplequeue">multiprocessing.SimpleQueue</h4> <ul> <li> <code class="language-plaintext highlighter-rouge">multiprocessing.SimpleQueue</code> 主要用于多进程编程中，允许多个进程之间安全地传递数据。它是一种轻量级的队列实现，适用于简单的生产者-消费者模型，其中一个或多个进程生产数据，而其他进程消费数据。</li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">multiprocessing</span>

<span class="k">def</span> <span class="nf">producer</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
        <span class="n">queue</span><span class="p">.</span><span class="nf">put</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">consumer</span><span class="p">(</span><span class="n">queue</span><span class="p">):</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">item</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">get</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">item</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Consumer got: </span><span class="si">{</span><span class="n">item</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="sh">"</span><span class="s">__main__</span><span class="sh">"</span><span class="p">:</span>
    <span class="n">data_to_process</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>

    <span class="c1"># 创建一个 SimpleQueue
</span>    <span class="n">queue</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="p">.</span><span class="nc">SimpleQueue</span><span class="p">()</span>

    <span class="c1"># 创建生产者和消费者进程
</span>    <span class="n">producer_process</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="p">.</span><span class="nc">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">producer</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="n">data_to_process</span><span class="p">))</span>
    <span class="n">consumer_process</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="p">.</span><span class="nc">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">consumer</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">queue</span><span class="p">))</span>

    <span class="n">producer_process</span><span class="p">.</span><span class="nf">start</span><span class="p">()</span>
    <span class="n">consumer_process</span><span class="p">.</span><span class="nf">start</span><span class="p">()</span>

    <span class="n">producer_process</span><span class="p">.</span><span class="nf">join</span><span class="p">()</span>
    <span class="c1"># 发送一个终止信号给消费者
</span>    <span class="n">queue</span><span class="p">.</span><span class="nf">put</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
    <span class="n">consumer_process</span><span class="p">.</span><span class="nf">join</span><span class="p">()</span>
</code></pre></div></div> <ul> <li>缺点： <ul> <li>功能有限：相对于其他队列实现（如 <code class="language-plaintext highlighter-rouge">multiprocessing.Queue</code>），<code class="language-plaintext highlighter-rouge">multiprocessing.SimpleQueue</code> 的功能有限。它不支持进程等待或超时，不允许设置队列的最大大小等高级特性。</li> <li>仅适用于简单场景：由于其功能有限，<code class="language-plaintext highlighter-rouge">multiprocessing.SimpleQueue</code> 适用于相对简单的生产者-消费者场景，对于复杂的需求可能不够灵活。</li> <li>不支持阻塞操作：它没有提供阻塞式的 <code class="language-plaintext highlighter-rouge">get</code> 操作，因此在没有数据的情况下，调用 <code class="language-plaintext highlighter-rouge">get</code> 会立即返回。</li> </ul> </li> </ul> <h4 id="multiprocessingjoinablequeue">multiprocessing.JoinableQueue</h4> <p><code class="language-plaintext highlighter-rouge">multiprocess.JoinableQueue</code> 是 Python <code class="language-plaintext highlighter-rouge">multiprocessing</code> 模块中的一个队列类型，它的主要作用是在多进程编程中实现进程之间的通信和同步。与普通队列不同，<code class="language-plaintext highlighter-rouge">JoinableQueue</code> 具有一些额外的特性，最重要的是可以跟踪队列中的任务并知道何时队列为空，以及何时可以安全地终止进程。</p> <p>以下是 <code class="language-plaintext highlighter-rouge">multiprocess.JoinableQueue</code> 的主要作用和示例：</p> <ol> <li> <strong>进程间通信</strong>：<code class="language-plaintext highlighter-rouge">JoinableQueue</code> 允许多个进程之间安全地传递数据。一个进程可以将数据放入队列，而另一个进程可以从队列中获取数据，从而实现进程之间的通信。</li> </ol> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">multiprocessing</span> <span class="kn">import</span> <span class="n">Process</span><span class="p">,</span> <span class="n">JoinableQueue</span>

<span class="k">def</span> <span class="nf">worker</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
   <span class="n">data</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="nf">get</span><span class="p">()</span>
   <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Worker got data: </span><span class="si">{</span><span class="n">data</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="sh">"</span><span class="s">__main__</span><span class="sh">"</span><span class="p">:</span>
   <span class="n">queue</span> <span class="o">=</span> <span class="nc">JoinableQueue</span><span class="p">()</span>
   <span class="n">p</span> <span class="o">=</span> <span class="nc">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">worker</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">queue</span><span class="p">,))</span>
   <span class="n">p</span><span class="p">.</span><span class="nf">start</span><span class="p">()</span>
   <span class="n">queue</span><span class="p">.</span><span class="nf">put</span><span class="p">(</span><span class="sh">"</span><span class="s">Hello from main process</span><span class="sh">"</span><span class="p">)</span>
   <span class="n">queue</span><span class="p">.</span><span class="nf">join</span><span class="p">()</span>
   <span class="n">p</span><span class="p">.</span><span class="nf">join</span><span class="p">()</span>
</code></pre></div></div> <p>在上面的示例中，主进程向队列中放入了数据，并调用 <code class="language-plaintext highlighter-rouge">queue.join()</code> 来等待队列中的任务全部完成，以确保工作进程执行完毕。</p> <ol> <li> <strong>跟踪任务完成</strong>：<code class="language-plaintext highlighter-rouge">JoinableQueue</code> 允许主进程跟踪子进程完成的任务数量。当子进程完成任务时，它会通过调用 <code class="language-plaintext highlighter-rouge">queue.task_done()</code> 来通知队列，从而使主进程知道何时所有任务都已完成。</li> </ol> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">multiprocessing</span> <span class="kn">import</span> <span class="n">Process</span><span class="p">,</span> <span class="n">JoinableQueue</span>

<span class="k">def</span> <span class="nf">worker</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
   <span class="n">data</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="nf">get</span><span class="p">()</span>
   <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Worker got data: </span><span class="si">{</span><span class="n">data</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
   <span class="n">q</span><span class="p">.</span><span class="nf">task_done</span><span class="p">()</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="sh">"</span><span class="s">__main__</span><span class="sh">"</span><span class="p">:</span>
   <span class="n">queue</span> <span class="o">=</span> <span class="nc">JoinableQueue</span><span class="p">()</span>
   <span class="n">p</span> <span class="o">=</span> <span class="nc">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">worker</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">queue</span><span class="p">,))</span>
   <span class="n">p</span><span class="p">.</span><span class="nf">start</span><span class="p">()</span>
   <span class="n">queue</span><span class="p">.</span><span class="nf">put</span><span class="p">(</span><span class="sh">"</span><span class="s">Hello from main process</span><span class="sh">"</span><span class="p">)</span>
   <span class="n">queue</span><span class="p">.</span><span class="nf">join</span><span class="p">()</span>
   <span class="n">p</span><span class="p">.</span><span class="nf">join</span><span class="p">()</span>
</code></pre></div></div> <p>在这个示例中，工作进程在完成任务后调用了 <code class="language-plaintext highlighter-rouge">q.task_done()</code>，主进程通过 <code class="language-plaintext highlighter-rouge">q.join()</code> 来等待任务完成。</p> <p>总之，<code class="language-plaintext highlighter-rouge">JoinableQueue</code> 是多进程编程中用于进程间通信和同步的一种重要工具，它允许主进程与子进程之间安全地传递数据和等待任务完成，从而更好地管理和控制多进程应用程序。</p> <h4 id="自定义-multi-parallel-queue">自定义 multi parallel queue</h4> <ul> <li> <p><strong>解决缓冲区大小限制问题</strong>：</p> <ul> <li>在多进程编程中，使用队列来在进程之间传递数据非常常见。但是，某些队列实现（例如 <code class="language-plaintext highlighter-rouge">multiprocessing.SimpleQueue</code>）使用系统管道（pipe），而这些管道的缓冲区大小是有限的，通常很小。这就意味着当队列中的数据达到管道缓冲区的上限时，进程可能会阻塞等待队列中的空间。</li> <li> <code class="language-plaintext highlighter-rouge">ParallelQueue</code> 的主要目的是通过使用多个队列，以轮询的方式从中选择一个队列来解决这个问题。每个队列都有自己的缓冲区，因此总体上可以容纳更多的数据。这可以帮助避免进程之间的阻塞，提高并行性能。</li> </ul> </li> <li> <p><strong>轮询</strong><strong>多个队列</strong>：</p> <ul> <li> <code class="language-plaintext highlighter-rouge">ParallelQueue</code> 维护一个队列列表 <code class="language-plaintext highlighter-rouge">_queues</code>，并在每次调用 <code class="language-plaintext highlighter-rouge">put</code> 或 <code class="language-plaintext highlighter-rouge">get</code> 方法时，根据轮询的方式选择一个队列来执行操作。这确保了每个队列都有机会被使用，从而均衡了数据分布。</li> </ul> </li> <li> <p><strong>提高管道缓冲区大小</strong>：</p> <ul> <li>在初始化过程中，<code class="language-plaintext highlighter-rouge">ParallelQueue</code> 使用 <code class="language-plaintext highlighter-rouge">fcntl</code> 模块来增加每个队列的管道缓冲区大小，将其设置为最大的管道大小（<code class="language-plaintext highlighter-rouge">PIPE_MAX_SIZE</code>）。这可以帮助提高每个队列的容量，从而减少阻塞的可能性。</li> </ul> </li> <li> <p><strong>可关闭</strong>：</p> <ul> <li> <code class="language-plaintext highlighter-rouge">ParallelQueue</code> 提供了 <code class="language-plaintext highlighter-rouge">close()</code> 方法，可以用于关闭所有包含的队列。</li> </ul> </li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">fcntl</span>

<span class="n">F_SETPIPE_SZ</span> <span class="o">=</span> <span class="mi">1031</span>
<span class="n">F_GETPIPE_SZ</span> <span class="o">=</span> <span class="mi">1032</span>
<span class="n">PIPE_MAX_SIZE</span> <span class="o">=</span> <span class="mi">1048576</span>


<span class="k">class</span> <span class="nc">ParallelQueue</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sh">'''</span><span class="s">
    ParallelQueue is a wrapper around multiple queues which are scheduled in
    round robin fashion. This is done to overcome the issue of buffer size limit
    per queue. For example, mp.SimpleQueue uses system pipe and it</span><span class="sh">'</span><span class="s">s not straighforward 
    to increase the Pipe</span><span class="sh">'</span><span class="s">s buffer size and also the max size limit. 
    Therefore, using multiple parallel queues might overcome the issue of size limit.
    
    </span><span class="sh">'''</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">QueueType</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">_cur_queue_idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">self</span><span class="p">.</span><span class="n">_total_queues</span> <span class="o">=</span> <span class="n">count</span>
        <span class="n">self</span><span class="p">.</span><span class="n">_queues</span> <span class="o">=</span> <span class="p">[</span><span class="nc">QueueType</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">count</span><span class="p">)]</span>

        <span class="n">self</span><span class="p">.</span><span class="nf">_init_queues</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_init_queues</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="sh">'''</span><span class="s"> 
        We increase the default pipe  size to max pipe size
        </span><span class="sh">'''</span>
        <span class="k">for</span> <span class="n">queue</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">_queues</span><span class="p">:</span>
            <span class="n">r_fd</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="n">_reader</span><span class="p">.</span><span class="nf">fileno</span><span class="p">()</span>
            <span class="n">w_fd</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="n">_writer</span><span class="p">.</span><span class="nf">fileno</span><span class="p">()</span>
            <span class="n">fcntl</span><span class="p">.</span><span class="nf">fcntl</span><span class="p">(</span><span class="n">r_fd</span><span class="p">,</span>  <span class="n">F_SETPIPE_SZ</span><span class="p">,</span> <span class="n">PIPE_MAX_SIZE</span><span class="p">)</span>
            <span class="n">fcntl</span><span class="p">.</span><span class="nf">fcntl</span><span class="p">(</span><span class="n">w_fd</span><span class="p">,</span>  <span class="n">F_SETPIPE_SZ</span><span class="p">,</span> <span class="n">PIPE_MAX_SIZE</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="p">[</span><span class="n">queue</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span> <span class="k">for</span> <span class="n">queue</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">_queues</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">):</span> <span class="c1"># 每次都会选择当前队列的下一个
</span>        <span class="n">idx</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">_cur_queue_idx</span>
        <span class="n">self</span><span class="p">.</span><span class="n">_cur_queue_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">_cur_queue_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">self</span><span class="p">.</span><span class="n">_total_queues</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">_queues</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="nf">put</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">empty</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">_cur_queue_idx</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">_queues</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="nf">empty</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">_cur_queue_idx</span>
        <span class="n">self</span><span class="p">.</span><span class="n">_cur_queue_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">_cur_queue_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">self</span><span class="p">.</span><span class="n">_total_queues</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">_queues</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="nf">get</span><span class="p">()</span>
</code></pre></div></div> <h4 id="multiprocess-中多种-queue-的选型问题">multiprocess 中多种 queue 的选型问题</h4> <ol> <li> <p><strong>multiprocessing.SimpleQueue</strong>：</p> <ul> <li> <strong>功能简单</strong>：<code class="language-plaintext highlighter-rouge">SimpleQueue</code> 是最简单的队列实现，它提供了基本的队列操作，包括 <code class="language-plaintext highlighter-rouge">put</code> 和 <code class="language-plaintext highlighter-rouge">get</code>。</li> <li> <strong>无法阻塞</strong>：它不支持阻塞式的 <code class="language-plaintext highlighter-rouge">get</code> 操作，因此在没有数据的情况下，调用 <code class="language-plaintext highlighter-rouge">get</code> 会立即返回。</li> <li> <strong>不支持超时</strong>：与阻塞操作相关，它也不支持设置超时等待。</li> <li> <strong>适用范围</strong>：适用于简单的生产者-消费者模型，对于复杂的场景功能有限。</li> </ul> </li> <li> <p><strong>multiprocessing.Queue</strong>：</p> <ul> <li> <strong>功能丰富</strong>：<code class="language-plaintext highlighter-rouge">Queue</code> 提供了比 <code class="language-plaintext highlighter-rouge">SimpleQueue</code> 更丰富的功能，包括阻塞式的 <code class="language-plaintext highlighter-rouge">get</code> 操作，支持设置队列的最大大小，允许设置超时等待。</li> <li> <strong>阻塞操作</strong>：可以使用 <code class="language-plaintext highlighter-rouge">get</code> 方法进行阻塞等待，直到队列中有数据可用。</li> <li> <strong>最大大小</strong>：可以通过参数设置队列的最大大小，以控制队列中的元素数量。</li> <li> <strong>适用范围</strong>：适用于大多数多进程通信需求，功能相对完备。</li> </ul> </li> <li> <p><strong>multiprocessing.JoinableQueue</strong>：</p> <ul> <li> <strong>功能更强大</strong>：<code class="language-plaintext highlighter-rouge">JoinableQueue</code> 是 <code class="language-plaintext highlighter-rouge">Queue</code> 的一个子类，除了 <code class="language-plaintext highlighter-rouge">Queue</code> 的功能外，还具备了一些额外的特性。</li> <li> <strong>支持任务追踪</strong>：<code class="language-plaintext highlighter-rouge">JoinableQueue</code> 允许跟踪进程的任务完成情况，通过 <code class="language-plaintext highlighter-rouge">task_done</code> 方法标记任务已完成，并通过 <code class="language-plaintext highlighter-rouge">join</code> 方法等待所有任务完成。</li> <li> <strong>适用范围</strong>：适用于需要追踪任务完成状态的场景，例如，当所有任务完成后，执行某个特定操作。</li> </ul> </li> </ol> <p>总之，选择合适的队列实现取决于你的多进程通信需求。如果只需要基本的队列操作，可以使用 <code class="language-plaintext highlighter-rouge">SimpleQueue</code>。如果需要更多功能，如阻塞操作、设置队列大小等，可以使用 <code class="language-plaintext highlighter-rouge">Queue</code>。如果需要追踪任务完成状态，可以使用 <code class="language-plaintext highlighter-rouge">JoinableQueue</code>。根据具体场景的要求，选择合适的队列可以提高多进程编程的效率和可维护性。</p> <h4 id="multiprocessevent-的作用和示例">multiprocess.event 的作用和示例</h4> <pre><code class="language-vbnet">import multiprocessing,time,random
def restaurant_handle(event): #餐厅的处理进程
    print("1、【餐厅】为食客安排座位，并在一旁等待食客点餐。。。")
    time.sleep(random.randint(1,3))
    event.set()#解除阻塞状态
    event.clear()#清除已有的状态
    event.wait()#等待食客后续处理

    print("3、【餐厅】厨师接到菜单，开始烹饪美食。。。")
    time.sleep(random.randint(1,3))
    event.set() #解除阻塞状态
    event.clear()  # 之前的状态清空
    event.wait()

    print("5、【餐厅】收银台算正在算账。。。")
    time.sleep(random.randint(1,3))
    event.set()  # 解除阻塞状态
    event.clear()  # 之前的状态清空
    event.wait()

    print("7、【餐厅】收银台收到钱。。。")
    time.sleep(random.randint(1,3))
    event.set()
    event.clear()
    event.wait()

def diners_hangle(event):#食客的处理进程
    event.wait() #等待之前的第一步完成  两个进程所以先阻塞，让另一个执行

    print("2、【食客】食客看完菜单，选好了自己心仪的美食。。。")
    time.sleep(random.randint(1,3))
    event.set() #解除阻塞状态
    event.clear()#之前的状态清空
    event.wait()#继续等待后续的处理步骤

    print("4、【食客】享用丰盛的美食。。。")
    time.sleep(random.randint(1,3))
    event.set()
    event.clear()
    event.wait()

    print("6、【食客】食客吃晚餐走向收银台付款。。。")
    time.sleep(random.randint(1,3))
    event.set()
    event.clear()
    event.wait()

    print("8、【食客】食客离开")
    event.set()

def main():
    event = multiprocessing.Event()#定义一个event同步处理
    restaurant_process = multiprocessing.Process(target=restaurant_handle,args=(event,),name="餐厅服务进程")
    diners_process = multiprocessing.Process(target=diners_hangle,args=(event,),name="食客进程")
    restaurant_process.start()
    diners_process.start()
if __name__ == '__main__':
    main()
</code></pre> <h3 id="thread">Thread</h3> <h2 id="rpc-专题">RPC 专题</h2> <h3 id="grpc">gRPC</h3> <ul> <li>为 gRPC 注册服务、函数和处理方式 <ol> <li> <code class="language-plaintext highlighter-rouge">grpc.stream_stream_rpc_method_handler</code>： <ul> <li>用于定义双向流式 RPC 方法的处理器。</li> <li>双向流式 RPC 是一种 RPC 类型，它允许客户端和服务器之间的双向通信，可以发送和接收多个消息。</li> <li>在 gRPC 中，这种方法的处理器需要指定请求消息的反序列化器（<code class="language-plaintext highlighter-rouge">request_deserializer</code>）和响应消息的序列化器（<code class="language-plaintext highlighter-rouge">response_serializer</code>）。</li> </ul> </li> <li> <code class="language-plaintext highlighter-rouge">grpc.unary_stream_rpc_method_handler</code>： <ul> <li>用于定义客户端流式 RPC 方法的处理器。</li> <li>客户端流式 RPC 允许客户端向服务器流式发送多个消息，但服务器只能返回单个响应消息。</li> <li>这种方法的处理器需要指定请求消息的反序列化器（<code class="language-plaintext highlighter-rouge">request_deserializer</code>）和响应消息的序列化器（<code class="language-plaintext highlighter-rouge">response_serializer</code>）。</li> </ul> </li> <li> <code class="language-plaintext highlighter-rouge">grpc.unary_unary_rpc_method_handler</code>： <ul> <li>用于定义一元 RPC 方法的处理器。</li> <li>一元 RPC 是最简单的 RPC 类型，客户端发送一个请求消息，服务器处理后返回一个响应消息。</li> <li>这种方法的处理器需要指定请求消息的反序列化器（<code class="language-plaintext highlighter-rouge">request_deserializer</code>）和响应消息的序列化器（<code class="language-plaintext highlighter-rouge">response_serializer</code>）。</li> </ul> </li> </ol> </li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">add_ModelServingServicer_to_server</span><span class="p">(</span><span class="n">servicer</span><span class="p">,</span> <span class="n">server</span><span class="p">):</span>
    <span class="n">rpc_method_handlers</span> <span class="o">=</span> <span class="p">{</span>
            <span class="sh">'</span><span class="s">predict</span><span class="sh">'</span><span class="p">:</span> <span class="n">grpc</span><span class="p">.</span><span class="nf">stream_stream_rpc_method_handler</span><span class="p">(</span>
                    <span class="n">servicer</span><span class="p">.</span><span class="n">predict</span><span class="p">,</span>
                    <span class="n">request_deserializer</span><span class="o">=</span><span class="n">predict__pb2</span><span class="p">.</span><span class="n">PredictRequest</span><span class="p">.</span><span class="n">FromString</span><span class="p">,</span>
                    <span class="n">response_serializer</span><span class="o">=</span><span class="n">predict__pb2</span><span class="p">.</span><span class="n">PredictResponse</span><span class="p">.</span><span class="n">SerializeToString</span><span class="p">,</span>
            <span class="p">),</span>
            <span class="sh">'</span><span class="s">predict_ack</span><span class="sh">'</span><span class="p">:</span> <span class="n">grpc</span><span class="p">.</span><span class="nf">unary_stream_rpc_method_handler</span><span class="p">(</span>
                    <span class="n">servicer</span><span class="p">.</span><span class="n">predict_ack</span><span class="p">,</span>
                    <span class="n">request_deserializer</span><span class="o">=</span><span class="n">predict__pb2</span><span class="p">.</span><span class="n">ClientToken</span><span class="p">.</span><span class="n">FromString</span><span class="p">,</span>
                    <span class="n">response_serializer</span><span class="o">=</span><span class="n">predict__pb2</span><span class="p">.</span><span class="n">PredictRequestAck</span><span class="p">.</span><span class="n">SerializeToString</span><span class="p">,</span>
            <span class="p">),</span>
            <span class="sh">'</span><span class="s">register</span><span class="sh">'</span><span class="p">:</span> <span class="n">grpc</span><span class="p">.</span><span class="nf">unary_unary_rpc_method_handler</span><span class="p">(</span>
                    <span class="n">servicer</span><span class="p">.</span><span class="n">register</span><span class="p">,</span>
                    <span class="n">request_deserializer</span><span class="o">=</span><span class="n">predict__pb2</span><span class="p">.</span><span class="n">RegisterRequest</span><span class="p">.</span><span class="n">FromString</span><span class="p">,</span>
                    <span class="n">response_serializer</span><span class="o">=</span><span class="n">predict__pb2</span><span class="p">.</span><span class="n">RegisterResponse</span><span class="p">.</span><span class="n">SerializeToString</span><span class="p">,</span>
            <span class="p">),</span>
            <span class="sh">'</span><span class="s">unregister</span><span class="sh">'</span><span class="p">:</span> <span class="n">grpc</span><span class="p">.</span><span class="nf">unary_unary_rpc_method_handler</span><span class="p">(</span>
                    <span class="n">servicer</span><span class="p">.</span><span class="n">unregister</span><span class="p">,</span>
                    <span class="n">request_deserializer</span><span class="o">=</span><span class="n">predict__pb2</span><span class="p">.</span><span class="n">ClientToken</span><span class="p">.</span><span class="n">FromString</span><span class="p">,</span>
                    <span class="n">response_serializer</span><span class="o">=</span><span class="n">predict__pb2</span><span class="p">.</span><span class="n">Empty</span><span class="p">.</span><span class="n">SerializeToString</span><span class="p">,</span>
            <span class="p">),</span>
    <span class="p">}</span>
    <span class="n">generic_handler</span> <span class="o">=</span> <span class="n">grpc</span><span class="p">.</span><span class="nf">method_handlers_generic_handler</span><span class="p">(</span>
            <span class="sh">'</span><span class="s">model_serving.ModelServing</span><span class="sh">'</span><span class="p">,</span> <span class="n">rpc_method_handlers</span><span class="p">)</span>
    <span class="n">server</span><span class="p">.</span><span class="nf">add_generic_rpc_handlers</span><span class="p">((</span><span class="n">generic_handler</span><span class="p">,))</span>
</code></pre></div></div> <h2 id="argparse">argparse</h2> <h3 id="store_true">–store_true</h3> <ul> <li>默认不传的时候就是设置为 False</li> <li> <p>True/False 参数无法设置的问题</p> <ul> <li>参考文献：<a href="https://github.com/spotify/luigi/issues/193" rel="external nofollow noopener" target="_blank">Cannot pass BooleanParameter in as argument from commandline · Issue #193 · spotify/luigi (github.com)</a> </li> <li>解决方案：直接避免 True 和 False 的出现即可</li> </ul> </li> </ul> <h3 id="打印所有的传入参数">打印所有的传入参数</h3> <p>-</p> <h2 id="numpy">Numpy</h2> <h3 id="初始化一个特定的-tensor">初始化一个特定的 Tensor</h3> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div> <h3 id="argwhere">Argwhere</h3> <ul> <li>返回：非 0 的数组元素的索引，其中 a 是待索引数组的条件</li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">).</span><span class="nf">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="c1"># x=[[0 1 2]
# [3 4 5]]
</span> 
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">argwhere</span><span class="p">(</span><span class="n">x</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)</span> <span class="c1">#x所有元素中大于1的元素的索引，分别是第0行第2列...以此类推
</span><span class="nf">print</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="c1"># y=[[0 2]
# [1 0]
# [1 1]
# [1 2]]
</span></code></pre></div></div> <h3 id="where">Where</h3> <ul> <li>满足条件(condition)，输出 x，不满足输出 y。</li> </ul> <div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">aa</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="p">.</span><span class="n">where</span><span class="p">(</span><span class="n">aa</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">])</span>  <span class="o">#</span> <span class="mi">0</span><span class="err">为</span><span class="n">False</span><span class="err">，所以第一个输出</span><span class="o">-</span><span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="p">.</span><span class="n">where</span><span class="p">(</span><span class="n">aa</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">])</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="p">.</span><span class="n">where</span><span class="p">(</span><span class="s">[[True,False], [True,True]]</span><span class="p">,</span>    <span class="o">#</span> <span class="err">官网上的例子</span>
             <span class="s">[[1,2], [3,4]]</span><span class="p">,</span>
             <span class="s">[[9,8], [7,6]]</span><span class="p">)</span>
<span class="n">array</span><span class="p">(</span><span class="s">[[1, 8],
       [3, 4]]</span><span class="p">)</span>
</code></pre></div></div> <h3 id="求和">求和</h3> <ul> <li>参考文档：<a href="https://blog.csdn.net/u014636245/article/details/84181868" rel="external nofollow noopener" target="_blank">https://blog.csdn.net/u014636245/article/details/84181868</a> </li> </ul> <h3 id="拼接-tensor">拼接 Tensor</h3> <ul> <li>参考文档：<a href="https://zhuanlan.zhihu.com/p/130260017" rel="external nofollow noopener" target="_blank">https://zhuanlan.zhihu.com/p/130260017</a> <ul> <li>列拼接：column_stack((a, b))</li> </ul> </li> </ul> <h3 id="对应-item-操作">对应 Item 操作</h3> <ul> <li>就是我们简单的单元操作符： + - * /</li> </ul> <h3 id="数组排序与翻转数组">数组排序与翻转数组</h3> <ul> <li>排序后得到 index 的数组：</li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/python3
#code-python(3.6)
</span><span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">])</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="nf">argsort</span><span class="p">()</span> <span class="c1">#将数组升序排列，但不改变数组，且返回对应的索引
</span><span class="nf">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>    <span class="c1">#[4 2 5 7]，其索引是[0,1,2,3]
</span><span class="nf">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>    <span class="c1">#升序后的索引是[1 0 2 3]，对应元素[2,4,5,7]
</span></code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/python3
#code-python(3.6)
</span><span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">])</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="nf">argsort</span><span class="p">()[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1">#将数组降序排列，但不改变数组，且返回对应的索引
</span><span class="nf">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>    <span class="c1">#[4 2 5 7]，其索引是[0,1,2,3]
</span><span class="nf">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>    <span class="c1">#降序后的索引是[3 2 0 1]，对应元素[7,5,4,2]
</span></code></pre></div></div> <ul> <li>翻转数组：</li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div> <ul> <li>按列排序 <ul> <li>参考文献：<a href="https://blog.csdn.net/jingyi130705008/article/details/78066842" rel="external nofollow noopener" target="_blank">https://blog.csdn.net/jingyi130705008/article/details/78066842</a> </li> </ul> </li> </ul> <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">data</span> <span class="o">=</span> <span class="kr">data</span><span class="p">[</span><span class="kr">data</span><span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">argsort</span><span class="nb">()</span><span class="p">]</span> <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;#</span><span class="err">按照第</span><span class="mi">3</span><span class="err">列对行排序</span><span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span>
</code></pre></div></div> <ul> <li>按行排序</li> </ul> <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">data</span> <span class="o">=</span> <span class="kr">data</span><span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="kr">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">argsort</span><span class="nb">()</span><span class="p">]</span>
</code></pre></div></div> <ul> <li>获取数组的排序 index</li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div> <h3 id="计数操作">计数操作</h3> <ul> <li>参考文献：<a href="https://www.itranslater.com/qa/details/2119130387891880960" rel="external nofollow noopener" target="_blank">https://www.itranslater.com/qa/details/2119130387891880960</a> <ul> <li>用于计算某个值在 numpy 的 narray 中出现的次数</li> </ul> </li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="p">.</span><span class="nf">count_nonzero</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
<span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="p">.</span><span class="nf">count_nonzero</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
<span class="mi">7</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="p">.</span><span class="nf">count_nonzero</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
<span class="mi">3</span>
</code></pre></div></div> <h3 id="升高维度和降低维度">升高维度和降低维度</h3> <p>-</p> <h3 id="增加一列">增加一列</h3> <h3 id="保存读取-csv-文件">保存/读取 csv 文件</h3> <ul> <li><a href="https://blog.csdn.net/weixin_38043770/article/details/84103587" rel="external nofollow noopener" target="_blank">使用 numpy，pandas 读取 csv 文件数据_xzn52moon 的博客-CSDN 博客_怎么用 numpy 读取数据 csv 数据</a></li> </ul> <h3 id="提取子矩阵">提取子矩阵</h3> <ul> <li>参考文献：<a href="https://cloud.tencent.com/developer/ask/sof/69599/answer/102244092" rel="external nofollow noopener" target="_blank">用户对问题“如何从 NumPy 2d 数组中提取 mxm 子矩阵(n&gt;m)？”的回答 - 问答 - 腾讯云开发者社区-腾讯云 (tencent.com)</a> </li> </ul> <div class="language-apache highlighter-rouge"><div class="highlight"><pre class="highlight"><code>x=np.arange(16).reshape((4,4))
x[range(1,3), :][:,range(1,3)]
</code></pre></div></div> <h3 id="获取唯一的元素">获取唯一的元素</h3> <h2 id="pandas-一些语法">Pandas 一些语法</h2> <h3 id="获取子表格">获取子表格</h3> <ul> <li>参考文档 1【一个报错记录】：<a href="https://stackoverflow.com/questions/36921951/truth-value-of-a-series-is-ambiguous-use-a-empty-a-bool-a-item-a-any-o" rel="external nofollow noopener" target="_blank">https://stackoverflow.com/questions/36921951/truth-value-of-a-series-is-ambiguous-use-a-empty-a-bool-a-item-a-any-o</a> </li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 训练集
</span><span class="n">train_df</span> <span class="o">=</span> <span class="n">UIT_header</span><span class="p">[</span><span class="n">UIT_header</span><span class="p">[</span><span class="sh">'</span><span class="s">day</span><span class="sh">'</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">18</span><span class="p">]</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">train_df</span><span class="p">))</span>

<span class="n">val_df</span> <span class="o">=</span> <span class="n">UIT_header</span><span class="p">[(</span><span class="n">UIT_header</span><span class="p">[</span><span class="sh">'</span><span class="s">day</span><span class="sh">'</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">18</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">UIT_header</span><span class="p">[</span><span class="sh">'</span><span class="s">day</span><span class="sh">'</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">24</span><span class="p">)]</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">val_df</span><span class="p">))</span>

<span class="n">test_df</span> <span class="o">=</span> <span class="n">UIT_header</span><span class="p">[</span><span class="n">UIT_header</span><span class="p">[</span><span class="sh">'</span><span class="s">day</span><span class="sh">'</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">24</span><span class="p">]</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">test_df</span><span class="p">))</span>
</code></pre></div></div> <ul> <li>根据一堆 index 获取子表格的方法：每次遍历得到的 c 都是一个混乱的 index 组合</li> </ul> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">c</span> <span class="k">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">client_idcs</span><span class="p">):</span>
        <span class="n">sub_labels</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
        <span class="n">sub_test_df</span> <span class="o">=</span> <span class="n">test_df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">c</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">all_split_df</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">sub_test_df</span><span class="p">)</span>
</code></pre></div></div> <h3 id="行遍历与行遍历赋值">行遍历与行遍历赋值</h3> <ul> <li>用于直接对 DataFrame 进行遍历的方法，目前只能用于 get【参考文档：<a href="https://zhuanlan.zhihu.com/p/339744795" rel="external nofollow noopener" target="_blank">https://zhuanlan.zhihu.com/p/339744795</a> 】</li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">idx</span><span class="p">,</span><span class="n">data</span> <span class="ow">in</span> <span class="n">df</span><span class="p">.</span><span class="nf">iterrows</span><span class="p">():</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">[{}]: {}</span><span class="sh">"</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span><span class="n">data</span><span class="p">))</span>
</code></pre></div></div> <ul> <li>行遍历赋值</li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">pandas</span> <span class="k">as</span> <span class="n">pd</span>

<span class="c1"># 创建一个示例 DataFrame
</span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="nc">DataFrame</span><span class="p">({</span><span class="sh">'</span><span class="s">A</span><span class="sh">'</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="sh">'</span><span class="s">B</span><span class="sh">'</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]})</span>

<span class="c1"># 定义一个函数，在每行 DataFrame 中添加一个新的 'C' 字段
</span><span class="k">def</span> <span class="nf">add_new_column</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
    <span class="n">row</span><span class="p">[</span><span class="sh">'</span><span class="s">C</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="sh">'</span><span class="s">A</span><span class="sh">'</span><span class="p">]</span> <span class="o">+</span> <span class="n">row</span><span class="p">[</span><span class="sh">'</span><span class="s">B</span><span class="sh">'</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">row</span>

<span class="c1"># 使用 apply 方法对每行 DataFrame 调用 add_new_column 函数
</span><span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">.</span><span class="nf">apply</span><span class="p">(</span><span class="n">add_new_column</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># 输出添加新字段后的 DataFrame
</span><span class="nf">print</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
</code></pre></div></div> <h3 id="nan-元素处理">nan 元素处理</h3> <ul> <li>判断某个元素是否为 Nan <ul> <li>参考文档：<a href="https://stackoverflow.com/questions/21011777/how-can-i-remove-nan-from-list-python-numpy" rel="external nofollow noopener" target="_blank">How can I remove Nan from list Python/NumPy</a> </li> </ul> </li> </ul> <pre><code class="language-vbscript">pd.isnull("A") 
&gt; False 

pd.isnull(3) 
&gt; False 

pd.isnull(np.nan) 
&gt; True 

pd.isnull(None)
&gt; True
</code></pre> <ul> <li>fillna 空值处理 <ul> <li>参考文档：<a href="https://cloud.tencent.com/developer/ask/28345" rel="external nofollow noopener" target="_blank">https://cloud.tencent.com/developer/ask/28345</a> </li> <li>参考文献：<a href="https://blog.csdn.net/qq_17753903/article/details/89892631" rel="external nofollow noopener" target="_blank">https://blog.csdn.net/qq_17753903/article/details/89892631</a> </li> </ul> </li> </ul> <div class="language-apache highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#fill all Nan value with zero</span>
df = df.fillna(0)

df = df.fillna(method='ffill', axis=0) <span class="c"># 用上一行的值替换空值</span>
df = df.fillna(method='ffill', axis=1) <span class="c"># 用上一列的值替换空值</span>
</code></pre></div></div> <h3 id="拼表操作joinmerge">拼表操作(join/merge)</h3> <ul> <li>参考文献：<a href="https://blog.csdn.net/brucewong0516/article/details/82707492" rel="external nofollow noopener" target="_blank">https://blog.csdn.net/brucewong0516/article/details/82707492</a> </li> <li> <p>主要涉及几个操作</p> <ul> <li>on：拼接列</li> <li>Suffixes：若出现相同的列时，如何重新命名</li> <li>How：如何拼接的问题 <ul> <li>Left： 只保留左表的完整数据</li> <li>inner：取交集：比如 left：[‘A’,‘B’,‘C’];right[’’A,‘C’,‘D’]；inner 取交集的话，left 中出现的 A 会和 right 中出现的买一个 A 进行匹配拼接，如果没有是 B，在 right 中没有匹配到，则会丢失。</li> <li>outer：取并集。比如 left：[‘A’,‘B’,‘C’];right[’’A,‘C’,‘D’]；’outer’取并集，出现的 A 会进行一一匹配，没有同时出现的会将缺失的部分添加缺失值。</li> </ul> </li> </ul> </li> </ul> <div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># bchain_df大，gold_df小，则会按大表来，没有的内容填充空值</span>
<span class="k">all_df</span> <span class="p">=</span> <span class="s">bchain_df.merge(gold_df,</span> <span class="s">how='outer')</span>
</code></pre></div></div> <h3 id="loc-操作--iloc-操作">loc 操作 / iloc 操作</h3> <ul> <li>loc 操作参考文献：<a href="https://blog.csdn.net/brucewong0516/article/details/82494090" rel="external nofollow noopener" target="_blank">https://blog.csdn.net/brucewong0516/article/details/82494090</a> <ul> <li>根据标签（label）索引</li> </ul> </li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dfa</span><span class="p">.</span><span class="n">loc</span><span class="p">[</span><span class="n">dfa</span><span class="p">.</span><span class="n">start_time</span><span class="o">==</span><span class="mi">0</span><span class="p">,</span> <span class="sh">'</span><span class="s">start_time</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">nan</span> <span class="c1"># 取'start_time'中为0的项目，赋值为np.nan
</span></code></pre></div></div> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">stock</span><span class="nc">.loc</span><span class="o">[</span><span class="err">0</span><span class="o">:</span><span class="err">5</span><span class="o">,[</span><span class="s2">'股票代码'</span><span class="o">,</span><span class="s2">'股票名称'</span><span class="o">,</span><span class="s2">'当前价'</span><span class="o">,</span><span class="s2">'涨跌额'</span><span class="o">,</span><span class="s2">'涨跌幅'</span><span class="o">,</span><span class="s2">'年初至今'</span><span class="o">,</span><span class="s2">'成交量'</span><span class="o">,</span><span class="s2">'成交额'</span><span class="o">]]</span>
</code></pre></div></div> <ul> <li>iloc 参考文献：<a href="https://zhuanlan.zhihu.com/p/129898162" rel="external nofollow noopener" target="_blank">https://zhuanlan.zhihu.com/p/129898162</a> <ul> <li>根据行标签的位置索引。iloc 就是 integer loc 。可以理解为是在 loc 的基础上，用整数索引。即 iloc 是基于位置索引的，也就是我们常说的几行几列。</li> </ul> </li> </ul> <div class="language-apache highlighter-rouge"><div class="highlight"><pre class="highlight"><code>stock.iloc[0:6,0:8]
</code></pre></div></div> <h3 id="保存文件">保存文件</h3> <h4 id="保存为-csv-文件效率很慢">保存为 CSV 文件[效率很慢]</h4> <ul> <li>参考文献：<a href="https://blog.csdn.net/tz_zs/article/details/81137998" rel="external nofollow noopener" target="_blank">https://blog.csdn.net/tz_zs/article/details/81137998</a> </li> <li>参考文献 2：<a href="https://blog.csdn.net/qq_38268886/article/details/80744721" rel="external nofollow noopener" target="_blank">https://blog.csdn.net/qq_38268886/article/details/80744721</a> </li> <li>正常来说，应该是会自动填充表头的。</li> </ul> <div class="language-apache highlighter-rouge"><div class="highlight"><pre class="highlight"><code>df.to_csv("tzzs_data2.csv", index_label="index_label")
</code></pre></div></div> <ul> <li>直接将 numpy 保存为 csv</li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nf">trange</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">UIT_header</span><span class="p">)):</span>
    <span class="n">i_size</span><span class="p">[</span><span class="n">UIT_header</span><span class="p">.</span><span class="n">loc</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="sh">'</span><span class="s">i</span><span class="sh">'</span><span class="p">]]</span> <span class="o">=</span> <span class="n">UIT_header</span><span class="p">.</span><span class="n">loc</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="sh">'</span><span class="s">video_size</span><span class="sh">'</span><span class="p">]</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">get content size finished!</span><span class="sh">"</span><span class="p">)</span>
<span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="sh">'</span><span class="s">content_size</span><span class="sh">'</span><span class="p">]</span>
<span class="n">i_size_pd</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="nc">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">i_size</span><span class="p">)</span>
<span class="n">i_size_pd</span><span class="p">.</span><span class="nf">to_csv</span><span class="p">(</span><span class="sh">'</span><span class="s">./dataset/i_size_pd.csv</span><span class="sh">'</span><span class="p">,</span><span class="n">encoding</span><span class="o">=</span><span class="sh">'</span><span class="s">utf-8</span><span class="sh">'</span><span class="p">)</span>
</code></pre></div></div> <ul> <li>不保存那个新的 Unnamed: 0</li> </ul> <h4 id="直接保存为-npy-文件">直接保存为 npy 文件</h4> <ul> <li>参考文献：<a href="https://qa.1r1g.com/sf/ask/4198038771/" rel="external nofollow noopener" target="_blank">https://qa.1r1g.com/sf/ask/4198038771/</a> </li> </ul> <h3 id="保存为特殊的二进制格式pkl-效率很快">保存为特殊的二进制格式(pkl) [效率很快]</h3> <p>先随便用 numpy 生成一个二位数组 <code class="language-plaintext highlighter-rouge">a = np.random.rand(500000, 50)</code>，查看大小约 200MB <code class="language-plaintext highlighter-rouge">print( a._sizeof_())</code>，执行时间 236ms（内存里当然快） 转为一个 df <code class="language-plaintext highlighter-rouge">df = pd.DataFrame(a)</code></p> <ul> <li>test1: 直接用 <code class="language-plaintext highlighter-rouge">df.to_csv('test1.csv')</code>，保存时间 35.7 秒，文件大小 474MB</li> <li>test2: 用 <code class="language-plaintext highlighter-rouge">df.to_pickle('test2.pkl')</code>，保存时间 402ms，几乎是瞬间完成，文件大小 195MB</li> <li>test3: 用 df.to_hdf(‘test3.h5’, ‘table’)，用时 1.72 秒，文件大小 199MB</li> </ul> <h3 id="增加操作">增加操作</h3> <ul> <li>增加一列：<a href="https://blog.csdn.net/qq_35318838/article/details/102720553" rel="external nofollow noopener" target="_blank">https://blog.csdn.net/qq_35318838/article/details/102720553</a> <ul> <li>所有值都一样的列</li> </ul> </li> </ul> <div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">data</span><span class="p">[</span><span class="sc">'d'</span><span class="p">]</span> <span class="p">=</span> <span class="mi">0</span>
</code></pre></div></div> <ul> <li>按条件赋值的列</li> </ul> <div class="language-apache highlighter-rouge"><div class="highlight"><pre class="highlight"><code>df['x1'] = df.apply(lambda x: x.amount <span class="ss">if</span> x.name != "" <span class="ss">else</span> 0, axis=1)
</code></pre></div></div> <h3 id="删除操作">删除操作</h3> <ul> <li>删除特定行： <a href="https://blog.csdn.net/u014636245/article/details/104202889" rel="external nofollow noopener" target="_blank">https://blog.csdn.net/u014636245/article/details/104202889</a> </li> </ul> <div class="language-apache highlighter-rouge"><div class="highlight"><pre class="highlight"><code>df_clear = df.drop(df[df['x']&lt;0.01].index)
<span class="p">&lt;</span>em<span class="p">&gt;</span><span class="c"># 也可以使用多个条件</span>
<span class="p">&lt;/</span>em<span class="p">&gt;</span>df_clear = df.drop(df[(df['x']&lt;0.01) | (df['x']&gt;10)].index) &lt;em&gt;#删除x小于0.01或大于10的行&lt;/em&gt;
</code></pre></div></div> <ul> <li>删除特定列</li> </ul> <div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">small_df</span> <span class="p">=</span> <span class="s">df.drop(columns=['Unnamed:</span> <span class="mi">0</span><span class="s">',</span> <span class="s">'index',</span> <span class="s">'job_name',</span> <span class="s">'task_name',</span> 
                <span class="s">'group',</span> <span class="s">'start_time_j',</span> <span class="s">'end_time_j',</span> <span class="s">'start_time_i',</span> 
                <span class="s">'end_time_i',</span> <span class="s">'run_time_i',</span> <span class="s">'duration_min',</span> <span class="s">'wait_time',</span>
                <span class="s">'start_date'])</span>
</code></pre></div></div> <h3 id="统计-value-操作">统计 value 操作</h3> <ul> <li>参考文献：<a href="https://zhuanlan.zhihu.com/p/113342292" rel="external nofollow noopener" target="_blank">pandas 计数函数 ：value_counts( )和 counts( )的使用</a> </li> </ul> <div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">df</span><span class="p">[</span><span class="s1">'收入'</span><span class="p">]</span><span class="mf">.</span><span class="nf">value_counts</span><span class="p">(</span><span class="n">ascending</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1"># 统计整一列中的每个特定值的数量</span>
<span class="n">df</span><span class="p">[</span><span class="s1">'收入'</span><span class="p">]</span><span class="mf">.</span><span class="nf">counts</span><span class="p">(</span><span class="s2">"123"</span><span class="p">)</span> <span class="c1"># 计算一列中特定值的数量</span>
</code></pre></div></div> <h3 id="向-dataframe-中增加数据">向 DataFrame 中增加数据</h3> <ul> <li>参考文献：<a href="https://blog.csdn.net/goodbye_earth/article/details/85210631" rel="external nofollow noopener" target="_blank">https://blog.csdn.net/goodbye_earth/article/details/85210631</a> </li> <li>很坑爹的语法：df = df.append(data)</li> </ul> <h3 id="整列操作">整列操作</h3> <ul> <li>【风险：可能会引发链式操作，导致一些奇怪的 bug 的产生】map 操作：传入一个 lambda 函数进行执行即可：</li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">small_df</span><span class="p">[</span><span class="sh">'</span><span class="s">plan_gpu</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="n">small_df</span><span class="p">[</span><span class="sh">'</span><span class="s">plan_gpu</span><span class="sh">'</span><span class="p">].</span><span class="nf">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">/</span> <span class="mf">100.0</span><span class="p">)</span>
</code></pre></div></div> <ul> <li>修改方案：直接使用 loc 进行更改比较好！</li> </ul> <div class="language-prolog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="ss">sub_test_df</span><span class="p">.</span><span class="ss">loc</span><span class="p">[</span><span class="ss">sub_test_df</span><span class="p">[</span><span class="ss">'label'</span><span class="p">]</span> <span class="o">==</span> <span class="m">1</span><span class="p">,</span> <span class="ss">'label'</span><span class="p">]</span> <span class="o">=</span> <span class="m">0</span>
<span class="ss">sub_test_df</span><span class="p">.</span><span class="ss">loc</span><span class="p">[</span><span class="ss">sub_test_df</span><span class="p">[</span><span class="ss">'label'</span><span class="p">]</span> <span class="o">==</span> <span class="m">2</span><span class="p">,</span> <span class="ss">'label'</span><span class="p">]</span> <span class="o">=</span> <span class="m">1</span>
</code></pre></div></div> <h3 id="groupby-操作">Groupby 操作</h3> <ul> <li> <p>参考文献：<a href="https://zhuanlan.zhihu.com/p/101284491" rel="external nofollow noopener" target="_blank">https://zhuanlan.zhihu.com/p/101284491</a></p> <ul> <li>标准的 groupby 操作</li> </ul> </li> <li> <p>相同值映射为 index</p> </li> </ul> <div class="language-prolog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="ss">list_drop_items</span> <span class="o">=</span> <span class="ss">small_df</span><span class="p">[</span><span class="ss">'job_id'</span><span class="p">].</span><span class="ss">drop_duplicates</span><span class="p">().</span><span class="ss">values</span><span class="p">.</span><span class="ss">tolist</span><span class="p">()</span>
<span class="ss">job_map</span> <span class="o">=</span> <span class="p">{}</span>
<span class="ss">idx</span> <span class="o">=</span> <span class="m">0</span>
<span class="ss">for</span> <span class="ss">item</span> <span class="ss">in</span> <span class="ss">list_drop_items</span><span class="o">:</span>
    <span class="ss">job_map</span><span class="p">[</span><span class="ss">item</span><span class="p">]</span> <span class="o">=</span> <span class="ss">idx</span>
    <span class="ss">idx</span> <span class="o">+=</span> <span class="m">1</span>
<span class="ss">list_drop_items</span> <span class="o">=</span> <span class="p">[]</span>
<span class="ss">copy_small_df</span> <span class="o">=</span> <span class="ss">small_df</span><span class="p">.</span><span class="ss">copy</span><span class="p">()</span>
<span class="ss">small_df</span><span class="p">[</span><span class="ss">'job_id'</span><span class="p">]</span> <span class="o">=</span> <span class="ss">small_df</span><span class="p">[</span><span class="ss">'job_id'</span><span class="p">].</span><span class="ss">map</span><span class="p">(</span><span class="ss">lambda</span> <span class="ss">x</span><span class="o">:</span> <span class="ss">job_map</span><span class="p">[</span><span class="ss">x</span><span class="p">])</span>
<span class="ss">print</span><span class="p">(</span><span class="ss">small_df</span><span class="p">)</span>
<span class="ss">job_map</span> <span class="o">=</span> <span class="p">{}</span>
</code></pre></div></div> <h3 id="修改列顺序">修改列顺序</h3> <ul> <li>参考文献：<a href="https://blog.csdn.net/a19990412/article/details/81945315" rel="external nofollow noopener" target="_blank">https://blog.csdn.net/a19990412/article/details/81945315</a> <ul> <li>最简单的操作</li> </ul> </li> </ul> <div class="language-apache highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div> <h3 id="表头信息与表头重命名">表头信息与表头重命名</h3> <ul> <li>获取表头的方法：</li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">df</span><span class="p">.</span><span class="n">columns</span> <span class="c1"># 返回表头的信息
</span></code></pre></div></div> <ul> <li>表头重命名的方法：<a href="https://blog.csdn.net/chenKFKevin/article/details/72847622" rel="external nofollow noopener" target="_blank">https://blog.csdn.net/chenKFKevin/article/details/72847622</a> </li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">df</span><span class="p">.</span><span class="nf">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="p">:</span> <span class="sh">'</span><span class="s">beijing_count</span><span class="sh">'</span><span class="p">})</span>
</code></pre></div></div> <ul> <li>读取文件后给表头赋值</li> </ul> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div> <h3 id="排序操作">排序操作</h3> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>df.sort_value(by=["???"])
</code></pre></div></div> <h3 id="采样操作">采样操作</h3> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">privacy_origin_df</span><span class="p">.</span><span class="n">sample</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">100000</span><span class="p">,</span> <span class="k">replace</span><span class="o">=</span><span class="k">False</span><span class="p">)</span>
</code></pre></div></div> <h3 id="链式操作的-bug-解决-settingwithcopy-解决">链式操作的 bug 解决 [SettingwithCopy 解决]</h3> <ul> <li>写的非常详细的一个文档：<a href="https://zhuanlan.zhihu.com/p/41202576" rel="external nofollow noopener" target="_blank">Pandas SettingwithCopy 警告解决方案 - 知乎 (zhihu.com)</a> </li> </ul> <h2 id="tensorflow-一些语法">TensorFlow 一些语法</h2> <h3 id="tensorflow-的版本依赖关系">TensorFlow 的版本依赖关系</h3> <ul> <li><a href="https://tensorflow.google.cn/install/source?hl=zh-cn#gpu" rel="external nofollow noopener" target="_blank">从源代码构建 TensorFlow (google.cn)</a></li> <li> <p>一般来说，tf 需要安装对应版本的 cuda 和 cudnn 【且要直接安装在全局路径 /usr/local 下，建议采用多版本切换的方法，同时还要将/usr/local/cuda/lib64 写入到 LD_LIBRARY_PATH 中！】</p> <ul> <li>安装 cudnn 的教程：<a href="https://www.jianshu.com/p/55551695e7e2" rel="external nofollow noopener" target="_blank">ubuntu 安装 cuda10.2 以及 cudnn7.6.5 - 简书 (jianshu.com)</a> </li> </ul> </li> </ul> <h3 id="静态图获取变量">静态图获取变量</h3> <ul> <li>get_collection() <ul> <li><a href="https://blog.csdn.net/qq_43088815/article/details/89926074" rel="external nofollow noopener" target="_blank">https://blog.csdn.net/qq_43088815/article/details/89926074</a></li> </ul> </li> </ul> <h3 id="session">Session</h3> <ul> <li>参考文档：<a href="https://zhuanlan.zhihu.com/p/32869210" rel="external nofollow noopener" target="_blank">https://zhuanlan.zhihu.com/p/32869210</a> </li> <li> <p>session 是客户端与整个 TensorFlow 系统<strong>交互的接口</strong></p> <ul> <li>session 的创建：<strong>session 拥有和管理物理资源 </strong><strong>CPU</strong><strong>和</strong><strong>GPU</strong><strong>、网络连接的功能</strong>，它最典型的使用方式是作为上下文管理器使用</li> </ul> </li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#  创建本地 session
</span><span class="k">with</span> <span class="n">tf</span><span class="p">.</span><span class="nc">Session</span><span class="p">()</span> <span class="k">as</span> <span class="n">sess</span><span class="p">:</span>
  <span class="c1"># ...
</span>
<span class="c1"># 创建远程 session
</span><span class="k">with</span> <span class="n">tf</span><span class="p">.</span><span class="nc">Session</span><span class="p">(</span><span class="sh">"</span><span class="s">grpc://example.org:2222</span><span class="sh">"</span><span class="p">):</span>
  <span class="c1"># ...
</span></code></pre></div></div> <ul> <li>session 的参数：可以见下一节 配置 Config</li> <li>session 的运行：tf.Session.run 是运行 OP 和获取 tensor 的值的主要方式，可以一次性传入多个 OP 和 tensor 给它，然后 TensorFlow 会自动执行所有需要的 OP 来得到结果</li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="nf">constant</span><span class="p">([[</span><span class="mf">37.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">23.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">]])</span>
<span class="n">w</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="nc">Variable</span><span class="p">(</span><span class="n">tf</span><span class="p">.</span><span class="nf">random_uniform</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="nf">matmul</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
<span class="n">output</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">nn</span><span class="p">.</span><span class="nf">softmax</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="n">init_op</span> <span class="o">=</span> <span class="n">w</span><span class="p">.</span><span class="n">initializer</span>

<span class="k">with</span> <span class="n">tf</span><span class="p">.</span><span class="nc">Session</span><span class="p">()</span> <span class="k">as</span> <span class="n">sess</span><span class="p">:</span>
  <span class="c1"># Run the initializer on `w`.
</span>  <span class="n">sess</span><span class="p">.</span><span class="nf">run</span><span class="p">(</span><span class="n">init_op</span><span class="p">)</span>

  <span class="c1"># 虽然只计算图了 output，但是所有相关的x,w,y 都会被执行，最后返回 NumPy 数组
</span>  <span class="nf">print</span><span class="p">(</span><span class="n">sess</span><span class="p">.</span><span class="nf">run</span><span class="p">(</span><span class="n">output</span><span class="p">))</span>

  <span class="c1"># 这里既执行了 y,又执行了output，可能有人会问，y 是不是会被执行两次，实际并不是，
</span>  <span class="c1"># y 只会执行一次，然后作为 output 的输入
</span>  <span class="n">y_val</span><span class="p">,</span> <span class="n">output_val</span> <span class="o">=</span> <span class="n">sess</span><span class="p">.</span><span class="nf">run</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">output</span><span class="p">])</span>
</code></pre></div></div> <h3 id="配置-config">配置 Config</h3> <ul> <li>参考文档：<a href="https://zhuanlan.zhihu.com/p/32869210" rel="external nofollow noopener" target="_blank">https://zhuanlan.zhihu.com/p/32869210</a> </li> <li> <p>tf.ConfigProto(): session 运行配置</p> <ul> <li>allow_soft_placement 如果指定为 TRUE，那么 session 就会自动把不适合在 GPU 上运行的 OP 全部放到 CPU 上运行。</li> <li> <h2 id="gpu_optionsallow_growth-设置会使得程序在开始时候逐步的增长-gpu-显存使用量而不是一开始就最大化的使用所有显存">gpu_options.allow_growth 设置会使得程序在开始时候逐步的增长 GPU 显存使用量，而不是一开始就最大化的使用所有显存。</h2> </li> </ul> </li> </ul> <h3 id="初始化">初始化</h3> <ul> <li>参考文档：<a href="https://blog.csdn.net/yyhhlancelot/article/details/81415137" rel="external nofollow noopener" target="_blank">https://blog.csdn.net/yyhhlancelot/article/details/81415137</a> </li> </ul> <h4 id="全局变量初始化">全局变量初始化</h4> <ul> <li>tf.global_variables_initializer() <ul> <li>添加节点用于初始化全局变量(GraphKeys.GLOBAL_VARIABLES)。返回一个初始化所有全局变量的操作（Op）。在你构建完整个模型并在会话中加载模型后，运行这个节点。</li> <li>能够将所有的变量一步到位的初始化，非常的方便。通过 feed_dict, 你也可以将指定的列表传递给它，只初始化列表中的变量。</li> </ul> </li> </ul> <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">sess.run(tf.global_variables_initializer(),</span> 
    <span class="s">feed_dict= {</span>
        <span class="s">learning_rate_dis</span><span class="err">:</span> <span class="s">learning_rate_val_dis,</span>
        <span class="s">adam_beta1_d_tf</span><span class="err">:</span> <span class="s">adam_beta1_d,</span>
        <span class="s">learning_rate_proj</span><span class="err">:</span> <span class="s">learning_rate_val_proj,</span>
        <span class="s">lambda_ratio_tf</span><span class="err">:</span> <span class="s">lambda_ratio,</span>
        <span class="s">lambda_l2_tf</span><span class="err">:</span> <span class="s">lambda_l2,</span>
        <span class="s">lambda_latent_tf</span><span class="err">:</span> <span class="s">lambda_latent,</span>
        <span class="s">lambda_img_tf</span><span class="err">:</span> <span class="s">lambda_img,</span>
        <span class="s">lambda_de_tf</span><span class="err">:</span> <span class="s">lambda_de,</span>
        <span class="s">adam_beta1_g_tf</span><span class="err">:</span> <span class="s">adam_beta1_g,</span>
    <span class="s">}</span>
<span class="s">)</span> 
<span class="c1"># learning_rate_dis为设置的变量，learning_rate_val_dis为我设置的具体的值。后续同理</span>
</code></pre></div></div> <h3 id="summary-和-tensorboard">Summary 和 Tensorboard</h3> <ul> <li>参考文档：<a href="https://zhuanlan.zhihu.com/p/102776848" rel="external nofollow noopener" target="_blank">https://zhuanlan.zhihu.com/p/102776848</a> </li> <li>tf.summary()提供了各类方法（支持各种多种格式）用于保存训练过程中产生的数据（比如 loss_value、accuracy、整个 variable），这些数据以日志文件的形式保存到指定的文件夹中。</li> </ul> <div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">tensorboard</span> <span class="s">--logdir=./</span> <span class="c1"># 默认localhost和6006</span>
</code></pre></div></div> <div class="language-apache highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tensorboard --logdir=./ --host 服务器ip --port 23445
</code></pre></div></div> <h3 id="saver">Saver</h3> <ul> <li>参考文档：<a href="https://www.cnblogs.com/denny402/p/6940134.html" rel="external nofollow noopener" target="_blank">https://www.cnblogs.com/denny402/p/6940134.html</a> </li> </ul> <p>模型保存，先要创建一个 Saver 对象：</p> <div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">saver</span><span class="o">=</span>tf.train.Saver<span class="o">()</span>
</code></pre></div></div> <h4 id="保存操作">保存操作</h4> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>saver.save<span class="o">(</span>sess,<span class="s1">'ckpt/mnist.ckpt'</span>,global_step<span class="o">=</span>step<span class="o">)</span>
</code></pre></div></div> <p>在创建这个 Saver 对象的时候，有一个参数我们经常会用到，就是 max_to_keep 参数，这个是用来设置保存模型的个数，默认为 5，即 max_to_keep=5，保存最近的 5 个模型。如果你想每训练一代（epoch)就想保存一次模型，则可以将 max_to_keep 设置为 None 或者 0。</p> <h4 id="恢复操作">恢复操作</h4> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">model_file</span><span class="o">=</span>tf.train.latest_checkpoint<span class="o">(</span><span class="s1">'ckpt/'</span><span class="o">)</span>
saver.restore<span class="o">(</span>sess,model_file<span class="o">)</span>
</code></pre></div></div> <h3 id="multinomial-操作">Multinomial 操作</h3> <ul> <li>参考文献：<a href="https://blog.csdn.net/qq1483661204/article/details/78962940" rel="external nofollow noopener" target="_blank">https://blog.csdn.net/qq1483661204/article/details/78962940</a> </li> <li>对一批次的数组，其 values 代表采样的概率，最后返回的是一批次的采样结果</li> </ul> <h3 id="tfgradienttape">tf.GradientTape</h3> <ul> <li>参考文献： <a href="https://blog.csdn.net/guanxs/article/details/102471843" rel="external nofollow noopener" target="_blank">https://blog.csdn.net/guanxs/article/details/102471843</a> </li> <li>一个求导的上下文管理器，可以用于求导。</li> </ul> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">with</span> <span class="n">tf</span><span class="p">.</span><span class="n">GradientTape</span><span class="p">()</span> <span class="k">as</span> <span class="n">tape</span><span class="p">:</span>
    <span class="n">predictions</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">images</span><span class="p">)</span>
    <span class="n">loss</span> <span class="o">=</span> <span class="n">loss_object</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">predictions</span><span class="p">)</span>
<span class="n">gradients</span> <span class="o">=</span> <span class="n">tape</span><span class="p">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">loss</span><span class="p">,</span> <span class="n">model</span><span class="p">.</span><span class="n">trainable_variables</span><span class="p">)</span>
</code></pre></div></div> <h3 id="tflosses-函数">tf.losses 函数</h3> <h4 id="sparse_softmax_cross_entropy">sparse_softmax_cross_entropy</h4> <h3 id="coordinator">Coordinator</h3> <ul> <li>知乎上的一些教程：<a href="https://zhuanlan.zhihu.com/p/29729954" rel="external nofollow noopener" target="_blank">[TensorFlow] 利用 tensorflow 中的队列和多线程读取数据来加快模型训练速度</a> </li> <li>官网文档：<a href="https://www.tensorflow.org/api_docs/python/tf/train/Coordinator" rel="external nofollow noopener" target="_blank">https://www.tensorflow.org/api_docs/python/tf/train/Coordinator</a> </li> </ul> <p>###</p> <h2 id="torch-一些语法">Torch 一些语法</h2> <h3 id="torch-sparse-安装失败原因">Torch sparse 安装失败原因</h3> <ul> <li>参考文献： <a href="https://cleverbobo.github.io/2020/10/22/install-torch-sparse/" rel="external nofollow noopener" target="_blank">如何安装 torch-sparse</a> </li> <li>官方安装教程：<a href="https://pytorch-geometric.readthedocs.io/en/latest/notes/installation.html" rel="external nofollow noopener" target="_blank">https://pytorch-geometric.readthedocs.io/en/latest/notes/installation.html</a> </li> </ul> <h3 id="torch-实现图神经网络">torch 实现图神经网络</h3> <ul> <li>参考文献：<a href="https://zhuanlan.zhihu.com/p/94491664" rel="external nofollow noopener" target="_blank">https://zhuanlan.zhihu.com/p/94491664</a> </li> <li> <p>PyG（PyTorch Geometric Library）</p> <ul> <li>基于 PyTorch 的用于处理不规则数据（比如图）的库，或者说是一个用于在图等数据上快速实现表征学习的框架。它的运行速度很快，训练模型速度可以达到 DGL（Deep Graph Library ）v0.2 的 40 倍（数据来自论文）。</li> <li>集成了很多论文中提出的方法（GCN,SGC,GAT,SAGE 等等）和常用数据集。</li> </ul> </li> <li> <p>Data 数据结构</p> <ul> <li>节点的属性/特征</li> </ul> </li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">tensor</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">],[</span><span class="mi">12</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="p">.</span><span class="nb">float</span><span class="p">)</span> <span class="c1"># 特征
</span><span class="n">y</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">tensor</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="p">.</span><span class="nb">float</span><span class="p">)</span> <span class="c1"># label
</span></code></pre></div></div> <ul> <li>邻接/边连接信息：图的节点连接信息要以 COO 格式进行存储。在 COO 格式中，COO list 是一个 2*E 维的 list。第一个维度的节点是源节点(source nodes)，第二个维度中是目标节点(target nodes)，连接方式是由源节点指向目标节点。对于无向图来说，存贮的 source nodes 和 target node 是成对存在的。</li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">edge_index</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">tensor</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span>
                          <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]],</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="p">,</span><span class="nb">long</span><span class="p">)</span>
</code></pre></div></div> <h3 id="modeltrain和-modeleval">model.train()和 model.eval()</h3> <ul> <li>参考文献：<a href="https://blog.csdn.net/qq_38410428/article/details/101102075" rel="external nofollow noopener" target="_blank">https://blog.csdn.net/qq_38410428/article/details/101102075</a> <ul> <li>如果模型中有 BN 层(Batch Normalization）和 Dropout，需要在训练时添加 model.train()。model.train()是保证 BN 层能够用到每一批数据的均值和方差。对于 Dropout，model.train()是随机取一部分网络连接来训练更新参数。</li> <li>如果模型中有 BN 层(Batch Normalization）和 Dropout，在测试时添加 model.eval()。model.eval()是保证 BN 层能够用全部训练数据的均值和方差，即测试过程中要保证 BN 层的均值和方差不变。对于 Dropout，model.eval()是利用到了所有网络连接，即不进行随机舍弃神经元。</li> <li>训练完 train 样本后，生成的模型 model 要用来测试样本。在 model(test)之前，需要加上 <code class="language-plaintext highlighter-rouge">model.eval()</code>，否则的话，有输入数据，即使不训练，它也会改变权值。这是 model 中含有 BN 层和 Dropout 所带来的的性质。</li> <li>如果不在意显存大小和计算时间的话，仅仅使用 <code class="language-plaintext highlighter-rouge">model.eval()</code> 已足够得到正确的 validation/test 的结果；而 <code class="language-plaintext highlighter-rouge">with torch.no_grad()</code> 则是更进一步加速和节省 gpu 空间（因为不用计算和存储梯度），从而可以更快计算，也可以跑更大的 batch 来测试。</li> </ul> </li> </ul> <h3 id="学习率-lr_scheduler">学习率 lr_scheduler</h3> <ul> <li>参考文献：<a href="https://blog.csdn.net/qyhaill/article/details/103043637" rel="external nofollow noopener" target="_blank">https://blog.csdn.net/qyhaill/article/details/103043637</a> </li> </ul> <h3 id="保存模型与加载模型">保存模型与加载模型</h3> <ul> <li>参考文献：<a href="https://pytorch123.com/ThirdSection/SaveModel/" rel="external nofollow noopener" target="_blank">保存和加载模型 - PyTorch 官方教程中文版</a> </li> <li>可以保存模型和优化器的参数</li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 加载模型
</span><span class="n">seq2seq_model</span><span class="p">.</span><span class="nf">load_state_dict</span><span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="n">cfg</span><span class="p">.</span><span class="n">lstm_model_path</span><span class="p">))</span>
</code></pre></div></div> <h3 id="categorical">Categorical</h3> <ul> <li>参考文献：<a href="https://www.cnblogs.com/pprp/p/14285062.html" rel="external nofollow noopener" target="_blank">https://www.cnblogs.com/pprp/p/14285062.html</a> <ul> <li>distributions 包主要是实现了参数化的概率分布和采样函数。参数化是为了让模型能够具有反向传播的能力，这样才可以用随机梯度下降的方法来进行优化。</li> </ul> </li> </ul> <h3 id="detach-函数">Detach 函数</h3> <ul> <li>参考文献：<a href="https://zhuanlan.zhihu.com/p/410199046" rel="external nofollow noopener" target="_blank">https://zhuanlan.zhihu.com/p/410199046</a> </li> <li>作用：detach()就是返回一个新的 tensor，并且这个 tensor 是从当前的计算图中分离出来的。但是返回的 tensor 和原来的 tensor 是共享内存空间的。</li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">torch</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">tensor</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">],</span> <span class="n">requires_grad</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="nf">detach</span><span class="p">()</span> <span class="c1"># 会将requires_grad 属性设置为False
</span><span class="nf">print</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">requires_grad</span><span class="p">)</span>
</code></pre></div></div> <h3 id="问题修复-同时-backward-两个网络">问题修复: 同时 backward 两个网络</h3> <ul> <li>参考文献：<a href="https://blog.csdn.net/weixin_44058333/article/details/99701876" rel="external nofollow noopener" target="_blank">https://blog.csdn.net/weixin_44058333/article/details/99701876</a> </li> <li> <p>retain_graph 这个参数在平常中我们是用不到的，但是在特殊的情况下我们会用到它：</p> <ul> <li>一个网络有两个 output 分别执行 backward 进行回传的时候: output1.backward(), output2.backward().</li> <li>一个网络有两个 loss 需要分别执行 backward 进行回传的时候: loss1.backward(), loss1.backward().</li> </ul> </li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#两个网络的情况需要分别为两个网络分别定义optimizer
</span><span class="n">optimizer1</span><span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">optim</span><span class="p">.</span><span class="nc">SGD</span><span class="p">(</span><span class="n">net1</span><span class="p">.</span><span class="nf">parameters</span><span class="p">(),</span> <span class="n">learning_rate</span><span class="p">,</span> <span class="n">momentum</span><span class="p">,</span><span class="n">weight_decay</span><span class="p">)</span>
<span class="n">optimizer2</span><span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">optim</span><span class="p">.</span><span class="nc">SGD</span><span class="p">(</span><span class="n">net2</span><span class="p">.</span><span class="nf">parameters</span><span class="p">(),</span> <span class="n">learning_rate</span><span class="p">,</span> <span class="n">momentum</span><span class="p">,</span><span class="n">weight_decay</span><span class="p">)</span>

<span class="c1">#train 部分的loss回传处理
</span><span class="n">loss1</span> <span class="o">=</span> <span class="nf">loss</span><span class="p">()</span>
<span class="n">loss2</span> <span class="o">=</span> <span class="nf">loss</span><span class="p">()</span>

<span class="n">optimizer1</span><span class="p">.</span><span class="nf">zero_grad</span><span class="p">()</span> <span class="c1">#set the grade to zero
</span><span class="n">loss1</span><span class="p">.</span><span class="nf">backward</span><span class="p">(</span><span class="n">retain_graph</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="c1">#保留backward后的中间参数。
</span><span class="n">optimizer1</span><span class="p">.</span><span class="nf">step</span><span class="p">()</span>

<span class="n">optimizer2</span><span class="p">.</span><span class="nf">zero_grad</span><span class="p">()</span> <span class="c1">#set the grade to zero
</span><span class="n">loss2</span><span class="p">.</span><span class="nf">backward</span><span class="p">()</span> 
<span class="n">optimizer2</span><span class="p">.</span><span class="nf">step</span><span class="p">()</span>
</code></pre></div></div> <h3 id="genum函数">ge(num)函数</h3> <ul> <li>参考文献：<a href="https://zhuanlan.zhihu.com/p/348035584" rel="external nofollow noopener" target="_blank">https://zhuanlan.zhihu.com/p/348035584</a> <ul> <li>torch.Tensor 可以调用该函数</li> <li>获取 bool 掩码，当 item&gt;num 的时候，设置为 True，否则为 False</li> </ul> </li> </ul> <h3 id="chunk函数">chunk()函数</h3> <ul> <li>参考文献：<a href="https://cloud.tencent.com/developer/article/1794326" rel="external nofollow noopener" target="_blank">https://cloud.tencent.com/developer/article/1794326</a> </li> <li> <p>函数会将输入张量（input）沿着指定维度（dim）均匀的分割成特定数量的张量块（chunks），并返回元素为张量块的<strong>元组</strong><strong>（</strong><strong>tuple</strong><strong>）</strong>。torch.chunk 函数有三个参数：</p> <ul> <li>input（Tensor）- 待分割的输入张量</li> <li>chunks（int）- 均匀分割张量块的数量</li> <li>dim（int）- 进行分割的维度</li> </ul> </li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">torch</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">))</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">chunk</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="n">A</span><span class="p">,</span>
                     <span class="n">chunks</span><span class="o">=</span><span class="mi">14</span><span class="p">,</span>
                     <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
<span class="c1"># 13
</span><span class="nf">print</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">size</span><span class="p">())</span>
<span class="c1"># torch.Size([10, 3, 32, 32])
</span><span class="nf">print</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="nf">size</span><span class="p">())</span>
<span class="c1"># torch.Size([8, 3, 32, 32])
</span></code></pre></div></div> <ul> <li>注意，最后如果要重新变成 Tensor，可以执行这个函数</li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">B</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">randn</span><span class="p">((</span><span class="mi">1185024</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">stack</span><span class="p">(</span><span class="n">B</span><span class="p">.</span><span class="nf">chunk</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span><span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
<span class="nf">print</span><span class="p">(</span><span class="n">res</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span> <span class="c1"># torch.Size([64, 18516, 2])
</span></code></pre></div></div> <h3 id="masked_select">masked_select</h3> <ul> <li>参考文献：<a href="https://zhuanlan.zhihu.com/p/348035584" rel="external nofollow noopener" target="_blank">https://zhuanlan.zhihu.com/p/348035584</a> </li> <li> <p>torch.masked_select(<em>input, mask, out=None</em>) 函数返回一个根据布尔掩码 (boolean mask) 索引输入张量的 1D 张量，其中布尔掩码和输入张量就是 torch.masked_select(<em>input, mask, out = None</em>) 函数的两个关键参数，函数的参数有：</p> <ul> <li>input(Tensor) - 需要进行索引操作的输入张量；</li> <li>mask(BoolTensor) - 要进行索引的布尔掩码；</li> <li>out(Tensor, optional) - 指定输出的张量。比如执行 torch.zeros([2, 2], out = tensor_a)，相当于执行 tensor_a = torch.zeros([2, 2])；</li> </ul> </li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">torch</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">randn</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="nf">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="c1"># 将x中的每一个元素与0.5进行比较
# 当元素大于等于0.5返回True,否则返回False
</span><span class="n">mask</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="nf">ge</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="nf">masked_select</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mask</span><span class="p">))</span>

<span class="sh">'''</span><span class="s">
tensor([[ 1.2001,  1.2968, -0.6657, -0.6907],
        [-2.0099,  0.6249, -0.5382,  1.4458],
        [ 0.0684,  0.4118,  0.1011, -0.5684]])
tensor([[ True,  True, False, False],
        [False,  True, False,  True],
        [False, False, False, False]])
tensor([1.2001, 1.2968, 0.6249, 1.4458])
</span><span class="sh">'''</span>
</code></pre></div></div> <h3 id="损失函数-loss-function">损失函数 Loss Function</h3> <ul> <li>参考文献：<a href="https://zhuanlan.zhihu.com/p/61379965" rel="external nofollow noopener" target="_blank">https://zhuanlan.zhihu.com/p/61379965</a> </li> </ul> <h3 id="squeeze-和-unsqueeze-函数">Squeeze 和 Unsqueeze 函数</h3> <ul> <li>参考文献： <a href="https://blog.csdn.net/xiexu911/article/details/80820028" rel="external nofollow noopener" target="_blank">https://blog.csdn.net/xiexu911/article/details/80820028</a> </li> <li> <p><strong>torch.squeeze(): </strong>这个函数主要对数据的维度进行压缩，去掉维数为 1 的的维度，比如是一行或者一列这种，一个一行三列（1,3）的数去掉第一个维数为一的维度之后就变成（3）行。</p> <ul> <li>a.squeeze(N) 就是在 a 中指定位置 N 加上一个维数为 1 的维度。还有一种形式就是 b=torch.squeeze(a，N) a 就是在 a 中指定位置 N 加上一个维数为 1 的维度。</li> </ul> </li> <li> <strong>torch.unsqueeze(): </strong>这个函数主要是对数据维度进行扩充。给指定位置加上维数为一的维度，比如原本有个三行的数据（3），在 0 的位置加了一维就变成一行三列（1,3）。</li> </ul> <h3 id="拼接-tensor-1">拼接 Tensor</h3> <ul> <li>参考文献：<a href="https://blog.csdn.net/weixin_44613063/article/details/89576810" rel="external nofollow noopener" target="_blank">https://blog.csdn.net/weixin_44613063/article/details/89576810</a> <ul> <li>这种做法比 Numpy 感觉还要好，不会凭空多出来一个维度</li> </ul> </li> </ul> <div class="language-fortran highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">torch</span><span class="err">.</span><span class="n">stack</span><span class="p">(</span><span class="k">sequence</span><span class="p">,</span><span class="w"> </span><span class="nb">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="w">
</span></code></pre></div></div> <h3 id="判断-tensormodel-是否在外部设备上">判断 Tensor/Model 是否在外部设备上</h3> <ul> <li>参考文献：<a href="https://blog.csdn.net/WYXHAHAHA123/article/details/86596981" rel="external nofollow noopener" target="_blank">pytorch 查看 torch.Tensor 和 model 是否在 CUDA 上_WYXHAHAHA123 的博客-CSDN 博客_pytorch 查看模型所在设备</a> </li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">torch</span>
<span class="kn">import</span> <span class="n">torchvision.models</span> <span class="k">as</span> <span class="n">models</span>
<span class="n">model</span><span class="o">=</span><span class="n">models</span><span class="p">.</span><span class="nf">vgg11</span><span class="p">(</span><span class="n">pretrained</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">next</span><span class="p">(</span><span class="n">model</span><span class="p">.</span><span class="nf">parameters</span><span class="p">()).</span><span class="n">is_cuda</span><span class="p">)</span> <span class="c1">#False
</span>
<span class="n">data</span><span class="o">=</span><span class="n">torch</span><span class="p">.</span><span class="nf">ones</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="nf">print</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">device</span><span class="p">)</span> <span class="c1">#cpu
</span></code></pre></div></div> <h3 id="只打印数值不打印设备信息">只打印数值，不打印设备信息</h3> <ul> <li>参考文献：<a href="https://blog.csdn.net/sjtuxx_lee/article/details/83116427" rel="external nofollow noopener" target="_blank">pytorch 下只打印 tensor 的数值不打印出 device 等信息的方法_sjtuxx_lee 的博客-CSDN 博客_pytorch 打印 tensor</a> </li> </ul> <div class="language-fortran highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="s1">'batch_loss: {:.3f} batch acc: {:.3f}'</span><span class="err">.</span><span class="k">format</span><span class="p">(</span><span class="l">loss.data</span><span class="p">,</span><span class="w"> </span><span class="l">acc.data</span><span class="p">))</span><span class="w">
</span></code></pre></div></div> <h3 id="梯度传播因为更改的时候-runtimeerror">梯度传播因为更改的时候 RuntimeError</h3> <ul> <li>参考文献：<a href="https://m.hupu.com/bbs/35366708.html" rel="external nofollow noopener" target="_blank">求 pytorch 大神解答，问题出在哪里_虎扑</a> </li> </ul> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Actor</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="no">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="n">state_dim</span><span class="p">,</span> <span class="n">action_dim</span><span class="p">):</span>
        <span class="k">super</span><span class="p">(</span><span class="no">Actor</span><span class="p">,</span> <span class="nb">self</span><span class="p">).</span><span class="nf">__init__</span><span class="p">()</span>
        <span class="nb">self</span><span class="p">.</span><span class="nf">actor</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="no">Sequential</span><span class="p">(</span>
            <span class="n">nn</span><span class="o">.</span><span class="no">Linear</span><span class="p">(</span><span class="n">state_dim</span><span class="p">,</span> <span class="n">action_dim</span><span class="p">),</span>
            <span class="n">nn</span><span class="o">.</span><span class="no">Tanh</span><span class="p">(),</span>
        <span class="p">)</span> 

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="n">raw_action</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="nf">actor</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="n">raw_action</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="no">F</span><span class="p">.</span><span class="nf">softmax</span><span class="p">(</span><span class="n">raw_action</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># 会报错！！！</span>
        <span class="k">return</span> <span class="n">raw_action</span>
</code></pre></div></div> <h3 id="gather">gather()</h3> <ul> <li>参考文献：<a href="https://zhuanlan.zhihu.com/p/352877584" rel="external nofollow noopener" target="_blank">https://zhuanlan.zhihu.com/p/352877584</a> <ul> <li>讲的非常有用，终于看懂了一次</li> <li>具体的应用场景在这里：/home/linchangxiao/labInDiWu/easy-rl/codes/DQN/task0.py</li> </ul> </li> </ul> <h3 id="获得向量中特定值所在的-index">获得向量中特定值所在的 index</h3> <ul> <li>参考文献：<a href="https://www.xknote.com/ask/60cd06db4d757.html" rel="external nofollow noopener" target="_blank">https://www.xknote.com/ask/60cd06db4d757.html</a> </li> </ul> <h3 id="dataloader-和-subset-和自定义-dataset">DataLoader 和 Subset 和自定义 Dataset</h3> <ul> <li>参考文献：<a href="https://stackoverflow.com/questions/44429199/how-to-load-a-list-of-numpy-arrays-to-pytorch-dataset-loader" rel="external nofollow noopener" target="_blank">How to load a list of numpy arrays to pytorch dataset loader?</a> </li> <li> <p>参考文献[自定义 Dataset]：<a href="https://www.cnblogs.com/orion-orion/p/15906086.html" rel="external nofollow noopener" target="_blank">Pytorch：自定义 Subset/Dataset 类完成数据集拆分 - orion-orion - 博客园 (cnblogs.com)</a></p> <ul> <li>Subset 对象虽然仍然还存有 data 属性，但是内置的 target 和 classes 属性已经不复存在。</li> </ul> </li> <li>注意：DataLoader 只是给数据集封装一个类，为了更少的使用空间，一般只会在内存中维护一个 dataset 实例，而 DataLoader 只是确定如何 load 这个 dataset 而已。</li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">torch</span> 
<span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span> 
<span class="kn">from</span> <span class="n">torch.utils.data</span> <span class="kn">import</span> <span class="n">TensorDataset</span><span class="p">,</span> <span class="n">DataLoader</span>

<span class="n">my_x</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([[</span><span class="mf">1.0</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]]),</span><span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([[</span><span class="mf">5.</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">]])]</span> <span class="c1"># a list of numpy arrays 
</span><span class="n">my_y</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="mf">4.</span><span class="p">]),</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="mf">2.</span><span class="p">])]</span> <span class="c1"># another list of numpy arrays (targets) 
</span><span class="n">tensor_x</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nc">Tensor</span><span class="p">(</span><span class="n">my_x</span><span class="p">)</span> <span class="c1"># transform to torch tensor 
</span><span class="n">tensor_y</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nc">Tensor</span><span class="p">(</span><span class="n">my_y</span><span class="p">)</span> 
<span class="n">my_dataset</span> <span class="o">=</span> <span class="nc">TensorDataset</span><span class="p">(</span><span class="n">tensor_x</span><span class="p">,</span><span class="n">tensor_y</span><span class="p">)</span> <span class="c1"># create your datset 
</span><span class="n">my_dataloader</span> <span class="o">=</span> <span class="nc">DataLoader</span><span class="p">(</span><span class="n">my_dataset</span><span class="p">)</span> <span class="c1"># create your dataloader
</span></code></pre></div></div> <h3 id="cuda-操作的异步性和手动同步方案">cuda 操作的异步性和手动同步方案</h3> <p>在执行 <code class="language-plaintext highlighter-rouge">torch.matmul(x, y)</code> 这样的 CUDA 操作后需要进行同步的原因是为了确保操作的完成。CUDA 操作通常是异步的，这意味着当你调用一个 CUDA 操作时，它可能会立即返回并开始在 GPU 上执行，而不会等待操作的实际完成。这是为了充分利用 GPU 的并行性能。</p> <p>但在某些情况下，你可能需要确保 CUDA 操作已经完成，才能继续执行后续的操作，例如：</p> <ol> <li> <strong>测量操作执行时间</strong>：如果你想测量某个 CUDA 操作的执行时间，那么在执行操作后立即同步可以确保计时的准确性。如果不同步，计时可能会在操作实际完成之前结束。</li> <li> <strong>操作顺序的</strong><strong>依赖性</strong>：如果你的后续操作依赖于前面的 CUDA 操作的结果，那么同步可以确保前面的操作已经完成，从而避免数据依赖性错误。</li> <li> <strong>结果一致性</strong>：在某些情况下，你可能需要确保 CUDA 操作的结果在继续执行后续操作之前已经准备好，以避免数据不一致性。</li> </ol> <p>因此，同步 CUDA 设备是一种控制操作执行顺序和确保操作已经完成的方式。你可以使用 <code class="language-plaintext highlighter-rouge">torch.cuda.synchronize()</code> 函数来实现同步，确保在继续执行后续操作之前等待 CUDA 操作的完成。这对于需要精确控制和管理 CUDA 操作的应用非常重要。</p> <div class="language-apache highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import torch

<span class="c"># 创建两个张量并将它们移到 CUDA 设备上</span>
x = torch.randn(1000, 1000).cuda()
y = torch.randn(1000, 1000).cuda()

<span class="c"># 执行一些 CUDA 操作</span>
result = torch.matmul(x, y)

<span class="c"># 同步 CUDA 设备</span>
torch.cuda.synchronize()

<span class="c"># 执行其他操作</span>
z = torch.randn(1000, 1000).cuda()
</code></pre></div></div> <h3 id="torchcudastream">torch.cuda.Stream()</h3> <ul> <li>Steam 是 CUDA 命令线性执行的抽象形式，分配给设备的 CUDA 命令按照入队序列的顺序执行。每个设备都有一个默认的 Steam，也可以通过 torch.cuda.Stream()创建新的 Stream。如果不同 Stream 中的命令交互执行，那么就不能保证命令绝对按顺序执行。下面的这个例子不同的 Stream 就可能会产生错误。</li> </ul> <div class="language-apache highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cuda = torch.device("cuda")
<span class="c"># 创建默认的stream，A就是使用的默认stream</span>
s = torch.cuda.Stream()
A = torch.randn((1,10), device=cuda)
for i <span class="ss">in</span> range(100):
    <span class="c"># 在新的stream上对默认的stream上创建的tensor进行求和</span>
    with torch.cuda.stream(s):
        <span class="c"># 存在的问题是：torch.sum()可能会在torch.randn()之前执行</span>
        B = torch.sum(A)
        print(B)
</code></pre></div></div> <ul> <li>这个例子存在的问题是 torch.sum()可能会在 torch.randn()之前就执行。为了保证 Stream 中的命令绝对按顺序执行，接下来使用 Synchronize 同步方法解决上面例子的问题：</li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cuda</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">device</span><span class="p">(</span><span class="sh">"</span><span class="s">cuda</span><span class="sh">"</span><span class="p">)</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">cuda</span><span class="p">.</span><span class="nc">Stream</span><span class="p">()</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">randn</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">10</span><span class="p">),</span> <span class="n">device</span><span class="o">=</span><span class="n">cuda</span><span class="p">)</span>
<span class="n">default_stream</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">cuda</span><span class="p">.</span><span class="nf">current_stream</span><span class="p">()</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Default Stream: {}</span><span class="sh">"</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">default_stream</span><span class="p">))</span>
<span class="c1"># 等待创建A的stream执行完毕
</span><span class="n">torch</span><span class="p">.</span><span class="n">cuda</span><span class="p">.</span><span class="n">Stream</span><span class="p">.</span><span class="nf">synchronize</span><span class="p">(</span><span class="n">default_stream</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">100</span><span class="p">):</span>
    <span class="c1"># 在新的stream上对默认的stream上创建的tensor进行求和
</span>    <span class="k">with</span> <span class="n">torch</span><span class="p">.</span><span class="n">cuda</span><span class="p">.</span><span class="nf">stream</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">current stream: {}</span><span class="sh">"</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="n">cuda</span><span class="p">.</span><span class="nf">current_stream</span><span class="p">()))</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
</code></pre></div></div> <h3 id="固定缓冲区与-pin_memory">固定缓冲区与 pin_memory</h3> <ul> <li>缓存就是当计算机内存不足的时候，就会把内存中的数据存储到硬盘上。固定缓冲区就是说常驻内存，不能把这部分数据缓存到硬盘上。可以直接使用 pin_memory 方法或在 Tensor 上直接调用 pin_memory 方法将 Tensor 复制到固定缓冲区。为什么要做固定缓冲区呢？目的只有一个，就是把 CPU 上的固定缓冲区拷贝到 GPU 上时速度快。Tensor 上的 is_pinned 方法可以查看该 Tensor 是否加载到固定缓冲区中。</li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">torch.utils.data._utils.pin_memory</span> <span class="kn">import</span> <span class="n">pin_memory</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nc">Tensor</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">10</span><span class="p">]])</span>
<span class="c1"># 通过pin_memory()方法将x复制到固定缓冲区
</span><span class="n">y</span> <span class="o">=</span> <span class="nf">pin_memory</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="c1"># 在tensor上直接调用pin_memory()方法将tensor复制到固定缓冲区
</span><span class="n">z</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="nf">pin_memory</span><span class="p">()</span>
<span class="c1"># id()方法返回tensor的内存地址，pin_memory()返回tensor对象的拷贝，因此内存地址是不同的
</span><span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">id: {}</span><span class="sh">"</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="nf">id</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">id: {}</span><span class="sh">"</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="nf">id</span><span class="p">(</span><span class="n">y</span><span class="p">)))</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">id: {}</span><span class="sh">"</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="nf">id</span><span class="p">(</span><span class="n">z</span><span class="p">)))</span>
<span class="c1"># 当tensor放入固定缓冲区后，就可以异步将数据复制到gpu设备上了
</span><span class="n">a</span> <span class="o">=</span> <span class="n">z</span><span class="p">.</span><span class="nf">cuda</span><span class="p">(</span><span class="n">non_blocking</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">is_pinned: {}/{}</span><span class="sh">"</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="nf">is_pinned</span><span class="p">(),</span> <span class="n">z</span><span class="p">.</span><span class="nf">is_pinned</span><span class="p">()))</span>

<span class="c1"># id: 1605289350472
# id: 1605969660408
# id: 1605969660248
# tensor([[ 1.,  2.,  4.],
#         [ 5.,  7.,  9.],
#         [ 3.,  7., 10.]], device='cuda:0')
# is_pinned: False/True
</span></code></pre></div></div> <h3 id="pytorch-原理---如何把数据从-cpu-传到-gpu-中dispatcher-cuda-调度">Pytorch 原理 - 如何把数据从 CPU 传到 GPU 中(dispatcher, cuda, 调度)</h3> <ul> <li>参考文献：<a href="https://www.cnblogs.com/rossiXYZ/p/15518457.html" rel="external nofollow noopener" target="_blank">[源码解析] PyTorch 如何使用 GPU - 罗西的思考 - 博客园 (cnblogs.com)</a> </li> </ul> <h3 id="cudacudnncuda-toolkit-的区别">cuda、cudnn、cuda toolkit 的区别</h3> <ul> <li>参考文献：<a href="https://blog.csdn.net/qq_41094058/article/details/116207333" rel="external nofollow noopener" target="_blank">【精选】一文讲清楚 CUDA、CUDA toolkit、CUDNN、NVCC 关系_健 0000 的博客-CSDN 博客</a> </li> <li> <p>区分</p> <ul> <li>CUDA：为“GPU 通用计算”构建的运算平台。</li> <li>cudnn：为深度学习计算设计的软件库。</li> <li>CUDA Toolkit (nvidia)： CUDA 完整的工具安装包，其中提供了 Nvidia 驱动程序、开发 CUDA 程序相关的开发工具包等可供安装的选项。包括 CUDA 程序的编译器、IDE、调试器等，CUDA 程序所对应的各式库文件以及它们的头文件。</li> <li>CUDA Toolkit (Pytorch)： CUDA 不完整的工具安装包，其主要包含在使用 CUDA 相关的功能时所依赖的动态链接库。不会安装驱动程序。</li> <li>NVCC 是 CUDA 的编译器，只是 CUDA Toolkit 中的一部分</li> </ul> </li> <li>注：CUDA Toolkit 完整和不完整的区别：在安装了 CUDA Toolkit (Pytorch)后，只要系统上存在与当前的 cudatoolkit 所兼容的 Nvidia 驱动，则已经编译好的 CUDA 相关的程序就可以直接运行，不需要重新进行编译过程。如需要为 Pytorch 框架添加 CUDA 相关的拓展时（Custom C++ and CUDA Extensions），需要对编写的 CUDA 相关的程序进行编译等操作，则需安装完整的 Nvidia 官方提供的 CUDA Toolkit。</li> <li>pytorch 运行时的 CUDA 版本</li> </ul> <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="kt">Pytorch</span> <span class="err">实际使用的运行时的</span> <span class="n">cuda</span> <span class="err">目录</span>
<span class="kr">import</span> <span class="nn">torch.utils.cpp_extension</span>
<span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">cpp_extension</span><span class="o">.</span><span class="kt">CUDA_HOME</span>
<span class="o">#</span> <span class="n">'</span><span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">cuda</span><span class="o">-</span><span class="mf">11.6</span><span class="n">'</span>
<span class="o">#</span> <span class="err">编译该</span> <span class="kt">Pytorch</span> <span class="n">release</span> <span class="err">版本时使用的</span> <span class="n">cuda</span> <span class="err">版本</span>
<span class="kr">import</span> <span class="nn">torch</span>
<span class="n">torch</span><span class="o">.</span><span class="n">version</span><span class="o">.</span><span class="n">cuda</span> 
<span class="o">#</span> <span class="n">'10</span><span class="o">.</span><span class="mi">2</span><span class="n">'</span>
</code></pre></div></div> <ul> <li>Pytorch 寻找 cuda 的流程 <ul> <li>环境变量 CUDA_HOME 或 CUDA_PATH</li> <li>/usr/local/cuda</li> <li>which nvcc 的上级上级目录（which nvcc 会在环境变量 PATH 中找）</li> <li>如果上述都不存在，则 torch.utils.cpp_extension.CUDA_HOME 为 None，会使用 conda 安装的 cudatoolkit，其路径为 cudart 库文件目录的上级目录（此时可能是通过 conda 安装的 cudatoolkit，一般直接用 conda install cudatoolkit，就是在这里搜索到 cuda 库的）。</li> </ul> </li> </ul> <h2 id="进度条库-tqdm">进度条库 tqdm</h2> <ul> <li>参考文献：<a href="https://zhuanlan.zhihu.com/p/163613814" rel="external nofollow noopener" target="_blank">python 进度条库 tqdm 详解</a> </li> </ul> <div class="language-apache highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import time
<span class="nc">from</span> tqdm import tqdm, trange

<span class="c">#trange(i)是tqdm(range(i))的一种简单写法</span>
for i <span class="ss">in</span> trange(100):
    time.sleep(0.05)

for i <span class="ss">in</span> tqdm(range(100), desc='Processing'):
    time.sleep(0.05)

dic = ['a', 'b', 'c', 'd', 'e']
pbar = tqdm(dic)
for i <span class="ss">in</span> pbar:
    pbar.set_description('Processing '+i)
    time.sleep(0.2)
100%|██████████| 100/100 [00:06&lt;00:00, 16.04it/s]
Processing: 100%|██████████| 100/100 [00:06&lt;00:00, 16.05it/s]
Processing e: 100%|██████████| 5/5 [00:01&lt;00:00,  4.69it/s]
</code></pre></div></div> <h3 id="label-的-bug">Label 的 bug</h3> <ul> <li>参考文献：<a href="https://blog.csdn.net/veritasalice/article/details/111917185" rel="external nofollow noopener" target="_blank">Pytorch 报错 CUDA error: device-side assert triggered_Dr. 卷心菜的博客-CSDN 博客</a> </li> <li>场景：在进行文本分类的时候，我遇到了一个问题，当 label 不是从 0 到 n 的数字时，直接就报错了！</li> </ul> <h2 id="opencv2-的一些实用">opencv2 的一些实用</h2> <h3 id="将视频中某时间段内的所有帧提取出来">将视频中某时间段内的所有帧提取出来</h3> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">cv2</span>

<span class="c1"># 定义视频文件路径
</span><span class="n">video_path</span> <span class="o">=</span> <span class="sh">"</span><span class="s">testdownload.mp4</span><span class="sh">"</span>

<span class="c1"># 定义提取的时间范围（单位：秒）
</span><span class="n">start_time</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">+</span> <span class="mi">17</span>  <span class="c1"># 1分17秒
</span><span class="n">end_time</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">+</span> <span class="mi">19</span>  <span class="c1"># 1分19秒
</span>
<span class="c1"># 打开视频文件
</span><span class="n">cap</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="nc">VideoCapture</span><span class="p">(</span><span class="n">video_path</span><span class="p">)</span>

<span class="c1"># 获取视频的帧率
</span><span class="n">fps</span> <span class="o">=</span> <span class="n">cap</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">cv2</span><span class="p">.</span><span class="n">CAP_PROP_FPS</span><span class="p">)</span>

<span class="c1"># 计算要提取的帧的起始和结束帧索引
</span><span class="n">start_frame</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="n">start_time</span> <span class="o">*</span> <span class="n">fps</span><span class="p">)</span>
<span class="n">end_frame</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="n">end_time</span> <span class="o">*</span> <span class="n">fps</span><span class="p">)</span>

<span class="c1"># 设置当前帧为起始帧
</span><span class="n">cap</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="n">cv2</span><span class="p">.</span><span class="n">CAP_PROP_POS_FRAMES</span><span class="p">,</span> <span class="n">start_frame</span><span class="p">)</span>

<span class="c1"># 循环读取视频帧并保存
</span><span class="n">frame_count</span> <span class="o">=</span> <span class="n">start_frame</span>
<span class="k">while</span> <span class="n">frame_count</span> <span class="o">&lt;=</span> <span class="n">end_frame</span><span class="p">:</span>
    <span class="c1"># 读取视频帧
</span>    <span class="n">ret</span><span class="p">,</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">cap</span><span class="p">.</span><span class="nf">read</span><span class="p">()</span>

    <span class="c1"># 如果读取成功，则保存帧图像
</span>    <span class="k">if</span> <span class="n">ret</span><span class="p">:</span>
        <span class="n">frame_file_path</span> <span class="o">=</span> <span class="sa">f</span><span class="sh">"</span><span class="s">frame_</span><span class="si">{</span><span class="n">frame_count</span><span class="si">}</span><span class="s">.jpg</span><span class="sh">"</span>
        <span class="n">cv2</span><span class="p">.</span><span class="nf">imwrite</span><span class="p">(</span><span class="n">frame_file_path</span><span class="p">,</span> <span class="n">frame</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Saved frame </span><span class="si">{</span><span class="n">frame_count</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>

    <span class="n">frame_count</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># 如果到达结束帧，则跳出循环
</span>    <span class="k">if</span> <span class="n">frame_count</span> <span class="o">&gt;</span> <span class="n">end_frame</span><span class="p">:</span>
        <span class="k">break</span>

<span class="c1"># 关闭视频文件
</span><span class="n">cap</span><span class="p">.</span><span class="nf">release</span><span class="p">()</span>
</code></pre></div></div> <h3 id="超分辨率">超分辨率</h3> <ul class="task-list"> <li class="task-list-item"> <input type="checkbox" class="task-list-item-checkbox" disabled>Waifu2x：主要用于动漫图片的 SR，但是很多高质量的 SR 需要花钱</li> <li class="task-list-item"> <input type="checkbox" class="task-list-item-checkbox" disabled>Image Upscaler[<a href="https://imgupscaler.com/" rel="external nofollow noopener" target="_blank">AI Image Upscaler - Upscale Photo, Cartoons in Batch Free (imgupscaler.com)</a>]： 有几次免费的机会，不知道 SR 的配置</li> <li class="task-list-item"> <input type="checkbox" class="task-list-item-checkbox" disabled>BigJPG[<a href="https://bigjpg.com/" rel="external nofollow noopener" target="_blank">Bigjpg - AI 人工智能图片无损放大 - 使用人工智能深度卷积神经网络(CNN)无损放大图片</a>]：好像是免费的，但是一次居然要排队 40 多分钟…</li> </ul> <h2 id="强化学习">强化学习</h2> <h3 id="a2c-的一个很好的例子">A2C 的一个很好的例子</h3> <ul> <li>参考文献：<a href="https://chowdera.com/2022/01/202201121625131237.html" rel="external nofollow noopener" target="_blank">https://chowdera.com/2022/01/202201121625131237.html</a> </li> </ul> <h3 id="loss-函数的问题">loss 函数的问题</h3> <ul> <li> <p>参考文献：<a href="https://www.cnblogs.com/yifanrensheng/p/13381934.html" rel="external nofollow noopener" target="_blank">https://www.cnblogs.com/yifanrensheng/p/13381934.html</a></p> <ul> <li>需要手动将 Loss 函数进行一次允许求导，不然会报错</li> <li>这个是因为没有将 requires_grad 设为 True，l=LOSS（out，label）中的 l 默认是 requires_grad 为 false，这个 l 其实也是一个张量 Tensor 类型，将其的 requires_grad 改为 True 后，使用 backward 函数就可以得到 requires_grad 为 True 的所有参数的梯度。</li> </ul> </li> <li> <p>参考文献：<a href="https://zhuanlan.zhihu.com/p/61379965" rel="external nofollow noopener" target="_blank">PyTorch 学习笔记（六）：PyTorch 的十八个损失函数</a></p> <ul> <li>这篇文章总结了所有可能需要的用到损失函数</li> </ul> </li> </ul> <h3 id="概率与采样">概率与采样</h3> <ul> <li>参考文献：<a href="https://zhuanlan.zhihu.com/p/343271979" rel="external nofollow noopener" target="_blank">https://zhuanlan.zhihu.com/p/343271979</a> <ul> <li>这是一篇很好的介绍策略学习算法的具体实现方式的文章，概率采样的内容在这里</li> </ul> </li> </ul> <div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">probs</span> <span class="o">=</span> self.policy_net<span class="o">(</span>state<span class="o">)</span>
<span class="nv">m</span> <span class="o">=</span> Bernoulli<span class="o">(</span>probs<span class="o">)</span>
<span class="c"># 公式6的实现：本质上是个分类问题,负号是为了将梯度上升转为梯度下降
</span><span class="nv">loss</span> <span class="o">=</span> <span class="nt">-m</span>.log_prob<span class="o">(</span>action<span class="o">)</span> <span class="k">*</span> reward  <span class="c"># Negtive score function x reward</span>
</code></pre></div></div> <ul> <li>参考文献：<a href="https://zhuanlan.zhihu.com/p/138117543" rel="external nofollow noopener" target="_blank">https://zhuanlan.zhihu.com/p/138117543</a> <ul> <li>这是一篇介绍多标签问题的解决方案。</li> <li>从 n 选 1 推进到 n 选 k</li> </ul> </li> </ul> <h3 id="策略网络的训练问题">策略网络的训练问题</h3> <ul> <li>参考文献 1：<a href="https://zhuanlan.zhihu.com/p/343271979" rel="external nofollow noopener" target="_blank">https://zhuanlan.zhihu.com/p/343271979</a> </li> <li>参考文献 2：</li> </ul> <h2 id="matplot-画图">matplot 画图</h2> <h3 id="log-坐标轴与刻度">log 坐标轴与刻度</h3> <ul> <li>参考文献：<a href="https://juejin.cn/post/7083780870611402788" rel="external nofollow noopener" target="_blank">https://juejin.cn/post/7083780870611402788</a> </li> <li>代码</li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">25</span><span class="p">,</span><span class="mi">30</span><span class="p">]</span>
<span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>

<span class="n">fig</span><span class="o">=</span><span class="n">plt</span><span class="p">.</span><span class="nf">figure</span><span class="p">()</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="p">.</span><span class="nf">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="sh">'</span><span class="s">v</span><span class="sh">'</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="sh">'</span><span class="s">r</span><span class="sh">'</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sh">'</span><span class="s">example</span><span class="sh">'</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="nf">legend</span><span class="p">(</span> <span class="n">loc</span><span class="o">=</span><span class="p">(</span><span class="mf">1.36</span><span class="o">/</span><span class="mi">5</span><span class="p">,</span><span class="mf">0.05</span><span class="o">/</span><span class="mi">5</span><span class="p">),</span><span class="n">ncol</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span> <span class="c1">#fontsize=10，loc是图例左下角所在的点的x和y值，ncol是图例分几列显示
</span><span class="n">ax</span><span class="p">.</span><span class="nf">grid</span><span class="p">()</span> <span class="c1"># 网格
</span>
<span class="n">ax</span><span class="p">.</span><span class="nf">set_xlabel</span><span class="p">(</span><span class="sh">'</span><span class="s">x</span><span class="sh">'</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">13</span><span class="p">)</span> <span class="c1"># 坐标轴标签
</span><span class="n">ax</span><span class="p">.</span><span class="nf">set_xlim</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">30</span><span class="p">)</span> <span class="c1"># x轴只显示5到30区间
</span><span class="n">ax</span><span class="p">.</span><span class="nf">set_xticks</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="c1"># x轴上的刻度显示，可以把x改成字符串列表
</span>
<span class="n">ax</span><span class="p">.</span><span class="nf">set_ylabel</span><span class="p">(</span><span class="sh">'</span><span class="s">y</span><span class="sh">'</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">13</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="nf">set_ylim</span><span class="p">(</span><span class="mf">0.25</span><span class="p">,</span><span class="mi">52</span><span class="p">)</span> <span class="c1"># y 轴只显示0.25到52区间
</span><span class="n">ax</span><span class="p">.</span><span class="nf">set_yscale</span><span class="p">(</span><span class="sh">"</span><span class="s">log</span><span class="sh">"</span><span class="p">,</span><span class="n">base</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span><span class="n">subs</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span> <span class="c1"># y 轴上以4为底数呈对数显示，2、3表示会标记出2倍、3倍的位置
# ax.set_yticks([0,2,8,32]) # 用了log就不能用这个
</span><span class="n">ax</span><span class="p">.</span><span class="nf">set_yticklabels</span><span class="p">([</span><span class="sh">'</span><span class="s">0</span><span class="sh">'</span><span class="p">,</span><span class="sh">'</span><span class="s">0.25</span><span class="sh">'</span><span class="p">,</span><span class="sh">'</span><span class="s">1</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">4</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">16</span><span class="sh">'</span><span class="p">])</span> <span class="c1"># 使y轴上刻度显示为这几个数，其中第一个数必须是0
</span><span class="n">ax</span><span class="p">.</span><span class="nf">set_zorder</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</code></pre></div></div> <h3 id="legend-相关问题">legend 相关问题</h3> <ul> <li>调整图例间距：<a href="https://blog.csdn.net/qq_41645987/article/details/109147034" rel="external nofollow noopener" target="_blank">https://blog.csdn.net/qq_41645987/article/details/109147034</a> </li> <li>水平 legend: ncol</li> <li>legend 的手动调整与微移动：<a href="https://www.cnblogs.com/IvyWong/p/9916791.html" rel="external nofollow noopener" target="_blank">https://www.cnblogs.com/IvyWong/p/9916791.html</a> </li> </ul> <h2 id="file-读写文件">File 读写文件</h2> <ul> <li><a href="https://www.delftstack.com/zh/howto/python/python-create-file-if-not-exists/" rel="external nofollow noopener" target="_blank">https://www.delftstack.com/zh/howto/python/python-create-file-if-not-exists/</a></li> </ul> <h2 id="mmap-内存映射文件">mmap 内存映射文件</h2> <h3 id="mmap-的原理和底层-c-函数介绍">Mmap 的原理和底层 C 函数介绍</h3> <ul> <li>参考文献：<a href="https://www.cnblogs.com/huxiao-tee/p/4660352.html" rel="external nofollow noopener" target="_blank">认真分析 mmap：是什么 为什么 怎么用 - 胡潇 - 博客园 (cnblogs.com)</a> </li> </ul> <h3 id="利用-mmap-写一个布隆过滤器">利用 mmap 写一个布隆过滤器</h3> <ul> <li> <p>参考文献</p> <ul> <li>比较好理解的版本：<a href="https://www.cnblogs.com/throwable/p/14490280.html" rel="external nofollow noopener" target="_blank">冷饭新炒：理解布隆过滤器算法的实现原理 - throwable - 博客园 (cnblogs.com)</a> </li> <li>布隆过滤器针对缓存场景：【为什么用布隆过滤器解决缓存问题】如何应对缓存问题 — G.Fukang’s Blog (gongfukangee.github.io)</li> <li>布隆过滤器针对缓存场景：【如何利用布隆过滤器解决缓存问题】MeetingFilm/布隆过滤器解决缓存穿透.md at master · daydreamdev/MeetingFilm · GitHub</li> <li>不是很好理解的版本：<a href="https://blog.csdn.net/preyta/article/details/72970887" rel="external nofollow noopener" target="_blank">用 Python 从零开始实现一个 Bloomfilter_烟火君的博客-CSDN 博客</a> </li> </ul> </li> <li> <p>github 地址（一个很好的学习资料）：<a href="https://github.com/preytaren/fastbloom" rel="external nofollow noopener" target="_blank">GitHub - preytaren/fastbloom: A simple but fast bloomfilter written in Python</a></p> </li> </ul> <h2 id="logging">Logging</h2> <div class="language-coffeescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">logging</span>

<span class="nx">def</span> <span class="nx">get_logger</span><span class="p">(</span><span class="nx">logging_file</span><span class="p">,</span> <span class="nx">enable_multiprocess</span><span class="p">,</span> <span class="nx">showing_stdout_level</span><span class="o">=</span><span class="nx">logging</span><span class="p">.</span><span class="na">INFO</span><span class="p">)</span><span class="o">:</span>
    <span class="nx">logger</span> <span class="o">=</span> <span class="nx">logging</span><span class="p">.</span><span class="na">getLogger</span><span class="p">(</span><span class="nx">__name__</span><span class="p">)</span>
    <span class="nx">logger</span><span class="p">.</span><span class="na">setLevel</span><span class="p">(</span><span class="nx">logging</span><span class="p">.</span><span class="na">DEBUG</span><span class="p">)</span>
    
    <span class="nx">file_ch</span> <span class="o">=</span> <span class="nx">logging</span><span class="p">.</span><span class="na">FileHandler</span><span class="p">(</span><span class="nx">logging_file</span><span class="p">)</span>
    <span class="nx">file_ch</span><span class="p">.</span><span class="na">setLevel</span><span class="p">(</span><span class="nx">logging</span><span class="p">.</span><span class="na">DEBUG</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="na">enable_multiprocess</span><span class="o">:</span>
        <span class="nx">file_formatter</span> <span class="o">=</span> <span class="nx">logging</span><span class="p">.</span><span class="na">Formatter</span><span class="p">(</span><span class="s">'%(asctime)s [%(levelname)s] at [process_id: %(process)d] %(filename)s,%(lineno)d: %(message)s'</span><span class="p">,</span> 
                                            <span class="nx">datefmt</span><span class="o">=</span><span class="s">'%Y-%m-%d(%a)%H:%M:%S'</span><span class="p">)</span>
    <span class="na">else</span><span class="o">:</span>
        <span class="nx">file_formatter</span> <span class="o">=</span> <span class="nx">logging</span><span class="p">.</span><span class="na">Formatter</span><span class="p">(</span><span class="s">'%(asctime)s [%(levelname)s] at %(filename)s,%(lineno)d: %(message)s'</span><span class="p">,</span> 
                                            <span class="nx">datefmt</span><span class="o">=</span><span class="s">'%Y-%m-%d(%a)%H:%M:%S'</span><span class="p">)</span>
    <span class="nx">file_ch</span><span class="p">.</span><span class="na">setFormatter</span><span class="p">(</span><span class="nx">file_formatter</span><span class="p">)</span>
    <span class="nx">logger</span><span class="p">.</span><span class="na">addHandler</span><span class="p">(</span><span class="nx">file_ch</span><span class="p">)</span>

    <span class="c1">#将大于或等于INFO级别的日志信息输出到StreamHandler(默认为标准错误)</span>
    <span class="nx">console</span> <span class="o">=</span> <span class="nx">logging</span><span class="p">.</span><span class="na">StreamHandler</span><span class="p">()</span>
    <span class="nx">console</span><span class="p">.</span><span class="na">setLevel</span><span class="p">(</span><span class="nx">showing_stdout_level</span><span class="p">)</span> 
    <span class="nx">formatter</span> <span class="o">=</span> <span class="nx">logging</span><span class="p">.</span><span class="na">Formatter</span><span class="p">(</span><span class="s">'[%(levelname)-8s] %(message)s'</span><span class="p">)</span>
    <span class="nx">console</span><span class="p">.</span><span class="na">setFormatter</span><span class="p">(</span><span class="nx">formatter</span><span class="p">)</span>
    <span class="nx">logger</span><span class="p">.</span><span class="na">addHandler</span><span class="p">(</span><span class="nx">console</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">logger</span>
</code></pre></div></div> <h2 id="profiler-专题">Profiler 专题</h2> <h3 id="时间-profiler">时间 Profiler</h3> <ul> <li><a href="https://github.com/pyutils/line_profiler" rel="external nofollow noopener" target="_blank">pyutils/line_profiler: Line-by-line profiling for Python (github.com)</a></li> </ul> <h3 id="空间-profiler">空间 Profiler</h3> <ul> <li><a href="https://github.com/pythonprofilers/memory_profiler" rel="external nofollow noopener" target="_blank">pythonprofilers/memory_profiler: Monitor Memory usage of Python code (github.com)</a></li> </ul> </div> </article> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2024 Linchang Xiao. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?7b30caa5023af4af8408a472dc4e1ebb"></script> <script defer src="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js?d633890033921b33e0ceb13d22340a9c"></script> <script defer src="/assets/js/common.js?acdb9690d7641b2f8d40529018c71a01"></script> <script defer src="/assets/js/copy_code.js?9b43d6e67ddc7c0855b1478ee4c48c2d" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>